category: Data Enrichment & Threat Intelligence
commonfields:
  id: ExportIndicators
  version: -1
configuration:
- additionalinfo: The query to run to update its list. To view expected results, you
    can run the following command from the Demisto CLI `!findIndicators query=<your
    query>`
  defaultvalue: ""
  display: Indicator Query
  name: indicators_query
  required: false
  type: 0
- defaultvalue: text
  display: Outbound Format
  name: format
  options:
  - text
  - json
  - json-seq
  - csv
  required: false
  type: 15
- additionalinfo: Maximum number of items in the export list
  defaultvalue: "2500"
  display: List Size
  name: list_size
  required: true
  type: 0
- additionalinfo: When selected this will prevent automatic refresh of the indicators
    export list
  defaultvalue: ""
  display: Update On-Demand Only
  name: on_demand
  required: false
  type: 8
- additionalinfo: How often to refresh the export indicators list
  defaultvalue: 5 minutes
  display: Refresh Rate
  name: cache_refresh_rate
  required: false
  type: 0
- defaultvalue: "true"
  display: Long Running Instance
  name: longRunning
  required: false
  type: 8
- additionalinfo: Will run the export indicators service on this port from within
    Cortex SOAR
  defaultvalue: "7000"
  display: Listen Port
  name: longRunningPort
  required: true
  type: 0
- defaultvalue: ""
  display: Certificate (Required for HTTPS)
  name: certificate
  required: false
  type: 12
- defaultvalue: ""
  display: Private Key (Required for HTTPS)
  name: key
  required: false
  type: 14
- additionalinfo: Ignores certificate and private key, and will run the export indicators
    service in HTTP
  defaultvalue: ""
  display: HTTP Server
  name: http_flag
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Use the Export Indicators Service integration to provide an endpoint
  with a list of indicators as a service for the system indicators.
detaileddescription: "# How to Access the Export Indicators Service\n\nThere are two
  ways that you can access the service:\n- **https://*demisto_address*/instance/execute/*instance_name***
  \n- **http://*demisto_address*:*listen_port***\n\n# Access the Service by Instance
  Name\nTo access the service by instance name, make sure ***Instance execute external***
  is enabled. \n\n1. In Demisto, go to **Settings > About > Troubleshooting**.\n2.
  In the **Server Configuration** section, verify that the ***instance.execute.external***
  key is set to *true*. If this key does not exist, click **+ Add Server Configuration**
  and add the *instance.execute.external* and set the value to *true*.\n"
display: Export Indicators Service
image: data:image/png;base64,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
name: ExportIndicators
script:
  commands:
  - arguments:
    - description: The query used to retrieve indicators from the system.
      name: query
      required: true
    - auto: PREDEFINED
      defaultValue: text
      description: The output format. Can be "text", "json", "json-seq", or "csv".
      name: format
      predefined:
      - text
      - json
      - json-seq
      - csv
    - description: The maximum number of entries in the output. If no value is provided,
        will use the value specified in the List Size parameter configured in the
        instance configuration.
      name: list_size
    - defaultValue: "false"
      description: Whether to print the indicators. If set to true will print the
        indicators the that were saved to the export indicators service. The default
        value is "false".
      name: print_indicators
      predefined:
      - "false"
      - "true"
      required: true
    description: Updates values stored in the export indicators service (only avaialable
      On-Demand).
    name: eis-update
  dockerimage: demisto/teams:1.0.0.4937
  longRunning: true
  longRunningPort: true
  runonce: false
  script: |2-



    import json
    from flask import Flask, Response
    from gevent.pywsgi import WSGIServer
    from tempfile import NamedTemporaryFile
    from typing import Callable, List, Any

    ''' GLOBAL VARIABLES '''
    INTEGRATION_NAME: str = 'Export Indicators Service'
    PAGE_SIZE: int = 200
    APP: Flask = Flask('demisto-export_iocs')
    CTX_VALUES_KEY: str = 'dmst_export_iocs_values'
    CTX_MIMETYPE_KEY: str = 'dmst_export_iocs_mimetype'
    FORMAT_CSV: str = 'csv'
    FORMAT_TEXT: str = 'text'
    FORMAT_JSON_SEQ: str = 'json-seq'
    FORMAT_JSON: str = 'json'
    CTX_LIMIT_ERR_MSG: str = 'Please provide a valid integer for List Size'
    CTX_MISSING_REFRESH_ERR_MSG: str = 'Refresh Rate must be "number date_range_unit", examples: (2 hours, 4 minutes, ' \
                                       '6 months, 1 day, etc.)'

    ''' HELPER FUNCTIONS '''


    def list_to_str(inp_list: list, delimiter: str = ',', map_func: Callable = str) -> str:
        """
        Transforms a list to an str, with a custom delimiter between each list item
        """
        str_res = ""
        if inp_list:
            if isinstance(inp_list, list):
                str_res = delimiter.join(map(map_func, inp_list))
            else:
                raise AttributeError('Invalid inp_list provided to list_to_str')
        return str_res


    def get_params_port(params: dict = demisto.params()) -> int:
        """
        Gets port from the integration parameters
        """
        port_mapping: str = params.get('longRunningPort', '')
        err_msg: str
        port: int
        if port_mapping:
            err_msg = f'Listen Port must be an integer. {port_mapping} is not valid.'
            if ':' in port_mapping:
                port = try_parse_integer(port_mapping.split(':')[1], err_msg)
            else:
                port = try_parse_integer(port_mapping, err_msg)
        else:
            raise ValueError('Please provide a Listen Port.')
        return port


    def refresh_outbound_context(indicator_query: str, out_format: str, limit: int = 0) -> str:
        """
        Refresh the cache values and format using an indicator_query to call demisto.searchIndicators
        Returns: List(IoCs in output format)
        """
        now = datetime.now()
        iocs = find_indicators_with_limit(indicator_query, limit)  # poll indicators into list from demisto
        out_dict = create_values_out_dict(iocs, out_format)
        out_dict[CTX_MIMETYPE_KEY] = 'application/json' if out_format == FORMAT_JSON else 'text/plain'
        save_context(now, out_dict)
        return out_dict[CTX_VALUES_KEY]


    def save_context(now: datetime, out_dict: dict):
        """Saves export_iocs state and refresh time to context"""
        demisto.setLastRun({'last_run': date_to_timestamp(now)})
        demisto.setIntegrationContext(out_dict)


    def find_indicators_with_limit(indicator_query: str, limit: int) -> list:
        """
        Finds indicators using demisto.searchIndicators
        """
        iocs, _ = find_indicators_with_limit_loop(indicator_query, limit)
        return iocs[:limit]


    def find_indicators_with_limit_loop(indicator_query: str, limit: int, total_fetched: int = 0, next_page: int = 0,
                                        last_found_len: int = PAGE_SIZE):
        """
        Finds indicators using while loop with demisto.searchIndicators, and returns result and last page
        """
        iocs: List[dict] = []
        if not last_found_len:
            last_found_len = total_fetched
        while last_found_len == PAGE_SIZE and limit and total_fetched < limit:
            fetched_iocs = demisto.searchIndicators(query=indicator_query, page=next_page, size=PAGE_SIZE).get('iocs')
            iocs.extend(fetched_iocs)
            last_found_len = len(fetched_iocs)
            total_fetched += last_found_len
            next_page += 1
        return iocs, next_page


    def create_values_out_dict(iocs: list, out_format: str) -> dict:
        """
        Create a dictionary for output values using the selected format (json, json-seq, text, csv)
        """
        if out_format == FORMAT_JSON:  # handle json separately
            iocs_list = [ioc for ioc in iocs]
            return {CTX_VALUES_KEY: json.dumps(iocs_list)}
        else:
            formatted_indicators = []
            if out_format == FORMAT_CSV and len(iocs) > 0:  # add csv keys as first item
                headers = list(iocs[0].keys())
                formatted_indicators.append(list_to_str(headers))
            for ioc in iocs:
                value = ioc.get('value')
                if value:
                    if out_format == FORMAT_TEXT:
                        formatted_indicators.append(value)
                    elif out_format == FORMAT_JSON_SEQ:
                        formatted_indicators.append(json.dumps(ioc))
                    elif out_format == FORMAT_CSV:
                        # wrap csv values with " to escape them
                        values = list(ioc.values())
                        formatted_indicators.append(list_to_str(values, map_func=lambda val: f'"{val}"'))
        return {CTX_VALUES_KEY: list_to_str(formatted_indicators, '\n')}


    def get_outbound_mimetype() -> str:
        """Returns the mimetype of the export_iocs"""
        ctx = demisto.getIntegrationContext()
        return ctx.get(CTX_MIMETYPE_KEY, 'text/plain')


    def get_outbound_ioc_values(on_demand, limit, indicator_query='', out_format='text', last_run=None,
                                cache_refresh_rate=None) -> str:
        """
        Get the ioc list to return in the list
        """
        # on_demand ignores cache
        if on_demand:
            values_str = get_ioc_values_str_from_context()
        else:
            if last_run:
                cache_time, _ = parse_date_range(cache_refresh_rate, to_timestamp=True)
                if last_run <= cache_time:
                    values_str = refresh_outbound_context(indicator_query, out_format, limit=limit)
                else:
                    values_str = get_ioc_values_str_from_context()
            else:
                values_str = refresh_outbound_context(indicator_query, out_format, limit=limit)
        return values_str


    def get_ioc_values_str_from_context() -> str:
        """
        Extracts output values from cache
        """
        cache_dict = demisto.getIntegrationContext()
        return cache_dict.get(CTX_VALUES_KEY, '')


    def try_parse_integer(int_to_parse: Any, err_msg: str) -> int:
        """
        Tries to parse an integer, and if fails will throw DemistoException with given err_msg
        """
        try:
            res = int(int_to_parse)
        except (TypeError, ValueError):
            raise DemistoException(err_msg)
        return res


    ''' ROUTE FUNCTIONS '''


    @APP.route('/', methods=['GET'])
    def route_list_values() -> Response:
        """
        Main handler for values saved in the integration context
        """
        params = demisto.params()
        values = get_outbound_ioc_values(
            out_format=params.get('format'),
            on_demand=params.get('on_demand'),
            limit=try_parse_integer(params.get('list_size'), CTX_LIMIT_ERR_MSG),
            last_run=demisto.getLastRun().get('last_run'),
            indicator_query=params.get('indicators_query'),
            cache_refresh_rate=params.get('cache_refresh_rate')
        )
        mimetype = get_outbound_mimetype()
        return Response(values, status=200, mimetype=mimetype)


    ''' COMMAND FUNCTIONS '''


    def test_module(args, params):
        """
        Validates:
            1. Valid port.
            2. Valid cache_refresh_rate
        """
        get_params_port(params)
        on_demand = params.get('on_demand', None)
        if not on_demand:
            try_parse_integer(params.get('list_size'), CTX_LIMIT_ERR_MSG)  # validate export_iocs Size was set
            query = params.get('indicators_query')  # validate indicators_query isn't empty
            if not query:
                raise ValueError('"Indicator Query" is required. Provide a valid query.')
            cache_refresh_rate = params.get('cache_refresh_rate', '')
            if not cache_refresh_rate:
                raise ValueError(CTX_MISSING_REFRESH_ERR_MSG)
            # validate cache_refresh_rate value
            range_split = cache_refresh_rate.split(' ')
            if len(range_split) != 2:
                raise ValueError(CTX_MISSING_REFRESH_ERR_MSG)
            try_parse_integer(range_split[0], 'Invalid time value for the Refresh Rate. Must be a valid integer.')
            if not range_split[1] in ['minute', 'minutes', 'hour', 'hours', 'day', 'days', 'month', 'months', 'year',
                                      'years']:
                raise ValueError(
                    'Invalid time unit for the Refresh Rate. Must be minutes, hours, days, months, or years.')
            parse_date_range(cache_refresh_rate, to_timestamp=True)
        return 'ok', {}, {}


    def run_long_running(params):
        """
        Starts the long running thread.
        """
        certificate: str = params.get('certificate', '')
        private_key: str = params.get('key', '')
        http_server: bool = params.get('http_flag', True)

        certificate_path = str()
        private_key_path = str()

        try:
            port = get_params_port(params)
            ssl_args = dict()

            if certificate and private_key and not http_server:
                certificate_file = NamedTemporaryFile(delete=False)
                certificate_path = certificate_file.name
                certificate_file.write(bytes(certificate, 'utf-8'))
                certificate_file.close()
                ssl_args['certfile'] = certificate_path

                private_key_file = NamedTemporaryFile(delete=False)
                private_key_path = private_key_file.name
                private_key_file.write(bytes(private_key, 'utf-8'))
                private_key_file.close()
                ssl_args['keyfile'] = private_key_path
                demisto.debug('Starting HTTPS Server')
            else:
                demisto.debug('Starting HTTP Server')

            server = WSGIServer(('', port), APP, **ssl_args)
            server.serve_forever()
        except Exception as e:
            if certificate_path:
                os.unlink(certificate_path)
            if private_key_path:
                os.unlink(private_key_path)
            demisto.error(f'An error occurred in long running loop: {str(e)}')
            raise ValueError(str(e))


    def update_outbound_command(args, params):
        """
        Updates the export_iocs values and format on demand
        """
        on_demand = demisto.params().get('on_demand')
        if not on_demand:
            raise DemistoException(
                '"Update exported IOCs On Demand" is off. If you want to update manually please toggle it on.')
        limit = try_parse_integer(args.get('list_size', params.get('list_size')), CTX_LIMIT_ERR_MSG)
        print_indicators = args.get('print_indicators')
        query = args.get('query')
        out_format = args.get('format')
        indicators = refresh_outbound_context(query, out_format, limit=limit)
        hr = tableToMarkdown('List was updated successfully with the following values', indicators,
                             ['Indicators']) if print_indicators == 'true' else 'List was updated successfully'
        return hr, {}, indicators


    def main():
        """
        Main
        """
        params = demisto.params()
        command = demisto.command()
        demisto.debug('Command being called is {}'.format(command))
        commands = {
            'test-module': test_module,
            'eis-update': update_outbound_command
        }

        try:
            if command == 'long-running-execution':
                run_long_running(params)
            else:
                readable_output, outputs, raw_response = commands[command](demisto.args(), params)
                return_outputs(readable_output, outputs, raw_response)
        except Exception as e:
            err_msg = f'Error in {INTEGRATION_NAME} Integration [{e}]'
            return_error(err_msg)


    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
