category: Network Security
commonfields:
  id: Cisco ASA
  version: -1
configuration:
- defaultvalue: ""
  display: Server URL (e.g. https://192.168.0.1)
  name: server
  required: true
  type: 0
- defaultvalue: ""
  display: Credentials
  name: credentials
  required: true
  type: 9
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: is ASAv
  name: isASAv
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Use the Cisco Adaptive Security Appliance Software integration to manage
  interfaces, rules, and network objects.
detaileddescription: |
  ## Configuring Cisco ASA

  ---
  Install and enable Cisco ASA API using the guide [here](https://www.cisco.com/c/en/us/td/docs/security/asa/api/qsg-asa-api.html#56532).
  You **must** install the API in order to run the integration from Demisto.
  If you are using ASAv (Cisco Adaptive Security Virtual Appliance) don't forget to check the ASAv box.
display: Cisco ASA
image: data:image/png;base64,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
name: Cisco ASA
script:
  commands:
  - arguments:
    - description: The name of the interface from which to get rules.
      name: interface_name
    - auto: PREDEFINED
      description: 'The interface type. Can be "In", "Out", or "Global". '
      name: interface_type
      predefined:
      - In
      - Out
      - Global
    description: Gets a list all rules for the supplied interface.
    name: cisco-asa-list-rules
    outputs:
    - contextPath: CiscoASA.Rules.Source
      description: The rule's source.
      type: String
    - contextPath: CiscoASA.Rules.Dest
      description: The rule's destination.
      type: String
    - contextPath: CiscoASA.Rules.InterfaceType
      description: The interface type. Can be "In", "Out", or "Global".
      type: String
    - contextPath: CiscoASA.Rules.IsActive
      description: Whether the rule is active.
      type: Boolean
    - contextPath: CiscoASA.Rules.Interface
      description: The name of the interface.
      type: String
    - contextPath: CiscoASA.Rules.Position
      description: The position of the rule.
      type: Number
    - contextPath: CiscoASA.Rules.ID
      description: The rule ID.
      type: String
    - contextPath: CiscoASA.Rules.Remarks
      description: A list of all rule remarks.
      type: Unknown
    - contextPath: CiscoASA.Rules.Permit
      description: Whether the rule permits traffic from source to destination.
      type: Boolean
    - contextPath: CiscoASA.Rules.DestService
      description: The destination service.
      type: String
    - contextPath: CiscoASA.Rules.SourceService
      description: The source service.
      type: String
  - arguments:
    - description: The name of the backup.
      name: backup_name
      required: true
    - description: The passphrase for the backup.
      name: passphrase
    description: Creates a backup of the current settings (i.e., the backup.cfg file).
    name: cisco-asa-backup
  - arguments:
    - description: The rule ID.
      name: rule_id
      required: true
    - description: The name of the interface.
      name: interface_name
    - auto: PREDEFINED
      description: The interface type. Can be "In", "Out", or "Global".
      name: interface_type
      predefined:
      - In
      - Out
      - Global
      required: true
    description: Gets a specific rule by rule ID.
    name: cisco-asa-get-rule-by-id
    outputs:
    - contextPath: CiscoASA.Rules.Interface
      description: The name of the interface.
      type: String
    - contextPath: CiscoASA.Rules.Source
      description: The rule's source.
      type: String
    - contextPath: CiscoASA.Rules.Dest
      description: The rule's destination.
      type: String
    - contextPath: CiscoASA.Rules.InterfaceType
      description: The interface type. Can be "In", "Out", or "Global".
      type: String
    - contextPath: CiscoASA.Rules.IsActive
      description: Whether the rule is active.
      type: Boolean
    - contextPath: CiscoASA.Rules.Position
      description: The position of the rule.
      type: Number
    - contextPath: CiscoASA.Rules.ID
      description: The rule ID.
      type: String
    - contextPath: CiscoASA.Rules.Remarks
      description: A list of all rule remarks.
      type: Unknown
    - contextPath: CiscoASA.Rules.Permit
      description: Whether the rule permits traffic from source to destination.
      type: Boolean
    - contextPath: CiscoASA.Rules.DestService
      description: The destination service.
      type: String
    - contextPath: CiscoASA.Rules.SourceService
      description: The source service.
      type: String
  - arguments:
    - description: The source. Can be the value of an IPv4, an address block, or the
        name of a network object.
      name: source
      required: true
    - description: The destination. Can be the value of an IPv4, an address block,
        or the name of a network object.
      name: destination
      required: true
    - auto: PREDEFINED
      description: Whether the rule is a permit. If True, the rule is a permit.
      name: permit
      predefined:
      - "True"
      - "False"
      required: true
    - description: A list of remarks for the rule.
      isArray: true
      name: remarks
    - description: 'The position in which to create the rule. '
      name: position
    - auto: PREDEFINED
      description: The log level of the rule. Can be "Default", "Emergencies", "Alerts",
        "Critical", "Errors", "Warnings", "Notifications", "Informational", or "Debugging".
      name: log_level
      predefined:
      - Default
      - Emergencies
      - Alerts
      - Critical
      - Errors
      - Warnings
      - Notifications
      - Informational
      - Debugging
    - auto: PREDEFINED
      description: Whether the rule will be active. If True, the rule will be active.
      name: active
      predefined:
      - "True"
      - "False"
    - auto: PREDEFINED
      description: The interface type. Can be "In", "Out", or "Global".
      name: interface_type
      predefined:
      - In
      - Out
      - Global
      required: true
    - description: The interface name.
      name: interface_name
    - description: The service of the rule.
      name: service
    description: Creates a rule.
    name: cisco-asa-create-rule
    outputs:
    - contextPath: CiscoASA.Rules.Source
      description: The rule's source.
      type: String
    - contextPath: CiscoASA.Rules.Dest
      description: The rule's destination.
      type: String
    - contextPath: CiscoASA.Rules.InterfaceType
      description: The interface type. Can be "In", "Out", or "Global".
      type: String
    - contextPath: CiscoASA.Rules.IsActive
      description: Whether the rule is active.
      type: Boolean
    - contextPath: CiscoASA.Rules.Interface
      description: The name of the interface.
      type: String
    - contextPath: CiscoASA.Rules.Position
      description: The position of the rule.
      type: Number
    - contextPath: CiscoASA.Rules.ID
      description: The rule ID.
      type: String
    - contextPath: CiscoASA.Rules.Remarks
      description: A list of all rule remarks.
      type: Unknown
    - contextPath: CiscoASA.Rules.Permit
      description: Whether the rule permits traffic from source to destination.
      type: Boolean
    - contextPath: CiscoASA.Rules.DestService
      description: The destination service.
      type: String
    - contextPath: CiscoASA.Rules.SourceService
      description: The source service.
      type: String
  - arguments:
    - description: The rule ID.
      name: rule_id
      required: true
    - description: The name of the interface.
      name: interface_name
    - auto: PREDEFINED
      description: The interface type. Can be "In", "Out", or "Global".
      name: interface_type
      predefined:
      - In
      - Out
      - Global
      required: true
    description: Deletes a rule.
    name: cisco-asa-delete-rule
  - arguments:
    - auto: PREDEFINED
      description: The interface type. Can be "In", "Out", or "Global".
      name: interface_type
      predefined:
      - In
      - Out
      - Global
      required: true
    - description: The interface name.
      name: interface_name
    - description: The rule ID.
      name: rule_id
      required: true
    - auto: PREDEFINED
      description: Whether the rule will be active. If True, will be active.
      name: active
      predefined:
      - "True"
      - "False"
    - description: The log level of the rule.
      name: log_level
    - description: 'The position the rule will be in. '
      name: position
    - description: A list of remarks for the rule.
      isArray: true
      name: remarks
    - auto: PREDEFINED
      description: True if the rule is a permit.
      name: permit
      predefined:
      - "True"
      - "False"
    - description: The destination. Can be the value of an IPv4, an address block,
        or the name of a network object.
      name: destination
    - description: The source. Can be the value of an IPv4, an address block, or the
        name of a network object.
      name: source
    - description: The service of the rule.
      name: service
    description: Updates an existing rule.
    name: cisco-asa-edit-rule
    outputs:
    - contextPath: CiscoASA.Rules.Source
      description: The rule's source.
      type: String
    - contextPath: CiscoASA.Rules.Dest
      description: The rule's destination.
      type: String
    - contextPath: CiscoASA.Rules.InterfaceType
      description: The interface type. Can be "In", "Out", or "Global".
      type: String
    - contextPath: CiscoASA.Rules.IsActive
      description: Whether the rule is active.
      type: Boolean
    - contextPath: CiscoASA.Rules.Interface
      description: The name of the interface.
      type: String
    - contextPath: CiscoASA.Rules.Position
      description: The position of the rule.
      type: Number
    - contextPath: CiscoASA.Rules.ID
      description: The rule ID.
      type: String
    - contextPath: CiscoASA.Rules.Remarks
      description: A list of all rule remarks.
      type: Unknown
    - contextPath: CiscoASA.Rules.Permit
      description: Whether the rule permits traffic from source to destination.
      type: Boolean
    - contextPath: CiscoASA.Rules.DestService
      description: The destination service.
      type: String
    - contextPath: CiscoASA.Rules.SourceService
      description: The source service.
      type: String
  - arguments:
    - description: A comma-separated list of network object names for which to get
        the network.
      isArray: true
      name: object_name
    - description: A comma-separated list of object IDs for which to get the network
        object.
      isArray: true
      name: object_id
    description: Gets a list all configured network objects.
    name: cisco-asa-list-network-objects
    outputs:
    - contextPath: CiscoASA.NetworkObject.ID
      description: The ID of the network object.
      type: String
    - contextPath: CiscoASA.NetworkObject.Host
      description: The host information of the network object.
      type: String
    - contextPath: CiscoASA.NetworkObject.Description
      description: A description of the network object.
      type: String
    - contextPath: CiscoASA.NetworkObject.Name
      description: The name of the network object.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The type of network object to create.
      name: object_type
      predefined:
      - IPv4
      - IP-Network
      required: true
    - description: The name of the object to create.
      name: object_name
      required: true
    - description: The value of the network object to create.
      name: object_value
      required: true
    description: Creates a network object.
    name: cisco-asa-create-network-object
    outputs:
    - contextPath: CiscoASA.NetworkObject.ID
      description: The ID of the network object.
      type: String
    - contextPath: CiscoASA.NetworkObject.Host
      description: The host information of the network object.
      type: String
    - contextPath: CiscoASA.NetworkObject.Description
      description: A description of the network object, if exists.
      type: String
    - contextPath: CiscoASA.NetworkObject.Name
      description: The name of the network object.
      type: String
  - arguments: []
    description: Gets a list of all interfaces.
    name: cisco-asa-list-interfaces
    outputs:
    - contextPath: CiscoASA.Interface.ID
      description: The interface ID.
      type: String
    - contextPath: CiscoASA.Interface.Name
      description: The inteface name.
      type: String
    - contextPath: CiscoASA.Interface.Type
      description: The type of interface.
      type: String
  dockerimage: demisto/python3:3.7.4.977
  runonce: false
  script: |
    from typing import Optional

    import urllib3
    import traceback





    # Disable insecure warnings
    urllib3.disable_warnings()

    ''' GLOBAL VARIABLES'''

    INTEGRATION_COMMAND = "cisco-asa"
    OBJECT_TYPES_DICT = {
        'IPv4': 'IPv4Address',
        'IP-Network': 'IPv4Network'
    }

    '''Client'''


    class Client(BaseClient):
        isASAv = False
        auth_token = ""

        def login(self, isASAv) -> None:
            if isASAv:
                self.isASAv = True
                res = self._http_request('POST', '/api/tokenservices', resp_type='response')
                auth_token = res.headers._store.get('x-auth-token')[1]
                self._headers['X-Auth-Token'] = auth_token
                self.auth_token = auth_token

        def logoff(self):
            try:
                if self.isASAv and self.auth_token:
                    self._http_request('DELETE', f'/api/tokenservices/{self.auth_token}', resp_type='response')
            except Exception as e:
                # if failed to logoof just write to log. no need to raise error
                demisto.debug(f'Logoff error: {str(e)}')

        def get_all_rules(self, specific_interface: Optional[str] = None, rule_type: str = 'All') -> list:
            """
            Args:
                 specific_interface): the name of the interface
                 rule_type: All/Global/In

            Returns:
                 all rules in Cisco ASA of the specified type/interface
            """
            rules = []  # type: list
            # Get global rules
            if specific_interface is None and rule_type in ['All', 'Global']:
                res = self._http_request('GET', '/api/access/global/rules')
                items = res.get('items', [])
                for item in items:
                    item['interface_type'] = "Global"
                rules.extend(items)

            # Get in rules
            if rule_type in ['All', 'In']:
                res = self._http_request('GET', '/api/access/in')
                interfaces = []
                for item in res.get('items', []):
                    interface_name = item.get('interface', {}).get('name')
                    if interface_name and specific_interface and specific_interface == interface_name:
                        interfaces.append(interface_name)
                    if interface_name and not specific_interface:
                        interfaces.append(interface_name)
                for interface in interfaces:
                    res = self._http_request('GET', f'/api/access/in/{interface}/rules')
                    items = res.get('items', [])
                    for item in items:
                        item['interface'] = interface
                        item['interface_type'] = "In"
                    rules.extend(items)

            # Get out rules
            if rule_type in ['All', 'Out']:
                res = self._http_request('GET', '/api/access/out')
                interfaces = []
                for item in res.get('items', []):
                    interface_name = item.get('interface', {}).get('name')
                    if interface_name and specific_interface and specific_interface == interface_name:
                        interfaces.append(interface_name)
                    if interface_name and not specific_interface:
                        interfaces.append(interface_name)
                for interface in interfaces:
                    res = self._http_request('GET', f'/api/access/out/{interface}/rules')
                    items = res.get('items', [])
                    for item in items:
                        item['interface'] = interface
                        item['interface_type'] = "Out"
                    rules.extend(items)

            return rules

        def rule_action(self, rule_id: str, interface_name: str, interface_type: str, command: str = 'GET',
                        data: dict = None) -> dict:
            """

            Args:
                rule_id: The Rule ID.
                interface_name: the name of the interface.
                interface_type: The type of interface.
                command: What
                data:

            Returns:
                Does the command on the rule.
                Delete - delete rule
                GET - rule info
                PATCH - edit rule
            """
            resp_type = {"GET": "json",
                         "DELETE": "text",
                         "PATCH": "response"
                         }
            if interface_type == "Global":
                rule = self._http_request(command, f'/api/access/global/rules/{rule_id}', resp_type=resp_type[command],
                                          json_data=data)
            if interface_type == "In":
                rule = self._http_request(command, f'/api/access/in/{interface_name}/rules/{rule_id}',
                                          resp_type=resp_type[command], json_data=data)
            if interface_type == 'Out':
                rule = self._http_request(command, f'/api/access/out/{interface_name}/rules/{rule_id}',
                                          resp_type=resp_type[command], json_data=data)
            if command == 'GET':
                rule['interface'] = interface_name
                rule['interface_type'] = interface_type
            return rule

        def create_rule_request(self, interface_type: str, interface_name: str, rule_body: dict) -> dict:
            """

            Args:
                interface_type:
                interface_name:
                rule_body: The information about the rule.

            Returns:
                The new created rule's information.

            """
            if interface_type == "Global":
                res = self._http_request("POST", '/api/access/global/rules', json_data=rule_body, resp_type="response")
            if interface_type == 'In':
                res = self._http_request("POST", '/api/access/in/{}/rules'.format(interface_name), json_data=rule_body,
                                         resp_type="response")
            if interface_type == 'Out':
                res = self._http_request("POST", '/api/access/out/{}/rules'.format(interface_name), json_data=rule_body,
                                         resp_type="response")
            loc = res.headers.get("Location", "")
            rule = self._http_request('GET', loc[loc.find('/api'):])
            rule['interface'] = interface_name
            rule['interface_type'] = interface_type
            return rule

        def test_command_request(self):
            self._http_request("GET", "/api/aaa/authorization")

        def backup(self, data: dict):
            self._http_request("POST", "/api/backup", json_data=data, resp_type="response")

        def restore(self, data: dict):
            self._http_request("POST", "/api/restore", json_data=data, resp_type='response')

        def get_network_obejcts(self):
            obj_res = self._http_request('GET', '/api/objects/networkobjects')
            return obj_res.get('items', [])

        def create_object(self, obj_name, obj_type, obj_value):
            data = {
                "kind": "object#NetworkObj",
                "name": obj_name,
                "host": {
                    "kind": OBJECT_TYPES_DICT.get(obj_type),
                    "value": obj_value
                }
            }
            try:
                return self._http_request('POST', '/api/objects/networkobjects', json_data=data, ok_codes=(200, 201, 204),
                                          resp_type='response')
            except Exception:
                raise

        def list_interfaces(self):
            interfaces = list()  # type: ignore
            for type in ['global', 'in', 'out']:
                resp = self._http_request('GET', f'/api/access/{type}')
                interfaces.extend(resp.get('items', []))
            return interfaces


    '''HELPER COMMANDS'''
    @logger
    def set_up_ip_kind(dict_body: dict, field_to_add: str, data: str) -> None:
        """

        Args:
            dict_body: The dict to add the data to.
            field_to_add: the name of the field to add to json.
            data: the string to check its kind and insert to dict.

        Returns:
            Takes the data, checks what kind of source/dest it is (IP, network, any or network object) and inserts to the
            dict the field_to_add as key and the source/dest as value in the correct format.
        """
        if is_ip_valid(data):
            dict_body[field_to_add] = {"kind": "IPv4Address",
                                       "value": data}
        elif data == 'any':
            dict_body[field_to_add] = {"kind": "AnyIPAddress",
                                       "value": "any4"}
        elif '/' in data:
            dict_body[field_to_add] = {"kind": "IPv4Network",
                                       "value": data}
        else:
            dict_body[field_to_add] = {"kind": "objectRef#NetworkObj",
                                       "objectId": data}


    @logger
    def raw_to_rules(raw_rules):
        """
        :param raw_rules:
        :return:
        Gets raw rules as received from API and extracts only the relevant fields
        """
        rules = list()
        for rule in raw_rules:
            source_services = rule.get('sourceService', {})

            if isinstance(source_services, list):
                source_services_list = [v['value'] for v in source_services]
            else:
                source_services_list = source_services.get('value')

            dest_services = rule.get('destinationService', {})
            if isinstance(dest_services, list):
                dest_services_list = [v['value'] for v in dest_services]
            else:
                dest_services_list = dest_services.get('value')
            rules.append({"Source": rule.get('sourceAddress', {}).get('value'),
                          "SourceService": source_services_list,
                          "Dest": rule.get('destinationAddress', {}).get('value'),
                          "DestService": dest_services_list,
                          "IsActive": rule.get('active'),
                          "Interface": rule.get("interface"),
                          "InterfaceType": rule.get("interface_type"),
                          "Remarks": rule.get('remarks'),
                          "Position": rule.get('position'),
                          "ID": rule.get('objectId'),
                          'Permit': rule.get('permit')
                          })
            if not rules[-1].get('Source'):
                rules[-1]['Source'] = rule.get('sourceAddress', {}).get('objectId')
            if not rules[-1].get('Dest'):
                rules[-1]['Dest'] = rule.get('destinationAddress', {}).get('objectId')

        return rules


    '''COMMANDS'''


    @logger
    def list_rules_command(client: Client, args):
        """
        :param client:
        :param args: Interface_name - get rules from a specific interface.
                    Interface_type - get rules from a specific type of interface.
        :return: hr - human readable, outputs - context, raw

        Returns all rules.
        """
        interface = args.get('interface_name')
        interface_type = args.get('interface_type', 'All')

        try:
            raw_rules = client.get_all_rules(interface, interface_type)  # demisto.getRules() #
            rules = raw_to_rules(raw_rules)
            outputs = {'CiscoASA.Rules(val.ID && val.ID == obj.ID)': rules}
            hr = tableToMarkdown("Rules:", rules, ["ID", "Source", "Dest", "Permit", "Interface", "InterfaceType",
                                                   "IsActive", "Position", "SourceService", "destService"])
            return hr, outputs, raw_rules

        except Exception as e:
            if "404" in str(e) and interface:
                raise ValueError("Could not find interface")
            else:
                raise e


    @logger
    def backup_command(client: Client, args):
        """

        Args:
            client:
            args:

        Returns:
            Creates a backup. Returns a message if backup was created successfully.

        """
        location = "disk0:/" + args.get("backup_name")
        passphrase = args.get("passphrase")
        data = {'location': location}
        if passphrase:
            data['passphrase'] = passphrase

        client.backup(data)
        return f"Created backup successfully in:\nLocation: {location}\nPassphrase: {passphrase}", {}, ""


    @logger
    def restore_command(client: Client, args):
        location = "disk0:/" + args.get("backup_name")
        passphrase = args.get("passphrase")
        data = {'location': location}
        if passphrase:
            data['passphrase'] = passphrase

        client.restore(data)
        return "Restored backup successfully.", {}, ""


    @logger
    def rule_by_id_command(client: Client, args):
        rule_id = args.get('rule_id')
        interface_type = args.get('interface_type')
        interface = args.get('interface_name')

        if interface_type != "Global" and not interface:
            raise ValueError("Please state the name of the interface when it's not a global interface.")
        interface = "" if interface_type == "Global" else interface

        raw_rules = client.rule_action(rule_id, interface, interface_type, 'GET')
        rules = raw_to_rules([raw_rules])

        outputs = {'CiscoASA.Rules(val.ID && val.ID == obj.ID)': rules}
        hr = tableToMarkdown("Rule {}:".format(rule_id), rules, ["ID", "Source", "Dest", "Permit", "Interface",
                                                                 "InterfaceType", "IsActive", "Position", "SourceService",
                                                                 "destService"])
        return hr, outputs, raw_rules


    @logger
    def create_rule_command(client: Client, args):
        source = args.get('source')
        dest = args.get('destination')
        permit = args.get('permit')
        interface = args.get('interface_name')
        interface_type = args.get('interface_type')
        service = args.get('service', 'ip')

        interface = "" if interface_type == "Global" else interface
        if interface_type != "Global" and not interface:
            raise ValueError("For In/Out interfaces, an interface name is mandatory.")

        remarks = argToList(args.get('remarks'), ',')
        position = args.get('position')
        log_level = args.get('logging_level')
        active = args.get('active', 'True')

        rule_body = {}  # type: dict
        rule_body['sourceService'] = {"kind": "NetworkProtocol",
                                      "value": service}

        # Set up source
        set_up_ip_kind(rule_body, "sourceAddress", source)

        # Set up dest
        rule_body['destinationService'] = {"kind": "NetworkProtocol",
                                           "value": service}

        set_up_ip_kind(rule_body, "destinationAddress", dest)

        # everything else
        rule_body['permit'] = True if permit == 'True' else False
        rule_body['remarks'] = remarks
        rule_body['active'] = True if active == 'True' else False
        if position:
            rule_body['position'] = position
        if log_level:
            rule_body['ruleLogging'] = {'logStatus': log_level}

        try:
            raw_rule = client.create_rule_request(interface_type, interface, rule_body)
            rules = raw_to_rules([raw_rule])

            outputs = {'CiscoASA.Rules(val.ID && val.ID == obj.ID)': rules}
            hr = tableToMarkdown("Created new rule. ID: {}".format(raw_rule.get('objectId'),),
                                 rules, ["ID", "Source", "Dest", "Permit", "Interface", "InterfaceType", "IsActive",
                                         "Position", "SourceService", "destService"])
            return hr, outputs, raw_rule
        except Exception as e:
            if 'DUPLICATE' in str(e):
                raise ValueError("You are trying to create a rule that already exists.")
            if '[500]' in str(e):
                raise ValueError("Could not find interface: {}.".format(interface))
            else:
                raise ValueError(f"Could not create rule. Error {str(e)}")


    @logger
    def delete_rule_command(client: Client, args):
        rule_id = args.get('rule_id')
        interface = args.get('interface_name')
        interface_type = args.get('interface_type')
        if interface_type != "Global" and not interface:
            raise ValueError("Please state the name of the interface when it's not a global interface.")

        try:
            client.rule_action(rule_id, interface, interface_type, 'DELETE')
        except Exception as e:
            if 'Not Found' in str(e):
                raise ValueError(f"Rule {rule_id} does not exist in interface {interface} of type {interface_type}.")
            else:
                raise ValueError(f"Could not delete rule. Error {str(e)}")

        return f"Rule {rule_id} deleted successfully.", {}, ""


    @logger
    def edit_rule_command(client: Client, args):
        interface = args.get('interface_name')
        interface_type = args.get('interface_type')
        rule_id = args.get('rule_id')

        if interface_type != "Global" and not interface:
            raise ValueError("Please state the name of the interface when it's not a global interface.")

        interface = "" if interface_type == "Global" else interface

        remarks = argToList(args.get('remarks'), ',')
        position = args.get('position')
        log_level = args.get('logging_level')
        active = args.get('active', 'True')
        source = args.get('source')
        dest = args.get('destination')
        permit = args.get('permit')
        service = args.get("service")

        rule_body = {}  # type: dict

        # Set up source
        if source:
            set_up_ip_kind(rule_body, "sourceAddress", source)

        if service:
            rule_body['sourceService'] = {"kind": "NetworkProtocol",
                                          "value": service}
        # Set up dest
        if dest:
            set_up_ip_kind(rule_body, "destinationAddress", dest)

        if service:
            rule_body['destinationService'] = {"kind": "NetworkProtocol",
                                               "value": service}

        # everything else
        if permit:
            rule_body['permit'] = True if permit == 'True' else False
        if remarks:
            rule_body['remarks'] = remarks
        if active:
            rule_body['active'] = True if active == 'True' else False
        if position:
            rule_body['position'] = position
        if log_level:
            rule_body['ruleLogging'] = {'logStatus': log_level}

        try:
            rule = client.rule_action(rule_id, interface, interface_type, "PATCH", rule_body)
            try:
                raw_rule = client.rule_action(rule_id, interface, interface_type, 'GET')
            except Exception:
                location = rule.headers._store.get('location')[1]  # type: ignore
                rule_id = location[location.rfind('/') + 1:]
                raw_rule = client.rule_action(rule_id, interface, interface_type, 'GET')

            rules = raw_to_rules([raw_rule])

            outputs = {'CiscoASA.Rules(val.ID && val.ID == obj.ID)': rules}
            hr = tableToMarkdown(f"Edited rule {raw_rule.get('objectId')}",
                                 rules, ["ID", "Source", "Dest", "Permit", "Interface", "InterfaceType", "IsActive",
                                         "Position", "SourceService", "destService"])
            return hr, outputs, raw_rule
        except Exception as e:
            if 'DUPLICATE' in str(e):
                raise ValueError("You are trying to create a rule that already exists.")
            if '[500]' in str(e):
                raise ValueError("Could not find interface: {}.".format(interface))
            else:
                raise


    @logger
    def list_objects_command(client: Client, args: dict):
        objects = client.get_network_obejcts()
        obj_names = argToList(args.get('object_name'))
        obj_ids = argToList(args.get('object_id'))
        formated_objects = []
        for object in objects:
            if (not obj_names and not obj_ids) or object.get('name') in obj_names or object.get('objectId') in obj_ids:
                object.pop('selfLink')
                object.pop('kind')
                formated_obj = camelize(object)
                formated_obj['ID'] = formated_obj.pop('Objectid')
                formated_objects.append(formated_obj)
        ec = {'CiscoASA.NetworkObject(val.ID && val.ID == obj.ID)': formated_objects}
        hr = tableToMarkdown("Network Objects", formated_objects, headers=['ID', 'Name', 'Host', 'Description'])
        return hr, ec, formated_objects


    @logger
    def create_object_command(client: Client, args: dict):
        obj_type = args.get('object_type')
        obj_name = args.get('object_name')
        obj_value = args.get('object_value')
        if obj_type not in OBJECT_TYPES_DICT.keys():
            raise ValueError("Please enter an object type from the given dropdown list.")
        client.create_object(obj_name, obj_type, obj_value)
        return list_objects_command(client, {'object_name': obj_name})


    @logger
    def list_interfaces_command(client: Client, args: dict):
        raw_interfaces = client.list_interfaces()
        interface_list = []
        for interface in raw_interfaces:

            temp_interface = {'Type': interface.get('direction', '').capitalize(),
                              'ID': interface.get('interface', {}).get('objectId', '-1'),
                              'Name': interface.get('interface', {}).get('name')}
            interface_list.append(temp_interface)
        ec = {'CiscoASA.Interface(val.ID && val.ID== obj.ID)': interface_list}
        hr = tableToMarkdown('Interfaces', interface_list, ['Type', 'ID', 'Name'])
        return hr, ec, raw_interfaces


    @logger
    def test_command(client: Client):
        """
        Args:
            client:

        Returns:
            Runs a random GET API request just to see if successful.
        """

        client.test_command_request()


    '''MAIN'''


    def main():
        username = demisto.params().get('credentials').get('identifier')
        password = demisto.params().get('credentials').get('password')
        verify_certificate = not demisto.params().get('insecure', False)
        proxy = demisto.params().get('proxy', False)
        isASAv = demisto.params().get('isASAv', False)
        # Remove trailing slash to prevent wrong URL path to service
        server_url = demisto.params()['server'][:-1] \
            if (demisto.params()['server'] and demisto.params()['server'].endswith('/')) else demisto.params()['server']

        commands = {
            f'{INTEGRATION_COMMAND}-list-rules': list_rules_command,
            f'{INTEGRATION_COMMAND}-backup': backup_command,
            f'{INTEGRATION_COMMAND}-get-rule-by-id': rule_by_id_command,
            f'{INTEGRATION_COMMAND}-create-rule': create_rule_command,
            f'{INTEGRATION_COMMAND}-delete-rule': delete_rule_command,
            f'{INTEGRATION_COMMAND}-edit-rule': edit_rule_command,
            f'{INTEGRATION_COMMAND}-list-network-objects': list_objects_command,
            f'{INTEGRATION_COMMAND}-create-network-object': create_object_command,
            f'{INTEGRATION_COMMAND}-list-interfaces': list_interfaces_command
        }

        LOG(f'Command being called is {demisto.command()}')
        client = Client(server_url, auth=(username, password), verify=verify_certificate, proxy=proxy, headers={})
        try:
            client.login(isASAv)

            if demisto.command() == 'test-module':
                test_command(client)
                demisto.results('ok')
            elif demisto.command() in commands.keys():
                hr, outputs, raw_rules = commands[demisto.command()](client, demisto.args())
                return_outputs(hr, outputs, raw_rules)

        # Log exceptions
        except Exception as e:
            return_error(f"Failed to execute {demisto.command()} command. Error: {e}", error=traceback.format_exc())
            raise

        finally:
            client.logoff()


    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
