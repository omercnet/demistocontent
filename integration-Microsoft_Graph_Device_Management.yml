category: IT Services
commonfields:
  id: Microsoft Graph Device Management
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Server URL
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: ID (received from the admin consent - see Detailed Instructions (?)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  name: tenant_id
  required: true
  type: 4
- defaultvalue: ""
  display: Key (received from the admin consent - see Detailed Instructions (?)
  name: enc_key
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Use a self deployed Azure Application
  name: self_deployed
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Microsoft Intune is a Microsoft cloud-based management solution that
  provides for mobile device and operating system management
detaileddescription: |-
  To allow us access to Microsoft Graph Device Management, an admin has to approve our app using an admin consent flow, by clicking on the following [link](https://oproxy.demisto.ninja/ms-graph-device-management).
  After authorizing the Demisto app, you will get an ID, Token, and Key, which should be inserted in the integration instance configuration's corresponding fields.
display: Microsoft Graph Device Management (Microsoft Intune)
image: data:image/png;base64,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
name: Microsoft Graph Device Management
script:
  commands:
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Get managed devices
    name: msgraph-get-managed-device-by-id
    outputs:
    - contextPath: MSGraphDeviceManagement.Device.ID
      description: The ID of the managed device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.UserID
      description: Unique Identifier for the user associated with the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.Name
      description: Name of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ManagedDeviceOwnerType
      description: Ownership of the device. Possible values are unknown, company,
        personal.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.actionName
      description: Action name
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.ActionState
      description: State of the action. Possible values are none, pending, canceled,
        active, done, failed, notSupported
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.StartDateTime
      description: Time the action was initiated
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.lastUpdatedDateTime
      description: Time the action state was last updated
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.EnrolledDateTime
      description: Enrollment time of the device
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.LastSyncDateTime
      description: The date and time that the device last completed a successful sync
        with Intune.
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.OperatingSystem
      description: Operating system of the device. Windows, iOS, etc.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ComplianceState
      description: Compliance state of the device. Possible values are unknown, compliant,
        noncompliant, conflict, error, inGracePeriod, configManager
      type: String
    - contextPath: MSGraphDeviceManagement.Device.JailBroken
      description: whether the device is jail broken or rooted.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ManagementAgent
      description: Management channel of the device. Possible values are eas, mdm,
        easMdm, intuneClient, easIntuneClient, configurationManagerClient, configurationManagerClientMdm,
        configurationManagerClientMdmEas, unknown, jamf, googleCloudDevicePolicyController.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.OSVersion
      description: Operating system version of the device.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.EASDeviceId
      description: Exchange ActiveSync Id of the device.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.EASActivationDateTime
      description: Exchange ActivationSync activation time of the device.
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.ActivationLockBypassCode
      description: Code that allows the Activation Lock on a device to be bypassed.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.EmailAddress
      description: Email(s) for the user associated with the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.AzureADDeviceId
      description: The unique identifier for the Azure Active Directory device. Read
        only.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.CategoryDisplayName
      description: Device category display name
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ExchangeAccessState
      description: The Access State of the device in Exchange. Possible values are
        none, unknown, allowed, blocked, quarantined.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.exchangeAccessStateReason
      description: The reason for the device's access state in Exchange. Possible
        values are none, unknown, exchangeGlobalRule, exchangeIndividualRule, exchangeDeviceRule,
        exchangeUpgrade, exchangeMailboxPolicy, other, compliant, notCompliant, notEnrolled,
        unknownLocation, mfaRequired, azureADBlockDueToAccessPolicy, compromisedPassword,
        deviceNotKnownWithManagedApp.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.IsSupervised
      description: Device supervised status
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.IsEncrypted
      description: Device encryption status
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.UserPrincipalName
      description: Device user principal name
      type: String
    - contextPath: MSGraphDeviceManagement.Device.Model
      description: Model of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.Manufacturer
      description: Manufacturer of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.IMEI
      description: IMEI of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.SerialNumber
      description: Serial number of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.PhoneNumber
      description: Phone number of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.AndroidSecurityPatchLevel
      description: Android security patch level of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.inventory
      description: Whether inventory is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.modernApps
      description: Whether modern application is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.resourceAccess
      description: Whether resource access is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.deviceConfiguration
      description: Whether device configuration is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.compliancePolicy
      description: Whether compliance policy is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.windowsUpdateForBusiness
      description: Whether Windows Update for Business is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.WiFiMacAddress
      description: Wi-Fi MAC
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.lastUpdateDateTime
      description: The Timestamp of the last update.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.issuedDateTime
      description: The DateTime when device was evaluated or issued to MDM
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.resetCount
      description: The number of times a PC device has hibernated or resumed
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.restartCount
      description: The number of times a PC device has rebooted
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bitLockerStatus
      description: On or Off of BitLocker Drive Encryption
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootManagerVersion
      description: The version of the Boot Manager
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.secureBoot
      description: When Secure Boot is enabled, the core components must have the
        correct cryptographic signatures
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootDebugging
      description: When bootDebugging is enabled, the device is used in development
        and testing
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.operatingSystemKernelDebugging
      description: When operatingSystemKernelDebugging is enabled, the device is used
        in development and testing
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.codeIntegrity
      description: When code integrity is enabled, code execution is restricted to
        integrity verified code
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.testSigning
      description: When test signing is allowed, the device does not enforce signature
        validation during boot
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.safeMode,
      description: Safe mode is a troubleshooting option for Windows that starts your
        computer in a limited state
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.windowsPE
      description: Operating system running with limited services that is used to
        prepare a computer for Windows
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.earlyLaunchAntiMalwareDriverProtection
      description: ELAM provides protection for the computers in your network when
        they start up
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.virtualSecureMode
      description: VSM is a container that protects high value assets from a compromised
        kernel
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.pcrHashAlgorithm
      description: Informational attribute that identifies the HASH algorithm that
        was used by TPM
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootAppSecurityVersion
      description: The security version number of the Boot Application
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootManagerSecurityVersion
      description: The security version number of the Boot Application
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.tpmVersion
      description: The security version number of the Boot Application
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.pcr0
      description: The measurement that is captured in PCR[0]
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.secureBootConfigurationPolicyFingerPrint
      description: Fingerprint of the Custom Secure Boot Configuration Policy
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.codeIntegrityPolicy
      description: The Code Integrity policy that is controlling the security of the
        boot environment
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootRevisionListInfo
      description: The Boot Revision List that was loaded during initial boot on the
        attested device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.operatingSystemRevListInfo
      description: The Operating System Revision List that was loaded during initial
        boot on the attested device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.healthStatusMismatchInfo
      description: This attribute appears if DHA-Service detects an integrity issue
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.healthAttestationSupportedStatus
      description: This attribute indicates if DHA is supported for the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.SubscriberCarrier
      description: Subscriber Carrier
      type: String
    - contextPath: MSGraphDeviceManagement.Device.MEID
      description: MEID
      type: String
    - contextPath: MSGraphDeviceManagement.Device.TotalStorageSpaceInBytes
      description: Total Storage in Bytes
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.FreeStorageSpaceInBytes
      description: Free Storage in Bytes
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.ManagedDeviceName
      description: Automatically generated name to identify a device. Can be overwritten
        to a user friendly name.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.PartnerReportedThreatState
      description: Indicates the threat state of a device when a Mobile Threat Defense
        partner is in use by the account and device. Read Only. Possible values are
        unknown, activated, deactivated, secured, lowSeverity, mediumSeverity, highSeverity,
        unresponsive, compromised, misconfigured.
      type: String
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Check the device with Intune, immediately receive pending actions
      and policies
    name: msgraph-sync-device
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Disable the lost mode of the device
    name: msgraph-device-disable-lost-mode
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Gets the GPS location of a device (iOS only)
    name: msgraph-locate-device
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Immediately reboots the device
    name: msgraph-device-reboot-now
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Immideately shuts down the device
    name: msgraph-device-shutdown
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Removes the activation lock (iOS devices only)
    name: msgraph-device-bypass-activation-lock
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Remove the device from intune management
    name: msgraph-device-retire
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Resets the passcode for the device
    name: msgraph-device-reset-passcode
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Lock the device, to unlock the user will have to use the passcode
    name: msgraph-device-remote-lock
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Request a remote access via TeamViewer
    name: msgraph-device-request-remote-assistance
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Recovers the passcode from the device
    name: msgraph-device-recover-passcode
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: logs out the current user on a shared iPad device
    name: msgraph-logout-shared-apple-device-active-user
  - arguments:
    - description: The principal name of the user to be deleted.
      name: user_principal_name
      required: true
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: deletes a user that you select from the local cache on a shared iPad
      device
    name: msgraph-delete-user-from-shared-apple-device
  - arguments:
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Forece update windows defender signatures
    name: msgraph-windows-device-defender-update-signatures
  - arguments:
    - auto: PREDEFINED
      default: true
      description: Whether to keep the user's data or not. (Default is set to true)
      name: keep_user_data
      predefined:
      - "true"
      - "false"
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: removes any apps that are installed on a PC running Windows 10. it
      helps remove pre-installed (OEM) apps that are typically installed with a new
      PC
    name: msgraph-clean-windows-device
  - arguments:
    - auto: PREDEFINED
      default: true
      description: Whether to peformn quick scan or not. (Default is set to true)
      name: quick_scan
      predefined:
      - "true"
      - "false"
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Scans the device with windows defender (windows devices only)
    name: msgraph-windows-device-defender-scan
  - arguments:
    - auto: PREDEFINED
      default: true
      description: Whether to keep enrollment data or not. (Default is set to true)
      name: keep_enrollment_data
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      default: true
      description: Whether to keep the user's data or not. (Default is set to true)
      name: keep_user_data
      predefined:
      - "true"
      - "false"
    - description: The MacOS unlock code.
      name: mac_os_unlock_code
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: restores a device to its factory default settings
    name: msgraph-wipe-device
  - arguments:
    - description: SIP address
      name: session_initiation_protocal_address
      required: true
    - description: Exchenge servier adddress
      name: exchange_server
      required: true
    - auto: PREDEFINED
      default: true
      description: Whether to enable calendar sync or not. (Default is set to false)
      name: calendar_sync_enabled
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      default: true
      description: Whether to enable password rotation or not. (Default is set to
        false)
      name: password_rotation_enabled
      predefined:
      - "true"
      - "false"
    - description: The device account password.
      name: device_account_password
      required: true
    - description: The device account email.
      name: device_account_email
      required: true
    - description: The ID of the managed device to be fetched (Can be retreived using
        the msgraph-list-managed-devices command)
      name: device_id
      required: true
    description: Updates the windows account of the device
    name: msgraph-update-windows-device-account
  - arguments:
    - default: true
      defaultValue: "10"
      description: The number of managed devices to fetch.
      name: limit
    description: List of managed devices
    name: msgraph-list-managed-devices
    outputs:
    - contextPath: MSGraphDeviceManagement.Device.ID
      description: The ID of the managed device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.UserID
      description: Unique Identifier for the user associated with the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.Name
      description: Name of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ManagedDeviceOwnerType
      description: Ownership of the device. Possible values are unknown, company,
        personal.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.actionName
      description: Action name
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.ActionState
      description: State of the action. Possible values are none, pending, canceled,
        active, done, failed, notSupported
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.StartDateTime
      description: Time the action was initiated
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.ActionResults.lastUpdatedDateTime
      description: Time the action state was last updated
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.EnrolledDateTime
      description: Enrollment time of the device
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.LastSyncDateTime
      description: The date and time that the device last completed a successful sync
        with Intune.
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.OperatingSystem
      description: Operating system of the device. Windows, iOS, etc.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ComplianceState
      description: Compliance state of the device. Possible values are unknown, compliant,
        noncompliant, conflict, error, inGracePeriod, configManager
      type: String
    - contextPath: MSGraphDeviceManagement.Device.JailBroken
      description: whether the device is jail broken or rooted.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ManagementAgent
      description: Management channel of the device. Possible values are eas, mdm,
        easMdm, intuneClient, easIntuneClient, configurationManagerClient, configurationManagerClientMdm,
        configurationManagerClientMdmEas, unknown, jamf, googleCloudDevicePolicyController.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.OSVersion
      description: Operating system version of the device.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.EASDeviceId
      description: Exchange ActiveSync Id of the device.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.EASActivationDateTime
      description: Exchange ActivationSync activation time of the device.
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.ActivationLockBypassCode
      description: Code that allows the Activation Lock on a device to be bypassed.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.EmailAddress
      description: Email(s) for the user associated with the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.AzureADDeviceId
      description: The unique identifier for the Azure Active Directory device. Read
        only.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.CategoryDisplayName
      description: Device category display name
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ExchangeAccessState
      description: The Access State of the device in Exchange. Possible values are
        none, unknown, allowed, blocked, quarantined.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.exchangeAccessStateReason
      description: The reason for the device's access state in Exchange. Possible
        values are none, unknown, exchangeGlobalRule, exchangeIndividualRule, exchangeDeviceRule,
        exchangeUpgrade, exchangeMailboxPolicy, other, compliant, notCompliant, notEnrolled,
        unknownLocation, mfaRequired, azureADBlockDueToAccessPolicy, compromisedPassword,
        deviceNotKnownWithManagedApp.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.IsSupervised
      description: Device supervised status
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.IsEncrypted
      description: Device encryption status
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.UserPrincipalName
      description: Device user principal name
      type: String
    - contextPath: MSGraphDeviceManagement.Device.Model
      description: Model of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.Manufacturer
      description: Manufacturer of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.IMEI
      description: IMEI of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.SerialNumber
      description: Serial number of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.PhoneNumber
      description: Phone number of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.AndroidSecurityPatchLevel
      description: Android security patch level of the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.inventory
      description: Whether inventory is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.modernApps
      description: Whether modern application is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.resourceAccess
      description: Whether resource access is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.deviceConfiguration
      description: Whether device configuration is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.compliancePolicy
      description: Whether compliance policy is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.ConfigurationManagerClientEnabledFeatures.windowsUpdateForBusiness
      description: Whether Windows Update for Business is managed by Intune
      type: Boolean
    - contextPath: MSGraphDeviceManagement.Device.WiFiMacAddress
      description: Wi-Fi MAC
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.lastUpdateDateTime
      description: The Timestamp of the last update.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.issuedDateTime
      description: The DateTime when device was evaluated or issued to MDM
      type: Date
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.resetCount
      description: The number of times a PC device has hibernated or resumed
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.restartCount
      description: The number of times a PC device has rebooted
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bitLockerStatus
      description: On or Off of BitLocker Drive Encryption
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootManagerVersion
      description: The version of the Boot Manager
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.secureBoot
      description: When Secure Boot is enabled, the core components must have the
        correct cryptographic signatures
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootDebugging
      description: When bootDebugging is enabled, the device is used in development
        and testing
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.operatingSystemKernelDebugging
      description: When operatingSystemKernelDebugging is enabled, the device is used
        in development and testing
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.codeIntegrity
      description: When code integrity is enabled, code execution is restricted to
        integrity verified code
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.testSigning
      description: When test signing is allowed, the device does not enforce signature
        validation during boot
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.safeMode,
      description: Safe mode is a troubleshooting option for Windows that starts your
        computer in a limited state
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.windowsPE
      description: Operating system running with limited services that is used to
        prepare a computer for Windows
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.earlyLaunchAntiMalwareDriverProtection
      description: ELAM provides protection for the computers in your network when
        they start up
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.virtualSecureMode
      description: VSM is a container that protects high value assets from a compromised
        kernel
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.pcrHashAlgorithm
      description: Informational attribute that identifies the HASH algorithm that
        was used by TPM
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootAppSecurityVersion
      description: The security version number of the Boot Application
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootManagerSecurityVersion
      description: The security version number of the Boot Application
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.tpmVersion
      description: The security version number of the Boot Application
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.pcr0
      description: The measurement that is captured in PCR[0]
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.secureBootConfigurationPolicyFingerPrint
      description: Fingerprint of the Custom Secure Boot Configuration Policy
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.codeIntegrityPolicy
      description: The Code Integrity policy that is controlling the security of the
        boot environment
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.bootRevisionListInfo
      description: The Boot Revision List that was loaded during initial boot on the
        attested device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.operatingSystemRevListInfo
      description: The Operating System Revision List that was loaded during initial
        boot on the attested device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.healthStatusMismatchInfo
      description: This attribute appears if DHA-Service detects an integrity issue
      type: String
    - contextPath: MSGraphDeviceManagement.Device.HealthAttestationState.healthAttestationSupportedStatus
      description: This attribute indicates if DHA is supported for the device
      type: String
    - contextPath: MSGraphDeviceManagement.Device.SubscriberCarrier
      description: Subscriber Carrier
      type: String
    - contextPath: MSGraphDeviceManagement.Device.MEID
      description: MEID
      type: String
    - contextPath: MSGraphDeviceManagement.Device.TotalStorageSpaceInBytes
      description: Total Storage in Bytes
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.FreeStorageSpaceInBytes
      description: Free Storage in Bytes
      type: Number
    - contextPath: MSGraphDeviceManagement.Device.ManagedDeviceName
      description: Automatically generated name to identify a device. Can be overwritten
        to a user friendly name.
      type: String
    - contextPath: MSGraphDeviceManagement.Device.PartnerReportedThreatState
      description: Indicates the threat state of a device when a Mobile Threat Defense
        partner is in use by the account and device. Read Only. Possible values are
        unknown, activated, deactivated, secured, lowSeverity, mediumSeverity, highSeverity,
        unresponsive, compromised, misconfigured.
      type: String
  dockerimage: demisto/crypto:1.0.0.7634
  runonce: false
  script: |2




    ''' IMPORTS '''
    import requests
    from typing import Tuple, Any
    import json

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()


    ''' GLOBAL VARS '''

    SPECIAL_HEADERS: dict = {
        'id': 'ID',
        'userId': 'User ID',
        'osVersion': 'OS Version',
        'imei': 'IMEI',
        'meid': 'MEID'
    }

    HEADERS: dict = {
        'raw_device': ['id', 'userId', 'deviceName', 'operatingSystem', 'osVersion', 'emailAddress',
                       'manufacturer', 'model', 'imei', 'meid'],
    }


    ''' CLIENT '''


    class MsGraphClient:
        def __init__(self, self_deployed, tenant_id, auth_and_token_url, enc_key, app_name, base_url, use_ssl, proxy,
                     ok_codes):
            self.ms_client = MicrosoftClient(self_deployed=self_deployed, tenant_id=tenant_id, auth_id=auth_and_token_url,
                                             enc_key=enc_key, app_name=app_name, base_url=base_url, verify=use_ssl,
                                             proxy=proxy, ok_codes=ok_codes)

        def list_managed_devices(self, limit: int) -> Tuple[list, Any]:
            url_suffix: str = '/deviceManagement/managedDevices'
            raw_response = self.ms_client.http_request('GET', url_suffix)
            return raw_response.get('value', [])[:limit], raw_response

        def get_managed_device(self, device_id: str) -> Tuple[Any, str]:
            url_suffix: str = f'/deviceManagement/managedDevices/{device_id}'
            return self.ms_client.http_request('GET', url_suffix), device_id

        def make_action(self, device_id: str, action: str, body: str = None) -> None:
            url_suffix: str = f'deviceManagement/managedDevices/{device_id}/{action}'
            self.ms_client.http_request('POST', url_suffix, data=body, return_empty_response=True)

        def delete_user_from_shared_apple_device(self, user_principal_name: str, device_id: str, action: str) -> None:
            body: dict = {'userPrincipalName': user_principal_name}
            self.make_action(device_id, action, json.dumps(body))

        def clean_windows_device(self, keep_user_data: bool, device_id: str, action: str) -> None:
            body: dict = {'keepUserData': keep_user_data}
            self.make_action(device_id, action, json.dumps(body))

        def windows_device_defender_scan(self, quick_scan: bool, device_id: str, action: str) -> None:
            body: dict = {'quickScan': quick_scan}
            self.make_action(device_id, action, json.dumps(body))

        def wipe_device(self, keep_enrollment_data: bool, keep_user_data: bool, mac_os_unlock_code: str,
                        device_id: str, action: str) -> None:
            body: dict = {
                'keepEnrollmentData': keep_enrollment_data,
                'keepUserData': keep_user_data
            }
            if mac_os_unlock_code:
                body['macOsUnlockCode'] = mac_os_unlock_code
            self.make_action(device_id, action, json.dumps(body))

        def update_windows_device_account(self, device_account_password: str, password_rotation_enabled: bool,
                                          calendar_sync_enabled: bool, device_account_email: str, exchange_server: str,
                                          session_initiation_protocal_address: str, device_id: str, action: str) -> None:
            body: dict = {
                'updateWindowsDeviceAccountActionParameter': {
                    '@odata.type': 'microsoft.graph.updateWindowsDeviceAccountActionParameter',
                    'deviceAccount': {
                        '@odata.type': 'microsoft.graph.windowsDeviceAccount',
                        'password': device_account_password
                    },
                    'passwordRotationEnabled': password_rotation_enabled,
                    'calendarSyncEnabled': calendar_sync_enabled,
                    'deviceAccountEmail': device_account_email,
                    'exchangeServer': exchange_server,
                    'sessionInitiationProtocalAddress': session_initiation_protocal_address
                }
            }
            self.make_action(device_id, action, json.dumps(body))


    ''' HELPER FUNCTIONS '''


    def try_parse_integer(int_to_parse: Any, err_msg: str) -> int:
        """
        Tries to parse an integer, and if fails will throw DemistoException with given err_msg
        :param int_to_parse: The argument to be parsed into integer
        :param err_msg: The error message to show in case of failure
        :return: The integer
        """
        try:
            res: int = int(int_to_parse)
        except (TypeError, ValueError):
            raise DemistoException(err_msg)
        return res


    def parse_device_action_results(raw_device_action_results: list) -> list:
        """
        Parses a list of device action results
        :param raw_device_action_results: The raw list of device action results
        :return: The parsed list of device action results
        """
        action_results: list = list()
        for device_action_result in raw_device_action_results:
            action_result = assign_params(**{
                'Name': device_action_result.get('actionName'),
                'State': device_action_result.get('actionState'),
                'StartDateTime': device_action_result.get('startDateTime'),
                'LastUpdatedDateTime': device_action_result.get('lastUpdatedDateTime')
            })
            if action_result:
                action_results.append(action_result)
        return action_results


    def build_device_object(raw_device: dict) -> dict:
        """
        Builds a device context object
        :param raw_device: The raw device object
        :return: The device context object
        """
        device_action_results: list = raw_device.get('deviceActionResults', []) if raw_device.get('deviceActionResults') \
            else []
        conf_manager_client_enabled_features: dict = raw_device.get('configurationManagerClientEnabledFeatures', {}) \
            if raw_device.get('configurationManagerClientEnabledFeatures') else {}
        device_health_attestation_state: dict = raw_device.get('deviceHealthAttestationState', {}) \
            if raw_device.get('deviceHealthAttestationState') else {}
        return assign_params(**{
            'ID': raw_device.get('id'),
            'UserID': raw_device.get('userId'),
            'Name': raw_device.get('deviceName'),
            'ManagedDeviceOwnerType': raw_device.get('managedDeviceOwnerType'),
            'ActionResults': parse_device_action_results(device_action_results),
            'EnrolledDateTime': raw_device.get('enrolledDateTime'),
            'LastSyncDateTime': raw_device.get('lastSyncDateTime'),
            'OperatingSystem': raw_device.get('operatingSystem'),
            'ComplianceState': raw_device.get('complianceState'),
            'JailBroken': raw_device.get('jailBroken'),
            'ManagementAgent': raw_device.get('managementAgent'),
            'OSVersion': raw_device.get('osVersion'),
            'EASDeviceID': raw_device.get('easDeviceId'),
            'EASActivationDateTime': raw_device.get('easActivationDateTime'),
            'ActivationLockBypassCode': raw_device.get('activationLockBypassCode'),
            'EmailAddress': raw_device.get('emailAddress'),
            'AzureADDeviceID': raw_device.get('azureADDeviceId'),
            'CategoryDisplayName': raw_device.get('deviceCategoryDisplayName'),
            'ExchangeAccessState': raw_device.get('exchangeAccessState'),
            'ExchangeAccessStateReason': raw_device.get('exchangeAccessStateReason'),
            'IsSupervised': raw_device.get('isSupervised'),
            'IsEncrypted': raw_device.get('isEncrypted'),
            'UserPrincipalName': raw_device.get('userPrincipalName'),
            'Model': raw_device.get('model'),
            'Manufacturer': raw_device.get('manufacturer'),
            'IMEI': raw_device.get('imei'),
            'SerialNumber': raw_device.get('serialNumber'),
            'PhoneNumber': raw_device.get('phoneNumber'),
            'AndroidSecurityPatchLevel': raw_device.get('androidSecurityPatchLevel'),
            'ConfigurationManagerClientEnabledFeatures': assign_params(**{
                'Inventory': conf_manager_client_enabled_features.get('inventory'),
                'ModernApps': conf_manager_client_enabled_features.get('modernApps'),
                'ResourceAccess': conf_manager_client_enabled_features.get('resourceAccess'),
                'DeviceConfiguration': conf_manager_client_enabled_features.get('deviceConfiguration'),
                'CompliancePolicy': conf_manager_client_enabled_features.get('compliancePolicy'),
                'WindowsUpdateForBusiness': conf_manager_client_enabled_features.get('windowsUpdatesForBusiness')
            }),
            'WiFiMacAddress': raw_device.get('wiFiMacAddress'),
            'HealthAttestationState': assign_params(**{
                'LastUpdateDateTime': device_health_attestation_state.get('lastUpdateDateTime'),
                'IssuedDateTime': device_health_attestation_state.get('issuedDateTime'),
                'ResetCount': device_health_attestation_state.get('resetCount'),
                'RestartCount': device_health_attestation_state.get('restartCount'),
                'BitLockerStatus': device_health_attestation_state.get('bitLockerStatus'),
                'BootManagerVersion': device_health_attestation_state.get('bootManagerVersion'),
                'SecureBoot': device_health_attestation_state.get('secureBoot'),
                'BootDebugging': device_health_attestation_state.get('bootDebugging'),
                'OperatingSystemKernelDebugging': device_health_attestation_state.get('operatingSystemKernelDebugging'),
                'CodeIntegrity': device_health_attestation_state.get('codeIntegrity'),
                'TestSigning': device_health_attestation_state.get('testSigning'),
                'SafeMode': device_health_attestation_state.get('safeMode'),
                'WindowsPE': device_health_attestation_state.get('windowsPE'),
                'EarlyLaunchAntiMalwareDriverProtection':
                    device_health_attestation_state.get('earlyLaunchAntiMalwareDriverProtection'),
                'VirtualSecureMode': device_health_attestation_state.get('virtualSecureMode'),
                'PCRHashAlgorithm': device_health_attestation_state.get('pcrHashAlgorithm'),
                'BootAppSecurityVersion': device_health_attestation_state.get('bootAppSecurityVersion'),
                'BootManagerSecurityVersion': device_health_attestation_state.get('bootManagerSecurityVersion'),
                'TPMVersion': device_health_attestation_state.get('tpmVersion'),
                'PCR0': device_health_attestation_state.get('pcr0'),
                'SecureBootConfigurationPolicyFingerPrint':
                    device_health_attestation_state.get('secureBootConfigurationPolicyFingerPrint'),
                'CodeIntegrityPolicy': device_health_attestation_state.get('codeIntegrityPolicy'),
                'BootRevisionListInfo': device_health_attestation_state.get('bootRevisionListInfo'),
                'OperatingSystemRevListInfo': device_health_attestation_state.get('operatingSystemRevListInfo'),
                'HealthStatusMismatchInfo': device_health_attestation_state.get('healthStatusMismatchInfo'),
                'HealthAttestationSupportedStatus': device_health_attestation_state.get('healthAttestationSupportedStatus')
            }),
            'SubscriberCarrier': raw_device.get('subscriberCarrier'),
            'MEID': raw_device.get('meid'),
            'TotalStorageSpaceInBytes': raw_device.get('totalStorageSpaceInBytes'),
            'FreeStorageSpaceInBytes': raw_device.get('freeStorageSpaceInBytes'),
            'ManagedDeviceName': raw_device.get('managedDeviceName'),
            'PartnerReportedThreatState': raw_device.get('partnerReportedThreatState')
        })


    ''' COMMANDS '''


    def list_managed_devices_command(client: MsGraphClient, args: dict) -> None:
        limit: int = try_parse_integer(args.get('limit', 10), err_msg='This value for limit must be an integer.')
        list_raw_devices, raw_response = client.list_managed_devices(limit)
        list_devices: list = [build_device_object(device) for device in list_raw_devices if device]
        entry_context: dict = {'MSGraphDeviceManagement.Device(val.ID === obj.ID)': list_devices}
        human_readable: str = 'No managed devices found.'
        if list_devices:
            name: str = 'List managed devices'
            if len(list_devices) == 1:
                name = f'Managed device {list_devices[0].get("Name", "")}'
            human_readable = tableToMarkdown(name=name, t=list_raw_devices, headers=HEADERS['raw_device'],
                                             headerTransform=lambda h: SPECIAL_HEADERS.get(h, pascalToSpace(h)),
                                             removeNull=True)
        return_outputs(human_readable, entry_context, raw_response)


    def get_managed_device_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        raw_response, device_id = client.get_managed_device(device_id)
        device: dict = build_device_object(raw_response)
        entry_context: dict = {'MSGraphDeviceManagement.Device(val.ID === obj.ID)': device}
        device_name: str = device.get('Name', '')
        human_readable: str = f'Managed device {device_id} not found.'
        if device:
            human_readable = tableToMarkdown(name=f'Managed device {device_name}', t=raw_response,
                                             headers=HEADERS['raw_device'],
                                             headerTransform=lambda h: SPECIAL_HEADERS.get(h, pascalToSpace(h)),
                                             removeNull=True)
        return_outputs(human_readable, entry_context, raw_response)


    def disable_lost_mode_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'disableLostMode')
        return_outputs('Device disable lost mode action activated successfully.', {}, {})


    def locate_device_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'locateDevice')
        return_outputs('Locate device action activated successfully.', {}, {})


    def sync_device_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'syncDevice')
        return_outputs('Sync device action activated successfully.', {}, {})


    def device_reboot_now_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'rebootNow')
        return_outputs('Device reboot now action activated successfully.', {}, {})


    def device_shutdown_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'shutDown')
        return_outputs('Device shutdown action activated successfully.', {}, {})


    def device_bypass_activation_lock_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'bypassActivationLock')
        return_outputs('Device bypass activation lock action activated successfully.', {}, {})


    def device_retire_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'retire')
        return_outputs('Retire device action activated successfully.', {}, {})


    def device_reset_passcode_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'resetPasscode')
        return_outputs('Device reset passcode action activated successfully.', {}, {})


    def device_remote_lock_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'remoteLock')
        return_outputs('Device remote lock action activated successfully.', {}, {})


    def device_request_remote_assistance_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'requestRemoteAssistance')
        return_outputs('Device request remote assistance action activated successfully.', {}, {})


    def device_recover_passcode_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'recoverPasscode')
        return_outputs('Device recover passcode action activated successfully.', {}, {})


    def logout_shared_apple_device_active_user_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'logoutSharedAppleDeviceActiveUser')
        return_outputs('Logout shard apple device active user action activated successfully.', {}, {})


    def delete_user_from_shared_apple_device_command(client: MsGraphClient, args: dict) -> None:
        user_principal_name: str = str(args.get('user_principal_name'))
        device_id: str = str(args.get('device_id'))
        client.delete_user_from_shared_apple_device(user_principal_name, device_id, 'deleteUserFromSharedAppleDevice')
        return_outputs('Delete user from shared apple device action activated successfully.', {}, {})


    def windows_device_defender_update_signatures_command(client: MsGraphClient, args: dict) -> None:
        device_id: str = str(args.get('device_id'))
        client.make_action(device_id, 'windowsDefenderUpdateSignatures')
        return_outputs('Windows device defender update signatures action activated successfully.', {}, {})


    def clean_windows_device_command(client: MsGraphClient, args: dict) -> None:
        keep_user_data: bool = bool(args.get('keep_user_data'))
        device_id: str = str(args.get('device_id'))
        client.clean_windows_device(keep_user_data, device_id, 'cleanWindowsDevice')
        return_outputs('Clean windows device action activated successfully.', {}, {})


    def windows_device_defender_scan_command(client: MsGraphClient, args: dict) -> None:
        quick_scan: bool = bool(args.get('quick_scan'))
        device_id: str = str(args.get('device_id'))
        client.windows_device_defender_scan(quick_scan, device_id, 'windowsDefenderScan')
        return_outputs('Windows device defender scan action activated successfully.', {}, {})


    def wipe_device_command(client: MsGraphClient, args: dict) -> None:
        keep_enrollment_data: bool = bool(args.get('keep_enrollment_data'))
        keep_user_data: bool = bool(args.get('keep_user_data'))
        mac_os_unlock_code: str = str(args.get('mac_os_unlock_code'))
        device_id: str = str(args.get('device_id'))
        client.wipe_device(keep_enrollment_data, keep_user_data, mac_os_unlock_code, device_id, 'wipe')
        return_outputs('Wipe device action activated successfully.', {}, {})


    def update_windows_device_account_command(client: MsGraphClient, args: dict) -> None:
        device_account_password: str = str(args.get('device_account_password'))
        password_rotation_enabled: bool = bool(args.get('password_rotation_enabled'))
        calendar_sync_enabled: bool = bool(args.get('calendar_sync_enabled'))
        device_account_email: str = str(args.get('device_account_email'))
        exchange_server: str = str(args.get('exchange_server'))
        session_initiation_protocal_address: str = str(args.get('session_initiation_protocal_address'))
        device_id: str = str(args.get('device_id'))
        client.update_windows_device_account(device_account_password, password_rotation_enabled, calendar_sync_enabled,
                                             device_account_email, exchange_server, session_initiation_protocal_address,
                                             device_id, 'updateWindowsDeviceAccount')
        return_outputs('Update windows device account action activated successfully.', {}, {})


    ''' MAIN '''


    def main():
        args: dict = demisto.args()
        params: dict = demisto.params()
        self_deployed: bool = params.get('self_deployed', False)
        tenant_id: str = params.get('tenant_id', '')
        auth_and_token_url: str = params.get('auth_id', '')
        enc_key: str = params.get('enc_key', '')
        base_url: str = urljoin(params.get('url', ''), '/v1.0')
        app_name: str = 'ms-graph-device-management'
        ok_codes: tuple = (200, 201, 202, 204)
        use_ssl: bool = not params.get('insecure', False)
        proxy: bool = params.get('proxy', False)

        client: MsGraphClient = MsGraphClient(self_deployed, tenant_id, auth_and_token_url, enc_key, app_name, base_url,
                                              use_ssl, proxy, ok_codes)

        command: str = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            if command == 'test-module':
                client.ms_client.get_access_token()
                demisto.results('ok')
            elif command == 'msgraph-list-managed-devices':
                list_managed_devices_command(client, args)
            elif command == 'msgraph-get-managed-device-by-id':
                get_managed_device_command(client, args)
            elif command == 'msgraph-device-disable-lost-mode':
                disable_lost_mode_command(client, args)
            elif command == 'msgraph-locate-device':
                locate_device_command(client, args)
            elif command == 'msgraph-sync-device':
                sync_device_command(client, args)
            elif command == 'msgraph-device-reboot-now':
                device_reboot_now_command(client, args)
            elif command == 'msgraph-device-shutdown':
                device_shutdown_command(client, args)
            elif command == 'msgraph-device-bypass-activation-lock':
                device_bypass_activation_lock_command(client, args)
            elif command == 'msgraph-device-retire':
                device_retire_command(client, args)
            elif command == 'msgraph-device-reset-passcode':
                device_reset_passcode_command(client, args)
            elif command == 'msgraph-device-remote-lock':
                device_remote_lock_command(client, args)
            elif command == 'msgraph-device-request-remote-assistance':
                device_request_remote_assistance_command(client, args)
            elif command == 'msgraph-device-recover-passcode':
                device_recover_passcode_command(client, args)
            elif command == 'msgraph-logout-shared-apple-device-active-user':
                logout_shared_apple_device_active_user_command(client, args)
            elif command == 'msgraph-delete-user-from-shared-apple-device':
                delete_user_from_shared_apple_device_command(client, args)
            elif command == 'msgraph-windows-device-defender-update-signatures':
                windows_device_defender_update_signatures_command(client, args)
            elif command == 'msgraph-clean-windows-device':
                clean_windows_device_command(client, args)
            elif command == 'msgraph-windows-device-defender-scan':
                windows_device_defender_scan_command(client, args)
            elif command == 'msgraph-wipe-device':
                wipe_device_command(client, args)
            elif command == 'msgraph-update-windows-device-account':
                update_windows_device_account_command(client, args)

        # log exceptions
        except Exception as err:
            return_error(str(err))



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.import traceback




    import requests
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Tuple

    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line


    class MicrosoftClient(BaseClient):

        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str = '',
                     token_retrieval_url: str = 'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = 'https://graph.microsoft.com/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str = '',
                     verify: bool = True,
                     self_deployed: bool = False,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]

            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id)
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope
                self.redirect_uri = redirect_uri

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify

        def http_request(self, *args, resp_type='json', headers=None, return_empty_response=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            if headers:
                default_headers.update(headers)

            response = super()._http_request(   # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))

            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self):
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            refresh_token = integration_context.get('current_refresh_token', '')
            valid_until = integration_context.get('valid_until')
            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            auth_type = self.auth_type
            if auth_type == OPROXY_AUTH_TYPE:
                access_token, expires_in, refresh_token = self._oproxy_authorize()
            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            integration_context = {
                'access_token': access_token,
                'current_refresh_token': refresh_token,
                'valid_until': time_now + expires_in,
            }

            demisto.setIntegrationContext(integration_context)
            return access_token

        def _oproxy_authorize(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key)
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self, refresh_token: str = ''):
            if self.grant_type == AUTHORIZATION_CODE:
                return self._get_self_deployed_token_auth_code(refresh_token)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                return self._get_self_deployed_token_client_credentials()

        def _get_self_deployed_token_client_credentials(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.scope:
                data['scope'] = self.scope
            if self.resource:
                data['resource'] = self.resource

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(self, refresh_token: str = '') -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'resource': self.resource,
                'redirect_uri': self.redirect_uri
            }
            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            # refresh_token = response_json.get('refresh_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
                brand_name = calling_context.get('IntegrationBrand', '')
                instance_name = calling_context.get('IntegrationInstance', '')
                headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
                headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
                if hasattr(demisto, 'demistoVersion'):
                    demisto_version = demisto.demistoVersion()
                    headers['X-Content-Server-Version'] = '{}-{}'.format(demisto_version.get('version'),
                                                                         demisto_version.get("buildNumber"))
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers



    if __name__ in ['__main__', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
