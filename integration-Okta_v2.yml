category: Authentication
commonfields:
  id: Okta v2
  version: -1
configuration:
- defaultvalue: ""
  display: Okta URL (https://<domain>.okta.com)
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: API Token (see Detailed Instructions)
  name: apitoken
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Integration with Okta's cloud-based identity management service
detaileddescription: |
  Okta V2
  -
    For information on getting your Okta API token, see the Okta documentation.
    https://developer.okta.com/docs/api/getting_started/getting_a_token
display: Okta v2
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAoCAYAAAA16j4lAAASU0lEQVR42u1cB1gU19oesCuaxJJo1DQ1RqMxGu/Vm+jv1RgNlqioUROTWG8SNXZFYelFehOUsnQRAaVJFYTtfdleWHqxoIAglvhb5p4zC4rLDMwu+P957nWe5zxZzcx3vvO953z9iCB/kce7UGs9ylN4a4Qzo+kNZ2YjHBZOjOZJPoLKBGHtj69qXkVd0/T5wSLhYGdWS8e8I5wYTUNceHeOZWhP02Xlw5DXT+8eplA6Zl6YQoHYsFDEjgYGvX2A3yeY6PIwCeNVze10WWqNOAhRhNJpXvjbgYu+7y24t9Qze+5rhHoLsEg6ZkGoFADMRs2AgDsP5CQT/T5WevlVze2WLT2KOPBRMwDqi3n1AE/15TWvDcz//DVCvXw4JfJRC8OkciKAN8VKM1/V3KdyZIeJAP7El99oFZT/2WuEXgP8+nkN8GuA/4oAN60LzJ/1GqH/VIB9eM2rfHNfO1n/cQC3h0nTfPm3vw++8t+nossbWvtf1TW+la1pHMOpbhl+79ETs78KwPLqRjPhtfsWvJrWlwa75u7wquY/B5E7wWBeexY6xJGOrgvj/MasvDNIUHd3mCFNFqB5ve3RgN7KU3nz3tA8beOofDDk9S2DiN6raHo4iF3VOrxjfm5tm4Wq4cHQoHS6Wa9BZelufLo9QbJvb2pp5LpYRaFlpIy7LEIqXBklY21NVGdtS1L5WWfpfriqa3rn/wvg8Bze5F8uqFNWxig5q6JkjM5jZbSctTpWyUiT1KwgAzCmpil0dKKXoG1FlJyzOkpGN6S5IkbF+SFBmaWuuz3FmPXKr7cNPsOu/XZBsNBxTYw8dW2MnL48QspfTpXx1sQoinelaM6vixKfvCSuWXAiTYFtIFply5LV4L0VkTLWcx4iwUis4B6Ipx0yCdTzLPUAvysKS8twYe67XsJ7w135KHIcLPx48YtxDIyjRShiU4yOdmU9fc+T23AgQxd0PFM37f8S4AyW5J0V0XI2YsMFPBW9zCM2CgGfHHR3sioqjas06xng9vkpzBfrPI4zTvDQM0Wa30ltQE71WB9azbFZ/nztaDfO/w51YunpHjOQJ/jvYGcuOs5T+OgLfx43kVe2fvsFVTxy2GDuo2BNdiJ0nBur6RPn3BFGgZtEl8zYfVGbgjgLniL2AFhb/Y5GcITwXBjwHThOMlAAdJNbQZWTa75u5KsGmClRv/VdrLIAcRABHou78gb+DrFlo6O9Sm5fUdYvIXeCyQ3EXoCeLlDs746/HHmd+UXZzc1fBIlKkROd5NQdXUr7e8AXQOzZzwbaFT3pui7w/11F6AeutLpPHbIsSIN7MPqK1cyz6lqEIgDEGZiAjF64LQMDx5IqLbCKFr/3qgDWlFdZfH9OdRmCiwsSFIItCx3mKXmULCj/jqwNJr1OOz4aUqjcR8RfUKHaYl+qJgShsIGWo6Pmxs7RzheGAy7AYnSSW3HNLMfL5ADeHpz508SQsj/hztQDa9rCzTqS9nZMdFaAQLmeKvyorwFuaGgYvO2CKgWqKcQWbxPSMBU7zFP6GJyy7eTDJOMAPlOo3ItHO4pROmxznCwFA9fWdDl2B75RAHtfyFs1/rSuDYKLLzBTmIBCYKFfBApKztBKx/UlwHsvaamIgxhTZ/jg0tEhntIntmmSQ8bFwUYI2F6IBl6RH8SjvTNJGYlQONhG73NwjQVYodVNmBGqqUecSlBzm6vEO9amGNuNUNWYQ7XhwMZsrl7INOKTDEqBwMGJffDnIzPjAGagm+JkXQC2ydL5YOB2UmOGNmzgKQm6M17obHyiQz/MMVPDwkIm/XpfHtg8wDREs8p2GNKN4Nbux8qfRCe3ozxpo+e1nwMD7W/fYdpoBJu2FwBvDGefR9zVYMKrxA4U8KBB8N/0eaCgyDJSGrIlQeGzMJgf87fTQtkoD/59CBDGGIHAIfOZyoYNRgFsA8qFMZLUzu97FZU7II5iTP3ihjfwO0chujCAGWRaJqudDljzNH9hjVWsPHjzOZUvGH4b4xV+6+OUAevj5AFr4rXBR9LVJ4Tq8rc606SX3pg+0YN3A25OQmDAWge48J/MDxGXrY0qSbaKkfuC8NPvqxBR5pxAYQ3wsJ9Bh8y8LwAOSy9aPja47B4mMAJwx7iyH+xLKw3NUN6eaZ9f+dIpZJTeGHS2SLVyS4KqAHGREJwquCvZ6NxAgfLen48tjAF46RkByyVXhc25yCPbeoCHDFP7eBpD3zDAR3enqM+niasHmAowAjSTuT0NTeWXLjM2vDyaoQ1EThLwB0wf4iRGF4TJKg4miX9V1t4cZfi9tL713W/CSw5N8xPUQpB7DfC/LsipiJ2QgCEaOtmbd+fn84rNPS0sU6i12BrJCUJOybs5yWw0SVS3mjTAgIaFM/spWHDGghARdaQ7/wkGLh5tO2g+uKhVvDK39f7D4b1NVU724TXtptKMKjbobrZMeMOF/QCq9S7yhOGasxid4skooqSJ3+2JVgSnZvaXZ8RaQpDJAFxRd33SVF9uLeIk6hIO6dtXmM+2JSp+IbtA93PZ/VeeZZ1HnCQEXicLXR9V8lKHBrsbgJ+rd6Bd+jmyUCJw+2Fqj4P+M1zGr7/dPKrXxQZ7DvqxD691mW/eHKNy23nqvYgTjsqH4ALNMj9MrjqUQB9Llt5FSf3n49y5zbjalQzAOdLqVYgdD1NJhjsO2syVkcYn+sMzGTM+D1XVQg+yC03gVMzwF1ZU3mp5k8wJJh2OgUTGvLNSuaC0/v0+qSYBgCf7cFtXBOQbBfCGGGkWNCt4mgtxFqHnmJpNxsoziFlzAPcUkwHYLVdDQSg8fJUHiAprWxeYkubcSmWdwZrZcFT+Rz6ClpBi7XO6XEkvAQYCnR4grkkXlM7ss3KhCQBXNTQPnxssUiMnGDjRABu1jFay66orhxrLo/pm2/gpXtxrXTxrMgDvSquIRk5cxREaHf3MT1DOqroz3hSAKbE5348O0Dw2ZAr+eewp3pOd8aItLwBWmAwwPL2D3UWo++WSHX1aDzYB4HRxxdTPAkR1UHZdTB04vVtCaadN4TFLedP890vaOBjFGA0wcPtTDRnCmLKmoWtBZeNUQdUIU5i6cIU9b3yAss3QdkCAR7lx0XXhvN0d7/J6CfBQAPCJS+JfTeHTPVt2hNgGc1tW+OfPJkuLStfMmeYvaoCmzXDNI3yV6JbArMOmVvPs8yq9kaPFhAB/6pBJBLAqFSYv8AGW005dNQ3ghHzWvImBKkKArfoI4I6KzxQQUrikC2eZBrAAt6Njsje3ZWNwAWmAI+nadoBpXdY81FuB/hySc9R0gCsIAf7Itbh2gWcePsC/ppVTcVU0YPIzf0GNXW75RFMYckss/HG4n+opnooe58F7vCdRvKkvVPSL5AYX/Qr0VgfliKcbw+fZIvUuWC3rWiXSJ20yJNVfk6V1WVI5ZVagqBZXRQMPet95UagpsjwnqO2/K1lzAR66LgAD1f+hO/1a670H+AB75atOwMlxnSzAaKri5jemMLUnRUHFnDdcJ0vYTGWWzSfrZCHtRQPo6SN2DPyUKBaG8NCFYTJZSB55kOm6m4ugk9alWoOlEgWoa67KkSyt6813h/49WKTENXlgbUujVUIQMbxprCwdcnQTP/DgNOI6Wc4C9G0XektDc+sY3I8LFXWWMDmAOHJww6RvwyVXjWUokyGa+2GArAE3TALpu1kBwvIbzXctSCU6MHXJROedFjIXnRFlDHETEKQoO6pXPPR/wmVyaqHkYzK8sstuvDfWjXEHceR2TXaAeHbiKc5Nu4Si0WTXvjZSnKrPstG7tAD185Cim4LythsrT6BF7fCTHTRs0w9y4T+V6Sqn4n5cwBa8PydQoINFhi6JDop++NCqj5BlpraqarBVnDIbFgJw05XAeVlDFSWTzmSBkGNFhJjDr2rsD9/9LqjAA9ozWIbEzby1g7woQi6JKZL22EoTWiAZ9NN5RQZC4XZNV7ZnnrbFCWMuFovMyazft1C7w9yF37WCBGk58tCZpyVVkZnFM8jKk1/bsnC4C+u+oePWOfVp5qNFI7NZWwiJHEkvPYPYCvAFBtTNIEfmQ8+i6oM9MRN1RTh6V7IqCYJrjtGi4dq2dNn1pS8BLOm+mvRDvPR5sWHr6SzzNaFs78EQZKIKVru6XhwhFyfQpJN74tsjX/07TJTgFdWxIou7BD2cIvGzuSQY1GN3SlnD2+Pc2S36VKUBXzAPDapPX1Nlkj9iaT224xZoGxeBNHEdnso3TH9uoPLziO1QiWrhG36qZlgaMxSYeUdJy57xdOt5VYofo/of/0rRWICiA7ajI9mV/f9IkoyKZet+mA0KCYijSL97KYZ0aFhC4p+hIk5t490hva0HW55l+w3xknWT8wYLBz7AEgByCkvxQXeCTGEpx80NlshgeQ9XDcISHnBmLCPEBSH0ssV/JMuGFZfeIuxkPJymcoPFBnOCEwe99gk+oganLMXJTZGCCV5XtNjGyS9tMrPJKRsSL77+sW1Ouc9AJ9bDbsHtTBOAvD+5JA5EJ5OBvN48klM1Qlpxrd9zpg6lyMKRUxrw8lXidCA4TQMc6I+WRUgEv18qjTuYURa+LVF1cbY/rxx6sVAFIQTtPRCIwc7sZyBoX9FXBf8lwZzTQzxlhCf5OchUBT+N0z3ITpmy/TDkIKrfYubKgQP9gcffhpdwD2fowhzyKr2O5FSH+tMqrBvvtDyvXCULKibNDBRVQt4JZQm9dOC9T/Zg39oUJ8/Zn66L/CNdF2UVJy8c5cxqw3q3SDcKtJdIQZVqtCv74ZfBQvWSCJk4jF3zotMkj8YeM81foEVcpUCVdFPwx4ROa+8GLMLSmc+dCko3BX8KC9zzFYb0ZUeHZRCt35dB3LOIq4QQGHM7fZL/60g5P5uv6jZPvTJClI2FTEQ9aJh9Z+hPdEc36THojAkf0eTlL2W8gmhlvwDH7RmR7excfMEaJjq6K8kW+3FA1neYtNMDHZdLo1SFLy2QV3Z9/lu+ymaYQzazLeqj1hLYKEBHLaMUzJrGu8P7uumu7f5Ds32p2kiso5LI7kMVRuGDBSuEeUINYeo1IF82fs5psQax5ZBu4cEyad6Kp2G5vDWG9HYkKnww207puxYd/W8Gifw8HbWKBc6j4ZNdUmk5xld5D+uY6AOQEWsGuihMwlfVN7/7qtpmnzx+ZL4jSZ3YcVMfHwj9SQYgc4olGkJeFNfuzJoeIKqGIJNRkVguHDh8x88V7TGk9fTZMzPry2VnYQjWa5AxLxzQgXzZFJMFOB3/FoO2fsEXZ6QaxFmC6o08zcjUIb1ddTPRnxPVKfL6O6NfdeP7vXttw8ANi1TYuEDcwag/ycujFGymrJQQZHA15+NvIiQsrGHOpmeABwA/YGNwvgseLWFNS/9loULbt915T4yzqwaePKjXT/TgNjpkyd2n+vIru+30aAd4fawijVBgB+Lo7+y5IIuc4C+9D08htKE9t5C233oANmBOoOj6tkTlHjKxHgP8Gx2ghUWB58VCgK2ipblk6Nxuahq2MQH0SNt1hHwEcTIAeVWMgnOBrXmbMLlwWWlxOE3tO8lH2IocoxMDjXV/8EFznyCm+1sNVcvBFRg+sJFPYE6ZTBut/lYFAx3pVYIuDhUWMNW1WDk0R9u86kMvXitms4k0FuAXXG/J61FoYTT1V3vTSiP+FiyugkkHbEAno6M7H3ZZwp0JJhvqyHyyKkou/jVF63i1tHEC2WBerFCPnBcqkyHWTL2T0XmABa6mSgrI0qq70WABbjlcgd0d2PeQv5dGERauDTwlQqc45a7uMQ8sqpsDSnWhfw8WV2PhonX7uim0F7cPbPnod1TRlR7rxY33h7sVVuwEmiZ/rBu7DQMa47HTbQfbdhkDmX7ix28GGjDNOlW6Po4uH9iZViCz5itwL6wAyPzxc+esgwa2MZjoj4nqZHKF7BuN/bbHCt4LZtasdb9a6fxzojIB3FjIB2qsaE20POu3i9qISP61I7uSNAtD2LUjEROeaGbpll2pFXE7k7Uxu5K10XDA37+llUXwqpvmG0NLWVk39kROhe+GBE0qaARMNhzrE9Tp3rRqirTiOqnbAKU3Ws2Bw/SeS0HVeqeCSu91cfKM2QECCUho1M8I4CvXxmsuF6nqFpPlL0d9a+ixrLLZSdKG3YcydUEbQMl2GVVSuJwqLdwcr0ihZOt8fGiVP30bypvK1NYPJKIDchKDD6SXLfaj1zr9mKBKAt8XfB0uKV4bI810ytW6nxdfm/RvRyRXcSJUnBoAAAAASUVORK5CYII=
name: Okta v2
script:
  commands:
  - arguments:
    - default: true
      description: Username to unlock.
      name: username
      required: true
    description: Unlocks a single user.
    execution: true
    name: okta-unlock-user
  - arguments:
    - description: Username to deactivate.
      name: username
      required: true
    description: Deactivates a single user.
    name: okta-deactivate-user
  - arguments:
    - default: true
      description: Username to activate.
      name: username
      required: true
    description: Activates a single user.
    name: okta-activate-user
  - arguments:
    - default: true
      description: Username to suspend.
      name: username
      required: true
    description: Suspends a single user. This operation can only be performed on users
      with an ACTIVE status. The user has a status of SUSPENDED when the process is
      completed.
    name: okta-suspend-user
  - arguments:
    - default: true
      description: Username to change the status to ACTIVE.
      name: username
      required: true
    description: Returns a single user to ACTIVE status. This operation can only be
      performed on users that have a SUSPENDED status.
    name: okta-unsuspend-user
  - arguments:
    - description: Username for which to return all enrolled factors.
      name: username
    - description: User ID of the user for which to get all enrolled factors.
      name: userId
    description: Returns all the enrolled factors for the specified user.
    name: okta-get-user-factors
    outputs:
    - contextPath: Account.ID
      description: Okta account ID.
      type: String
    - contextPath: Account.Factor.ID
      description: Okta account factor ID.
      type: String
    - contextPath: Account.Factor.Provider
      description: Okta account factor provider
      type: String
    - contextPath: Account.Factor.Profile
      description: Okta account factor profile.
      type: String
    - contextPath: Account.Factor.FactorType
      description: Okta account factor type.
      type: String
    - contextPath: Account.Factor.Status
      description: Okta account factor status.
      type: Unknown
  - arguments:
    - description: The user ID
      name: userId
    - description: Username for which to un-enroll an existing factor.
      name: username
    - description: The ID of the factor to reset.
      name: factorId
      required: true
    description: Un-enrolls an existing factor for the specified user. This enables
      the user to enroll a new factor.
    name: okta-reset-factor
  - arguments:
    - default: true
      description: Okta username for which to set the password.
      name: username
      required: true
    - description: The new password to set for the user.
      name: password
      required: true
    description: Sets passwords without validating existing user credentials.
    execution: true
    name: okta-set-password
  - arguments:
    - description: ID of the user to add to the group.
      name: userId
    - description: Name of the user to add to the group.
      name: username
    - description: ID of the group to add the user to.
      name: groupId
    - description: Name of the group to add the user to.
      name: groupName
    description: Adds a user to a group with OKTA_GROUP type.
    name: okta-add-to-group
  - arguments:
    - description: ID of the user to remove from the group.
      name: userId
    - description: Name of the user to remove from the group.
      name: username
    - description: ID of the group to remove the user from.
      name: groupId
    - description: Name of the group to remove the user from.
      name: groupName
    description: Removes a user from a group with OKTA_GROUP type
    name: okta-remove-from-group
  - arguments:
    - default: true
      description: Username in Okta for which to get the associated groups.
      name: username
      required: true
    description: Returns all user groups associated with a specified user.
    name: okta-get-groups
    outputs:
    - contextPath: Account.Group
      description: Okta groups with which the account is associated.
      type: Unknown
    - contextPath: Account.ID
      description: Okta account ID.
      type: String
    - contextPath: Account.Type
      description: Okta account type.
      type: String
    - contextPath: Account.Group.ID
      description: Unique key for the group.
      type: String
    - contextPath: Account.Group.Created
      description: Timestamp when the group was created.
      type: Date
    - contextPath: Account.Group.ObjectClass
      description: The object class, which determines the group's profile.
      type: String
    - contextPath: Account.Group.LastUpdated
      description: Timestamp when the group's profile was last updated.
      type: Date
    - contextPath: Account.Group.LastMembershipUpdated
      description: Timestamp when the group's memberships were last updated.
      type: Date
    - contextPath: Account.Group.Type
      description: Group type, which determines how a group's profile and memberships
        are managed.
      type: String
    - contextPath: Account.Group.Description
      description: Description of the group.
      type: String
    - contextPath: Account.Group.Name
      description: Name of the group.
      type: String
  - arguments:
    - description: The ID of the user to enroll and verify.
      name: userId
      required: true
    - description: The push factor ID.
      name: factorId
      required: true
    description: Enrolls and verifies a push factor for the specified user.
    name: okta-verify-push-factor
    outputs:
    - contextPath: Account.ID
      description: Okta user ID.
      type: String
    - contextPath: Account.VerifyPushResult
      description: Okta user push factor result.
      type: String
  - arguments:
    - default: true
      description: Term by which to search. Can be a first name, last name, or email
        address.
      name: term
      required: true
    - description: The maximum number of results to return. The default and maximum
        is 200.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return details of users that match the found term. Can
        be "true" or "false". The default is "false".
      name: verbose
      predefined:
      - "true"
      - "false"
    description: Searches for Okta users.
    name: okta-search
    outputs:
    - contextPath: Account.ID
      description: Okta account IDs returned by the search.
      type: String
    - contextPath: Account.Username
      description: Okta account usernames returned by the search.
      type: String
    - contextPath: Account.Email
      description: Okta account emails returned by the search.
      type: String
    - contextPath: Account.DisplayName
      description: Okta account display names returned by the search.
      type: String
    - contextPath: Account.Type
      description: Okta account type returned by the search.
      type: String
    - contextPath: Account.Status
      description: Okta account current status.
      type: String
    - contextPath: Account.Created
      description: Timestamp for when the user was created.
      type: Date
    - contextPath: Account.Activated
      description: Timestamp for when the user was activated.
      type: Date
    - contextPath: Account.StatusChanged
      description: Timestamp for when the user's status was last changed.
      type: Date
    - contextPath: Account.PasswordChanged
      description: Timestamp for when the user's password was last changed.
      type: Date
  - arguments:
    - description: Okta username for which to get information.
      name: username
    - description: User ID of the user for which to get information.
      name: userId
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to return extended user information. Can be "true" or "false".
        The default is "false".
      name: verbose
      predefined:
      - "true"
      - "false"
    description: Fetches information for a single user. You must enter one or more
      parameters for the command to run.
    name: okta-get-user
    outputs:
    - contextPath: Account.ID
      description: Okta account ID.
      type: String
    - contextPath: Account.Email
      description: Okta account email.
      type: String
    - contextPath: Account.Username
      description: Okta account username.
      type: String
    - contextPath: Account.DisplayName
      description: Okta account display name.
      type: String
    - contextPath: Account.Status
      description: Okta account status.
      type: String
    - contextPath: Account.Created
      description: Timestamp for when the user was created.
      type: Date
    - contextPath: Account.Activated
      description: Timestamp for when the user was activated.
      type: Date
    - contextPath: Account.StatusChanged
      description: Timestamp for when the user's status was last changed.
      type: Date
    - contextPath: Account.PasswordChanged
      description: Timestamp for when the user's password was last changed.
      type: Date
  - arguments:
    - description: First name of the user (givenName).
      name: firstName
      required: true
    - description: Family name of the user (familyName).
      name: lastName
      required: true
    - description: Primary email address of the user.
      name: email
      required: true
    - description: Unique identifier for the user (username).
      name: login
      required: true
    - description: Secondary email address of user. Usually used for account recovery.
      name: secondEmail
    - description: Middle name(s) of the user.
      name: middleName
    - description: A comma-separated list of honorific prefix(es) of the user, or
        title in most Western languages.
      name: honorificPrefix
    - description: A comma-separated list of honorific suffix(es) of the user.
      name: honificSuffix
    - description: User's title. for example, Vice President.
      name: title
    - description: Display name of the user.
      name: displayName
    - description: Casual way to address the user (nick name).
      name: nickName
    - description: URL of the user online profile. For example, a web page.
      name: profileUrl
    - description: Primary phone number of the user.
      name: primaryPhone
    - description: Mobile phone number of the user.
      name: mobilePhone
    - description: Full street address component of the user's address.
      name: streetAddress
    - description: City or locality component of the user's address (locality).
      name: city
    - description: State or region component of the user's address (region).
      name: state
    - description: Zip code or postal code component of the user's address (postalCode).
      name: zipCode
    - description: Country name component of the user's address (country).
      name: countryCode
    - description: Mailing address component of the user's address.
      name: postalAddress
    - description: User's preferred written or spoken languages.
      name: preferredLanguage
    - description: User's default location, for purposes of localizing items such
        as currency, date-time format, numerical representations, etc.
      name: locale
    - description: User's time zone.
      name: timezone
    - description: The user type, which is used to identify the organization-to-user
        relationship such as "Employee" or "Contractor".
      name: userType
    - description: Organization or company assigned unique identifier for the user.
      name: employeeNumber
    - description: Name of a cost center the user is assigned to.
      name: costCenter
    - description: Name of the user's organization.
      name: organization
    - description: Name of the user's division.
      name: division
    - description: Name of the user's department.
      name: department
    - description: ID of the user's manager.
      name: managerId
    - description: Display name of the user's manager.
      name: manager
    - description: Password for the new user.
      name: password
    - description: Password question for the new user.
      name: passwordQuestion
    - description: Password answer for question.
      name: passwordAnswer
    - auto: PREDEFINED
      description: The provider type. Can be "OKTA", "ACTIVE_DIRECTORY", "LDAP", "FEDERATION",
        or "SOCIAL".
      name: providerType
      predefined:
      - OKTA
      - ACTIVE_DIRECTORY
      - LDAP
      - FEDERATION
      - SOCIAL
    - description: Name of the provider.
      name: providerName
    - description: IDs of groups that the user will be immediately added to at time
        of creation (does Not include default group).
      name: groupIds
    - auto: PREDEFINED
      description: Whether to activate the lifecycle operation when creating the user.
        Can be "true" or "false".
      name: activate
      predefined:
      - "true"
      - "false"
    description: Creates a new user with an option of setting a password, recovery
      question, and answer. The new user will immediately be able to log in after
      activation with the assigned password. This flow is common when developing a
      custom user registration experience.
    execution: true
    name: okta-create-user
    outputs:
    - contextPath: Account.ID
      description: Created Okta account ID.
      type: String
    - contextPath: Account.Email
      description: Created Okta account email address.
      type: String
    - contextPath: Account.Username
      description: Created okta account username.
      type: String
    - contextPath: Account.DisplayName
      description: Created Okta account display name.
      type: String
    - contextPath: Account.Type
      description: Type of created account - Okta.
      type: String
    - contextPath: Account.Status
      description: Okta account current status.
      type: String
    - contextPath: Account.Created
      description: Timestamp for when the user was created.
      type: Date
    - contextPath: Account.Activated
      description: Timestamp for when the user was activated.
      type: Date
    - contextPath: Account.StatusChanged
      description: Timestamp for when the user's status was last changed.
      type: Date
    - contextPath: Account.PasswordChanged
      description: Timestamp for when the user's password was last changed.
      type: Date
  - arguments:
    - description: First name of the user (given name).
      name: firstName
    - description: Family name of the user.
      name: lastName
    - description: Primary email address of the user.
      name: email
    - description: Unique identifier for the user (login).
      name: username
      required: true
    - description: Secondary email address of the user (typically used for account
        recovery.
      name: secondEmail
    - description: Middle name(s) of the user.
      name: middleName
    - description: Honorific prefix(es) of the user, or title in most Western languages.
      name: honorificPrefix
    - description: Honorific suffix(es) of the user.
      name: honorificSuffix
    - description: User's title. For example, Vice President.
      name: title
    - description: Display name of the user.
      name: displayName
    - description: Casual way to address the user in real life (nick name).
      name: nickName
    - description: URL of the user's online profile. For example, a web page.
      name: profileUrl
    - description: Primary phone number of the user.
      name: primaryPhone
    - description: Mobile phone number of the user.
      name: mobilePhone
    - description: Full street address component of the user's address.
      name: streetAddress
    - description: City or locality component of the user's address (locality).
      name: city
    - description: State or region component of the user's address (region).
      name: state
    - description: Zip code or postal code component of the user's address (postalCode).
      name: zipCode
    - description: Country name component of the user's address (country).
      name: countryCode
    - description: Mailing address component of the user's address.
      name: postalSddress
    - description: User's preferred written or spoken languages.
      name: preferredLanguage
    - description: User's default location for purposes of localizing items such as
        currency, date-time format, numerical representations, etc.
      name: locale
    - description: User time zone.
      name: timezone
    - description: The user type, which is used to identify the organization-to-user
        relationship such as "Employee" or "Contractor".
      name: userType
    - description: Organization or company assigned unique identifier for the user.
      name: employeeNumber
    - description: Name of a cost center the user is assigned to.
      name: costCenter
    - description: Name of the user's organization.
      name: organization
    - description: Name of the user's division.
      name: division
    - description: Name of the user's department.
      name: department
    - description: ID of the user's manager.
      name: managerId
    - description: Display name of the user's manager.
      name: manager
    - description: New password for the specified user.
      name: password
    - description: Password question for the specified user.
      name: passwordQuestion
    - description: Password answer for the question.
      name: passwordAnswer
    - auto: PREDEFINED
      description: The provider type. Can be "OKTA", "ACTIVE_DIRECTORY", "LDAP", "FEDERATION",
        or "SOCIAL".
      name: providerType
      predefined:
      - OKTA
      - ACTIVE_DIRECTORY
      - FEDERATION
      - SOCIAL
    - description: Name of the provider.
      name: providerName
    description: Updates a user with a given login. All fields are optional, fields
      which are not set will not be overridden.
    execution: true
    name: okta-update-user
  - arguments:
    - description: ID of the group.
      name: groupId
    - description: The maximum number of results to return.
      name: limit
    - auto: PREDEFINED
      defaultValue: "false"
      description: Whether to print extended user details. Can be "true" or "false".
        The default is "false".
      name: verbose
      predefined:
      - "true"
      - "false"
    - description: Name of the group.
      name: groupName
    description: Enumerates all users that are members of a group.
    name: okta-get-group-members
    outputs:
    - contextPath: Account.ID
      description: Okta account ID.
      type: String
    - contextPath: Account.Email
      description: Okta account email address.
      type: String
    - contextPath: Account.Username
      description: Okta account username.
      type: String
    - contextPath: Account.DisplayName
      description: Okta account display name.
      type: String
    - contextPath: Account.Type
      description: Account type - Okta.
      type: String
    - contextPath: Account.Status
      description: Okta account current status.
      type: String
    - contextPath: Account.Created
      description: Timestamp for when the user was created.
      type: Date
    - contextPath: Account.Activated
      description: Timestamp for when the user was activated.
      type: Date
    - contextPath: Account.StatusChanged
      description: Timestamp for when the user's status was last changed.
      type: Date
    - contextPath: Account.PasswordChanged
      description: Timestamp for when the user's password was last changed.
      type: Date
  - arguments:
    - description: Searches the name property of groups for matching values.
      name: query
    - description: "Useful for performing structured queries where constraints on
        group attribute values can be explicitly targeted. \nThe following expressions
        are supported(among others) for groups with the filter query parameter: \ntype
        eq \"OKTA_GROUP\" - Groups that have a type of OKTA_GROUP; lastUpdated lt
        \"yyyy-MM-dd''T''HH:mm:ss.SSSZ\" - Groups with profile last updated before
        a specific timestamp; lastMembershipUpdated eq \"yyyy-MM-dd''T''HH:mm:ss.SSSZ\"
        - Groups with memberships last updated at a specific timestamp; id eq \"00g1emaKYZTWRYYRRTSK\"
        - Group with a specified ID. For more information about filtering, visit https://developer.okta.com/docs/api/getting_started/design_principles#filtering"
      name: filter
    - defaultValue: "200"
      description: The maximum number of results to return. The default is 200.
      name: limit
    description: Lists groups in your organization. A subset of groups can be returned
      that match a supported filter expression or query.
    name: okta-list-groups
    outputs:
    - contextPath: Okta.Group.ID
      description: Unique key for the group.
      type: String
    - contextPath: Okta.Group.Created
      description: Timestamp for when the group was created.
      type: Date
    - contextPath: Okta.Group.ObjectClass
      description: The group's profile.
      type: Unknown
    - contextPath: Okta.Group.LastUpdated
      description: Timestamp for when the group's profile was last updated.
      type: Date
    - contextPath: Okta.Group.LastMembershipUpdated
      description: Timestamp for when the group's membership was last updated.
      type: Date
    - contextPath: Okta.Group.Type
      description: The group type, which determines how a group's profile and membership
        are managed. Can be "OKTA_GROUP", "APP_GROUP", or "BUILT_IN".
      type: String
    - contextPath: Okta.Group.Name
      description: Name of the group.
      type: String
    - contextPath: Okta.Group.Description
      description: Description of the group.
      type: String
  - arguments:
    - description: 'Filters the lower time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
      name: since
    - description: 'Filters the upper time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. An example: 2017-05-03T16:22:18Z'
      name: until
    - auto: PREDEFINED
      defaultValue: ASCENDING
      description: The order of the returned events. Can be "ASCENDING" or "DESCENDING".
        The default is "ASCENDING".
      name: sortOrder
      predefined:
      - ASCENDING
      - DESCENDING
    - description: The maximum number of results to return. The default is 100.
      name: limit
    description: Returns failed login events.
    name: okta-get-failed-logins
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of the user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The OS on which the client runs. For example, Microsoft Windows
        10.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: Identifies the browser type, if relevant. For example, Chrome.
      type: String
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device that client operated from. For example, Computer.
      type: String
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests, the ID of the OAuth client making the request.
        For SSWS token requests, the ID of the agent making the request.
      type: String
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: IP address from which the client made its request.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event.
      type: String
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published.
      type: String
    - contextPath: Okta.Logs.Events.outcome.result
      description: Result of the action. Can be "SUCCESS", "FAILURE", "SKIPPED", "UNKNOWN".
      type: String
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result. For example, INVALID_CREDENTIALS.
      type: String
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when the event was published.
      type: String
    - contextPath: Okta.Logs.Events.severity
      description: The event severity. Can be "DEBUG", "INFO", "WARN", or "ERROR".
      type: String
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to.
      type: Number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to send the event's request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event's request is from a known proxy.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source.
      type: String
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target.
      type: String
  - arguments:
    - description: "Useful for performing structured queries where constraints on
        LogEvent attribute values can be explicitly targeted.  \nThe following expressions
        are supported for events with the filter query parameter: eventType eq \"
        :eventType\" \n-Events that have a specific action; eventType target.id eq
        \":id\" \n- Events published with a specific target id; actor.id eq \":id\"\n-
        Events published with a specific actor ID. For more information about filtering,
        visit https://developer.okta.com/docs/api/getting_started/design_principles#filtering"
      name: filter
    - description: "The query parameter can be used to perform keyword matching against
        a LogEvents object’s attribute values. In order to satisfy the constraint,
        all supplied keywords must be matched exactly. Note that matching is case-insensitive.
        \ The following are some examples of common keyword filtering: \nEvents that
        mention a specific city: query=San Francisco; \nEvents that mention a specific
        url: query=interestingURI.com; \nEvents that mention a specific person: query=firstName
        lastName."
      name: query
    - description: 'Filters the lower time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. For example: 2017-05-03T16:22:18Z.'
      name: since
    - description: 'Filters the upper  time bound of the log events in the Internet
        Date/Time Format profile of ISO 8601. For example: 2017-05-03T16:22:18Z.'
      name: until
    - auto: PREDEFINED
      defaultValue: ASCENDING
      description: The order of the returned events. Can be "ASCENDING" or "DESCENDING".
        The default is "ASCENDING".
      name: sortOrder
      predefined:
      - ASCENDING
      - DESCENDING
    - defaultValue: "100"
      description: The maximum number of results to return. The default is 100.
      name: limit
    description: Gets logs by providing optional filters.
    name: okta-get-logs
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The operation system on which the client runs. For example, Microsoft
        Windows 10.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: Identifies the type of web browser, if relevant. For example, Chrome.
      type: String
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device from which the client operated. For example, Computer.
      type: String
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests, the ID of the OAuth client making the request.
        For SSWS token requests, the ID of the agent making the request.
      type: String
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: IP address from which the client made its request.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event.
      type: String
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published.
      type: String
    - contextPath: Okta.Logs.Events.outcome.result
      description: Result of the action. Can be "SUCCESS", "FAILURE", "SKIPPED", or
        "UNKNOWN".
      type: String
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result. For example, INVALID_CREDENTIALS.
      type: String
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when the event was published.
      type: String
    - contextPath: Okta.Logs.Events.severity
      description: The event severity. Can be "DEBUG", "INFO", "WARN", or "ERROR".
      type: String
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to.
      type: Number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to send the event's request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event's request is from a known proxy.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source.
      type: String
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target.
      type: String
  - arguments:
    - description: Filters the lower time bound of the log event in the Internet Date\Time
        format profile of ISO 8601. For example, 2020-02-14T16:00:18Z.
      name: since
    - description: Filters the upper time bound of the log event in the Internet Date\Time
        format profile of ISO 8601. For example, 2020-02-14T16:00:18Z.
      name: until
    - auto: PREDEFINED
      defaultValue: ASCENDING
      description: The order of the returned events. Can be "ASCENDING" or "DESCENDING".
        The default is "ASCENDING".
      name: sortOrder
      predefined:
      - ASCENDING
      - DESCENDING
    - defaultValue: "100"
      description: The maximum number of results to return. The default is 100.
      name: limit
    description: Gets events for when a user was added to a group.
    name: okta-get-group-assignments
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of the actor.
      type: String
    - contextPath: Okta.Logs.Event.actor.id
      description: ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The OS on which the client runs. For example, Microsoft Windows
        10.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: Identifies the type of web browser, if relevant. For example, Chrome.
      type: String
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device from which the client operated. For example, Computer.
      type: String
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests, the ID of the OAuth client making the request.
        For SSWS token requests, the ID of the agent making the request.
      type: String
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: IP address from which the client made its request.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.state
      description: Full name of the state or province encompassing in the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event.
      type: String
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published.
      type: String
    - contextPath: Okta.Logs.Events.outcome.result
      description: Result of the action. Can be "SUCCESS", "FAILURE", "SKIPPED", or
        "UNKNOWN".
      type: String
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result. For example INVALID_CREDENTIALS.
      type: Unknown
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when the event was published.
      type: String
    - contextPath: Okta.Logs.Events.severity
      description: The event severity. Can be "DEBUG", "INFO", "WARN", or "ERROR".
      type: String
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to.
      type: Number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to send the event's request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event's request is from a known proxy.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source.
      type: String
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.type
      description: Target type.
      type: String
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target.
      type: String
  - arguments:
    - description: Filters the lower time bound of the log event in the Internet Date\Time
        format profile of ISO 8601. For example, 2020-02-14T16:00:18Z.
      name: since
    - description: Filters the upper time bound of the log event in the Internet Date\Time
        format profile of ISO 8601. For example, 2020-02-14T16:00:18Z.
      name: until
    - auto: PREDEFINED
      defaultValue: ASCENDING
      description: The order of the returned events. Can be "ASCENDING" or "DESCENDING".
        The default is "ASCENDING".
      name: sortOrder
      predefined:
      - ASCENDING
      - DESCENDING
    - defaultValue: "100"
      description: The maximum number of results to return. The default is 100.
      name: limit
    description: Returns events for when a user was assigned to an application.
    name: okta-get-application-assignments
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of the actor.
      type: String
    - contextPath: Okta.Logs.Event.actor.id
      description: ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of the user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The OS on which the client runs. For example, Microsoft Windows
        10.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: Identifies the type of web browser, if relevant. For example, Chrome.
      type: String
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device from which the client operated. For example, Computer.
      type: String
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests, the ID of the OAuth client making the request.
        For SSWS token requests, the ID of the agent making the request.
      type: String
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: IP address from which the client made its request.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event.
      type: String
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published.
      type: String
    - contextPath: Okta.Logs.Events.outcome.result
      description: Result of the action. For example, "SUCCESS", "FAILURE", "SKIPPED",
        or "UNKNOWN".
      type: String
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result. For example INVALID_CREDENTIALS.
      type: String
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when the event was published.
      type: String
    - contextPath: Okta.Logs.Events.severity
      description: The event severity. Can be "DEBUG", "INFO", "WARN", or "ERROR".
      type: String
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to.
      type: Number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to send the event's request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event's request is from a known proxy.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source.
      type: String
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target.
      type: String
  - arguments:
    - description: Filters the lower time bound of the log event in the Internet Date\Time
        format profile of ISO 8601. For example, 2020-02-14T16:00:18Z.
      name: since
    - description: Filters the upper time bound of the log event in the Internet Date\Time
        format profile of ISO 8601. For example, 2020-02-14T16:00:18Z.
      name: until
    - auto: PREDEFINED
      defaultValue: ASCENDING
      description: The order of the returned events. Can be "ASCENDING" or "DESCENDING".
        The default is "ASCENDING".
      name: sortOrder
      predefined:
      - ASCENDING
      - DESCENDING
    - defaultValue: "100"
      description: The maximum number of results to return. The default is 100.
      name: limit
    description: Returns logs using specified filters.
    name: okta-get-application-authentication
    outputs:
    - contextPath: Okta.Logs.Events.actor.alternateId
      description: Alternative ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.displayName
      description: Display name of the actor.
      type: String
    - contextPath: Okta.Logs.Events.actor.id
      description: ID of the actor.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.rawUserAgent
      description: A raw string representation of user agent, formatted according
        to section 5.5.3 of HTTP/1.1 Semantics and Content. Both the browser and the
        OS fields can be derived from this field.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.os
      description: The OS on which the client runs. For example, Microsoft Windows
        10.
      type: String
    - contextPath: Okta.Logs.Events.client.userAgent.browser
      description: Identifies the type of web browser, if relevant. For example, Chrome.
      type: String
    - contextPath: Okta.Logs.Events.client.device
      description: Type of device from which the client operated. For example, Computer.
      type: String
    - contextPath: Okta.Logs.Events.client.id
      description: For OAuth requests, the ID of the OAuth client making the request.
        For SSWS token requests, the ID of the agent making the request.
      type: String
    - contextPath: Okta.Logs.Events.client.ipAddress
      description: IP address from which the client made its request.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.client.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.displayMessage
      description: The display message for an event.
      type: String
    - contextPath: Okta.Logs.Events.eventType
      description: Type of event that was published.
      type: String
    - contextPath: Okta.Logs.Events.outcome.result
      description: Result of the action. Can be "SUCCESS", "FAILURE", "SKIPPED", or
        "UNKNOWN".
      type: String
    - contextPath: Okta.Logs.Events.outcome.reason
      description: Reason for the result. For example INVALID_CREDENTIALS.
      type: String
    - contextPath: Okta.Logs.Events.published
      description: Timestamp when the event was published.
      type: String
    - contextPath: Okta.Logs.Events.severity
      description: The event severity. Can be "DEBUG", "INFO", "WARN", or "ERROR".
      type: String
    - contextPath: Okta.Logs.Events.securityContext.asNumber
      description: Autonomous system number associated with the autonomous system
        that the event request was sourced to.
      type: Number
    - contextPath: Okta.Logs.Events.securityContext.asOrg
      description: Organization associated with the autonomous system that the event
        request was sourced to.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isp
      description: Internet service provider used to send the event's request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.domain
      description: The domain name associated with the IP address of the inbound event
        request.
      type: String
    - contextPath: Okta.Logs.Events.securityContext.isProxy
      description: Specifies whether an event's request is from a known proxy.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.IP
      description: IP address.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.city
      description: The city encompassing the area containing the geo-location coordinates,
        if available. For example, Seattle, San Francisco.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.state
      description: Full name of the state or province encompassing the area containing
        the geo-location coordinates. For example, Montana, Incheon.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.geographicalContext.country
      description: Full name of the country encompassing the area containing the geo-location
        coordinates. For example, France, Uganda.
      type: String
    - contextPath: Okta.Logs.Events.request.ipChain.source
      description: Details regarding the source.
      type: String
    - contextPath: Okta.Logs.Events.target.id
      description: ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.type
      description: Type of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.alternateId
      description: Alternative ID of a target.
      type: String
    - contextPath: Okta.Logs.Events.target.displayName
      description: Display name of a target.
      type: String
  - arguments:
    - description: Okta User ID.
      name: userId
    - description: Username of the user.
      name: username
    description: Deletes the specified user.
    execution: true
    name: okta-delete-user
  - arguments:
    - description: Okta User ID.
      name: userId
      required: true
    description: |-
      Removes all active identity provider sessions. This forces the user to authenticate upon the next operation. Optionally revokes OpenID Connect and OAuth refresh and access tokens issued to the user.
      For more information and examples:
      https://developer.okta.com/docs/reference/api/users/#user-sessions
    name: okta-clear-user-sessions
  dockerimage: demisto/python3:3.8.2.6981
  runonce: false
  script: |2


    # IMPORTS
    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    # CONSTANTS
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%SZ'
    SEARCH_LIMIT = 200
    PROFILE_ARGS = [
        'firstName',
        'lastName',
        'email',
        'login',
        'secondEmail',
        'middleName',
        'honorificPrefix',
        'honorificSuffix',
        'title',
        'displayName',
        'nickName',
        'profileUrl',
        'primaryPhone',
        'mobilePhone',
        'streetAddress',
        'city',
        'state',
        'zipCode',
        'countryCode',
        'postalAddress',
        'preferredLanguage',
        'locale',
        'timezone',
        'userType',
        'employeeNumber',
        'costCenter',
        'organization',
        'division',
        'department',
        'managerId',
        'manager'
    ]


    class Client(BaseClient):
        """
        Client will implement the service API, and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        # Getting Group Id with a given group name
        def get_group_id(self, group_name):
            uri = 'groups'
            query_params = {
                'q': encode_string_results(group_name)
            }
            res = self._http_request(
                method="GET",
                url_suffix=uri,
                params=query_params
            )
            if res and len(res) == 1:
                return res[0].get('id')

        # Getting User Id with a given username
        def get_user_id(self, username):
            uri = 'users'
            query_params = {
                'filter': encode_string_results(f'profile.login eq "{username}"')
            }
            res = self._http_request(
                method='GET',
                url_suffix=uri,
                params=query_params

            )
            if res and len(res) == 1:
                return res[0].get('id')
            raise Exception(f'Failed to find userID for: {username} username.')

        def unlock_user(self, user_id):
            """
            sending a POST request to unlock a specific user
            """
            uri = f'users/{user_id}/lifecycle/unlock'
            return self._http_request(
                method='POST',
                url_suffix=uri
            )

        def deactivate_user(self, user_id):
            uri = f'users/{user_id}/lifecycle/deactivate'
            return self._http_request(
                method="POST",
                url_suffix=uri
            )

        def activate_user(self, user_id):
            uri = f'users/{user_id}/lifecycle/activate'
            return self._http_request(
                method="POST",
                url_suffix=uri
            )

        def suspend_user(self, user_id):
            uri = f'users/{user_id}/lifecycle/suspend'
            return self._http_request(
                method="POST",
                url_suffix=uri
            )

        def unsuspend_user(self, user_id):
            uri = f'users/{user_id}/lifecycle/unsuspend'
            return self._http_request(
                method="POST",
                url_suffix=uri
            )

        def get_user_factors(self, user_id):
            uri = f'users/{user_id}/factors'
            return self._http_request(
                method="GET",
                url_suffix=uri
            )

        def reset_factor(self, user_id, factor_id):
            uri = f'users/{user_id}/factors/{factor_id}'
            return self._http_request(
                method="DELETE",
                url_suffix=uri,
                resp_type='text'
            )

        def set_password(self, user_id, password):
            uri = f'users/{user_id}'
            body = {
                "credentials": {
                    "password": {"value": password}
                }
            }

            return self._http_request(
                method="POST",
                url_suffix=uri,
                json_data=body
            )

        def add_user_to_group(self, user_id, group_id):
            uri = f'groups/{group_id}/users/{user_id}'
            return self._http_request(
                method="PUT",
                url_suffix=uri,
                resp_type='text'
            )

        def remove_user_from_group(self, user_id, group_id):
            uri = f'groups/{group_id}/users/{user_id}'
            return self._http_request(
                method="DELETE",
                url_suffix=uri,
                resp_type='text'
            )

        def get_groups_for_user(self, user_id):
            uri = f'users/{user_id}/groups'
            return self._http_request(
                method="GET",
                url_suffix=uri
            )

        @staticmethod
        def get_readable_groups(raw_groups):
            groups = []
            raw_groups = raw_groups if isinstance(raw_groups, list) else [raw_groups]
            for group in raw_groups:
                group = {
                    'ID': group.get('id'),
                    'Created': group.get('created'),
                    'ObjectClass': group.get('objectClass'),
                    'LastUpdated': group.get('lastUpdated'),
                    'LastMembershipUpdated': group.get('lastMembershipUpdated'),
                    'Type': group.get('type'),
                    'Name': group.get('profile', {}).get('name'),
                    'Description': group.get('profile', {}).get('description')
                }
                groups.append(group)
            return groups

        @staticmethod
        def get_readable_logs(raw_logs):
            logs = []
            raw_logs = raw_logs if isinstance(raw_logs, list) else [raw_logs]
            for log in raw_logs:
                if log.get('client', {}).get('userAgent'):
                    browser = log.get('client', {}).get('userAgent').get('browser')
                    if (not browser) or browser.lower() == 'unknown':
                        browser = 'Unknown browser'
                    os = log.get('client', {}).get('userAgent').get('os')
                    if (not os) or os.lower() == 'unknown':
                        os = 'Unknown OS'
                    device = log.get('client', {}).get('device')
                if (not device) or device.lower() == 'unknown':
                    device = 'Unknown device'
                targets = ''
                if log.get('target'):
                    for target in log.get('target'):
                        targets += f"{target.get('displayName')} ({target.get('type')})\n"
                time_published = datetime.strptime(log.get('published'), '%Y-%m-%dT%H:%M:%S.%f%z').strftime("%m/%d/%Y, "
                                                                                                            "%H:%M:%S")
                log = {
                    'Actor': f"{log.get('actor', {}).get('displayName')} ({log.get('actor', {}).get('type')})",
                    'ActorAlternaneId': log.get('actor', {}).get('alternateId'),
                    'EventInfo': log.get('displayMessage'),
                    'EventOutcome': log.get('outcome', {}).get('result') + (
                        f": {log.get('outcome', {}).get('reason')}" if log.get('outcome', {}).get('reason') else ''),
                    'EventSeverity': log.get('severity'),
                    'Client': f"{browser} on {os} {device}",
                    'RequestIP': log.get('client', {}).get('ipAddress'),
                    'ChainIP': log.get('request', {}).get('ipChain')[0].get('ip'),
                    'Targets': targets or '-',
                    'Time': time_published
                }
                logs.append(log)
            return logs

        @staticmethod
        def get_readable_factors(raw_factors):
            factors = []
            for factor in raw_factors:
                factor = {
                    'ID': factor.get('id'),
                    'FactorType': factor.get('factorType'),
                    'Provider': factor.get('provider'),
                    'Status': factor.get('status'),
                    'Profile': factor.get('profile')
                }
                factors.append(factor)
            return factors

        def verify_push_factor(self, user_id, factor_id):
            """
            Creates a new transaction and sends an asynchronous push notification to the device for the user to approve or reject.
            You must poll the transaction to determine when it completes or expires.
            """
            uri = f'users/{user_id}/factors/{factor_id}/verify'
            return self._http_request(
                method="POST",
                url_suffix=uri
            )

        def poll_verify_push(self, url):
            """
            Keep polling authentication transactions with WAITING result until the challenge completes or expires.
            time limit defined by us = one minute
            """
            counter = 0
            while counter < 10:
                response = self._http_request(
                    method='GET',
                    full_url=url,
                    url_suffix=''
                )
                if not response.get('factorResult') == 'WAITING':
                    return response
                counter += 1
                time.sleep(5)
            response['factorResult'] = "TIMEOUT"
            return response

        def search(self, term, limit):
            uri = f"users"
            query_params = {
                'q': encode_string_results(term),
                'limit': limit
            }
            return self._http_request(
                method='GET',
                url_suffix=uri,
                params=query_params
            )

        @staticmethod
        def get_users_context(raw_users):
            users = []
            raw_users = raw_users if isinstance(raw_users, list) else [raw_users]
            for user in raw_users:
                user = {
                    'ID': user.get('id'),
                    'Username': user.get('profile', {}).get('login'),
                    'DisplayName':
                        f"{user.get('profile', {}).get('firstName', '')} {user.get('profile', {}).get('lastName', '')}",
                    'Email': user.get('profile', {}).get('email'),
                    'Status': user.get('status'),
                    'Type': 'Okta',
                    'Created': user.get('created'),
                    'Activated': user.get('activated'),
                    'StatusChanged': user.get('statusChanged'),
                    'PasswordChanged': user.get('passwordChanged')
                }
                if user.get('group'):
                    user['Group'] = user.get('group')
                users.append(user)
            return users

        @staticmethod
        def get_readable_users(raw_users, verbose='false'):
            raw_users = raw_users if isinstance(raw_users, list) else [raw_users]
            if verbose == 'true':
                users_verbose = ''
                for user in raw_users:
                    profile = {
                        'First Name': user.get('profile', {}).get('firstName'),
                        'Last Name': user.get('profile', {}).get('lastName'),
                        'Mobile Phone': user.get('profile', {}).get('mobilePhone'),
                        'Login': user.get('profile', {}).get('login'),
                        'Email': user.get('profile', {}).get('email'),
                        'Second Email': user.get('profile', {}).get('secondEmail'),
                    }
                    additionalData = {
                        'ID': user.get('id'),
                        'Status': user.get('status'),
                        'Created': user.get('created'),
                        'Activated': user.get('activated'),
                        'Status Changed': user.get('userChanged'),
                        'Last Login': user.get('lastLogin'),
                        'Last Updated': user.get('lastUpdated'),
                        'Password Changed': user.get('passwordChanged'),
                        'Type': user.get('type'),
                        'Credentials': user.get('credentials'),
                        '_links': user.get('_links')
                    }
                    if user.get('group'):
                        additionalData['Group'] = user.get('group')
                    users_verbose += f"### User:{profile.get('Login')}\n" \
                                     f"{tableToMarkdown('Profile', profile)}\n {tableToMarkdown('Additional Data', additionalData)}"
                return users_verbose

            else:
                users = []
                for user in raw_users:
                    user = {
                        'ID': user.get('id'),
                        'Login': user.get('profile').get('login'),
                        'First Name': user.get('profile').get('firstName'),
                        'Last Name': user.get('profile').get('lastName'),
                        'Mobile Phone': user.get('profile').get('mobilePhone'),
                        'Last Login': user.get('lastLogin'),
                        'Status': user.get('status')
                    }
                    users.append(user)
                return users

        def get_user(self, user_term):
            uri = f'users/{encode_string_results(user_term)}'
            return self._http_request(
                method='GET',
                url_suffix=uri
            )

        def create_user(self, cred, profile, group_ids, activate):
            body = {
                'profile': profile,
                'groupIds': group_ids or [],
                'credentials': cred
            }
            uri = 'users'
            query_params = {
                'activate': activate,
                'provider': 'true' if cred.get('provider') else None
            }
            return self._http_request(
                method='POST',
                url_suffix=uri,
                json_data=body,
                params=query_params
            )

        # Build profile dict with pre-defined keys (for user)
        @staticmethod
        def build_profile(args):
            profile = {}
            keys = args.keys()
            for key in PROFILE_ARGS:
                if key in keys:
                    profile[key] = args[key]
            return profile

        # Build credentials dict with predefined keys (for user)
        @staticmethod
        def build_credentials(args):
            cred = {}
            if args.get('password'):
                cred['password'] = {"value": args.get('password')}
            if args.get('passwordQuestion') and args.get('passwordAnswer'):
                cred['recovery_question'] = {
                    "question": args.get('passwordQuestion'),
                    "answer": args.get('passwordAnswer')
                }
            if args.get('providerName') and args.get('providerType'):
                cred['provider'] = {
                    'name': args.get('providerName'),
                    'type': args.get('providerType')
                }
            return cred

        def update_user(self, user_id, profile, cred):
            body = {
                "profile": profile,
                "credentials": cred
            }
            uri = f"users/{user_id}"
            return self._http_request(
                method='POST',
                url_suffix=uri,
                json_data=body
            )

        def get_paged_results(self, uri, query_param=None):
            response = self._http_request(
                method="GET",
                url_suffix=uri,
                resp_type='response',
                params=query_param
            )
            paged_results = response.json()
            while "next" in response.links and len(response.json()) > 0:
                next_page = response.links.get("next").get("url")
                response = self._http_request(
                    method="GET",
                    full_url=next_page,
                    url_suffix='',
                    resp_type='response',
                    params=query_param

                )
                paged_results += response.json()
            return paged_results

        def get_group_members(self, group_id, limit):
            uri = f'groups/{group_id}/users'
            if limit:
                query_params = {
                    'limit': limit
                }
                return self._http_request(
                    method="GET",
                    url_suffix=uri,
                    params=query_params
                )
            return self.get_paged_results(uri)

        def list_groups(self, args):
            # Base url - if none of the the above specified - returns all the groups (default 200 items)
            uri = f"groups"
            query_params = {}
            for key, value in args.items():
                if key == 'query':
                    key = 'q'
                query_params[key] = encode_string_results(value)
            if args.get('limit'):
                return self._http_request(
                    method='GET',
                    url_suffix=uri,
                    params=query_params
                )
            return self.get_paged_results(uri, query_params)

        def get_logs(self, args):
            uri = f'logs'
            query_params = {}
            for key, value in args.items():
                if key == 'query':
                    key = 'q'
                query_params[key] = encode_string_results(value)
            if args.get('limit'):
                return self._http_request(
                    method='GET',
                    url_suffix=uri,
                    params=query_params
                )
            return self.get_paged_results(uri, query_params)

        def delete_user(self, user_term):
            uri = f"users/{encode_string_results(user_term)}"
            return self._http_request(
                method="DELETE",
                url_suffix=uri,
                resp_type='text'
            )

        def clear_user_sessions(self, user_id):
            uri = f'users/{user_id}/sessions'
            return self._http_request(
                method='DELETE',
                url_suffix=uri,
                resp_type='text'
            )


    def test_module(client, args):
        """
        Returning 'ok' indicates that the integration works like it is supposed to. Connection to the service is successful.

        Args:
            client: HelloWorld client

        Returns:
            'ok' if test passed, anything else will fail the test.
        """
        args
        uri = 'users/me'
        client._http_request(method='GET', url_suffix=uri)
        return 'ok', None, None


    def unlock_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.unlock_user(user_id)

        readable_output = f"### {args.get('username')} unlocked"

        return (
            readable_output,
            {},
            raw_response  # raw response - the original response
        )


    def activate_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.activate_user(user_id)

        readable_output = f"### {args.get('username')} is active now"
        return (
            readable_output,
            {},
            raw_response
        )


    def deactivate_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.deactivate_user(user_id)

        readable_output = f"### User {args.get('username')} deactivated"

        return (
            readable_output,
            {},
            raw_response  # raw response - the original response
        )


    def suspend_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.suspend_user(user_id)

        readable_output = f"### {args.get('username')} status is Suspended"
        return (
            readable_output,
            {},
            raw_response
        )


    def unsuspend_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.unsuspend_user(user_id)

        readable_output = f"### {args.get('username')} is no longer SUSPENDED"
        return (
            readable_output,
            {},
            raw_response
        )


    def get_user_factors_command(client, args):
        user_id = args.get('userId')

        if not (args.get('username') or user_id):
            raise Exception("You must supply either 'Username' or 'userId")

        if not user_id:
            user_id = client.get_user_id(args.get('username'))

        raw_response = client.get_user_factors(user_id)
        if not raw_response or len(raw_response) == 0:
            raise Exception('No Factors found')

        factors = client.get_readable_factors(raw_response)
        context = createContext(factors, removeNull=True)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': {
                'Factor': context,
                'ID': user_id
            }
        }
        readable_output = f"Factors for user: {user_id}\n {tableToMarkdown('Factors', factors)}"
        return (
            readable_output,
            outputs,
            raw_response
        )


    def reset_factor_command(client, args):
        factor_id = args.get('factorId')
        user_id = args.get('userId')

        if not (args.get('username') or user_id):
            raise Exception("You must supply either 'Username' or 'userId")

        if not user_id:
            user_id = client.get_user_id(args.get('username'))

        raw_response = client.reset_factor(user_id, factor_id)

        readable_output = f"Factor: {factor_id} deleted"
        return (
            readable_output,
            {},
            raw_response
        )


    def set_password_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        password = args.get('password')

        raw_response = client.set_password(user_id, password)
        readable_output = f"{args.get('username')} password was last changed on {raw_response.get('passwordChanged')}"
        return (
            readable_output,
            {},
            raw_response
        )


    def add_user_to_group_command(client, args):
        group_id = args.get('groupId')
        user_id = args.get('userId')

        if (not (args.get('username') or user_id)) or (not (args.get('groupName') or group_id)):
            raise Exception("You must supply either 'Username' or 'userId")
        if not user_id:
            user_id = client.get_user_id(args.get('username'))
        if not group_id:
            group_id = client.get_group_id(args.get('groupName'))
        raw_response = client.add_user_to_group(user_id, group_id)
        readable_output = f"User: {user_id} added to group: {args.get('groupName')} successfully"
        return (
            readable_output,
            {},
            raw_response
        )


    def remove_from_group_command(client, args):
        group_id = args.get('groupId')
        user_id = args.get('userId')

        if (not (args.get('username') or user_id)) or (not (args.get('groupName') or group_id)):
            raise Exception("You must supply either 'Username' or 'userId' and either 'groupName' or 'groupId'")
        if not user_id:
            user_id = client.get_user_id(args.get('username'))
        if not group_id:
            group_id = client.get_group_id(args.get('groupName'))
        raw_response = client.remove_user_from_group(user_id, group_id)
        readable_output = f"User: {user_id} was removed from group: {args.get('groupName')} successfully"
        return (
            readable_output,
            {},
            raw_response)


    def get_groups_for_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        raw_response = client.get_groups_for_user(user_id)
        groups = client.get_readable_groups(raw_response)

        context = createContext(groups, removeNull=True)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': {
                'Group': context,
                'ID': user_id,
                'Type': 'Okta'
            }
        }
        readable_output = f"Okta groups for user: {args.get('username')}\n {tableToMarkdown('Groups', groups)}"

        return (
            readable_output,
            outputs,
            raw_response
        )


    def verify_push_factor_command(client, args):
        user_id = args.get('userId')
        factor_id = args.get('factorId')

        raw_response = client.verify_push_factor(user_id, factor_id)
        poll_link = raw_response.get('_links').get('poll')
        if not poll_link:
            raise Exception('No poll link for the push factor challenge')
        poll_response = client.poll_verify_push(poll_link.get('href'))

        outputs = {
            'Account(val.ID && val.ID === obj.ID)': {
                'ID': user_id,
                "VerifyPushResult": poll_response.get('factorResult')
            }
        }
        readable_output = f"Verify push factor result for user {user_id}: {poll_response.get('factorResult')}"
        return (
            readable_output,
            outputs,
            raw_response
        )


    def search_command(client, args):
        term = args.get('term')
        limit = args.get('limit') or SEARCH_LIMIT
        verbose = args.get('verbose')
        raw_response = client.search(term, limit)

        if raw_response and len(raw_response) > 0:
            users_context = client.get_users_context(raw_response)
            users_readable = client.get_readable_users(raw_response, verbose)
            context = createContext(users_context, removeNull=True)
            outputs = {
                'Account(val.ID && val.ID === obj.ID)': context
            }
            if verbose == 'true':
                readable_output = f"### Okta users found:\n {users_readable}"
            else:
                readable_output = f"### Okta users found:\n {tableToMarkdown('Users:', users_readable)} "
            return (
                readable_output,
                outputs,
                raw_response
            )
        return 'No users found in Okta', {}, raw_response


    def get_user_command(client, args):
        if not (args.get('username') or args.get('userId')):
            raise Exception("You must supply either 'Username' or 'userId")
        user_term = args.get('userId') if args.get('userId') else args.get('username')
        raw_response = client.get_user(user_term)
        verbose = args.get('verbose')

        user_context = client.get_users_context(raw_response)
        user_readable = client.get_readable_users(raw_response, verbose)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': createContext(user_context)
        }
        readable_output = user_readable if verbose == 'true' else f"{tableToMarkdown(f'User:{user_term}', user_readable)} "
        return (
            readable_output,
            outputs,
            raw_response
        )


    def create_user_command(client, args):
        group_ids = args.get('groupIds')
        cred = client.build_credentials(args)
        profile = client.build_profile(args)
        if group_ids:
            group_ids = args.get('groupIds').split(',')
        activate = 'true' if args.get('activate') == 'true' else 'false'
        raw_response = client.create_user(cred, profile, group_ids, activate)
        user_context = client.get_users_context(raw_response)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': createContext(user_context)
        }
        readable_output = tableToMarkdown(f"Okta User Created: {args.get('login')}:",
                                          client.get_readable_users(raw_response))
        return (
            readable_output,
            outputs,
            raw_response
        )


    def update_user_command(client, args):
        user_id = client.get_user_id(args.get('username'))
        cred = client.build_credentials(args)
        profile = client.build_profile(args)
        profile['login'] = args.get('username')
        raw_response = client.update_user(user_id, profile, cred)
        readable_output = tableToMarkdown(f"Okta user: {args.get('username')} Updated:", raw_response.get('profile'))
        return (
            readable_output,
            {},
            raw_response
        )


    def get_group_members_command(client, args):
        if not (args.get('groupId') or args.get('groupName')):
            raise Exception("You must supply either 'groupName' or 'groupId")
        limit = args.get('limit')
        group_id = args.get('groupId') or client.get_group_id(args.get('groupName'))
        raw_members = client.get_group_members(group_id, limit)
        users_context = client.get_users_context(raw_members)
        users_readable = client.get_readable_users(raw_members, args.get('verbose'))
        context = createContext(users_context, removeNull=True)
        outputs = {
            'Account(val.ID && val.ID === obj.ID)': context
        }
        if args.get('verbose') == 'true':
            return (
                f"### Users for group: {args.get('groupName') or group_id}:\n {users_readable}",
                outputs,
                raw_members
            )
        return (
            tableToMarkdown(f"Users for group: {args.get('groupName') or group_id}", users_readable),
            outputs,
            raw_members
        )


    def list_groups_command(client, args):
        raw_response = client.list_groups(args)
        groups = client.get_readable_groups(raw_response)
        context = createContext(groups, removeNull=True)
        outputs = {
            'Okta.Group(val.ID && val.ID === obj.ID)': context
        }
        readable_output = tableToMarkdown('Groups', groups)

        return (
            readable_output,
            outputs,
            raw_response
        )


    def get_logs_command(client, args):
        raw_response = client.get_logs(args)
        if not raw_response:
            return 'No logs found', {}, raw_response

        logs = client.get_readable_logs(raw_response)
        readable_output = tableToMarkdown('Okta Events', logs)
        outputs = {
            'Okta.Logs.Events(val.uuid && val.uuid === obj.uuid)': createContext(raw_response)
        }
        return (
            readable_output,
            outputs,
            raw_response
        )


    def get_failed_login_command(client, args):
        args['filter'] = 'eventType eq "user.session.start" and outcome.result eq "FAILURE"'
        raw_response = client.get_logs(args)
        if not raw_response:
            return 'No logs found', {}, raw_response
        logs = client.get_readable_logs(raw_response)
        readable_output = tableToMarkdown('Failed Login Events', logs)
        outputs = {
            'Okta.Logs.Events(val.uuid && val.uuid === obj.uuid)': createContext(raw_response)
        }
        return (
            readable_output,
            outputs,
            raw_response
        )


    def get_group_assignments_command(client, args):
        args['filter'] = 'eventType eq "group.user_membership.add"'
        raw_response = client.get_logs(args)
        if not raw_response:
            return 'No logs found', {}, raw_response
        logs = client.get_readable_logs(raw_response)
        readable_output = tableToMarkdown('Group Assignment Events', logs)
        outputs = {
            'Okta.Logs.Events(val.uuid && val.uuid === obj.uuid)': createContext(raw_response)
        }
        return (
            readable_output,
            outputs,
            raw_response
        )


    def get_application_assignments_command(client, args):
        args['filter'] = 'eventType eq "application.user_membership.add"'
        raw_response = client.get_logs(args)
        if not raw_response:
            return 'No logs found', {}, raw_response
        logs = client.get_readable_logs(raw_response)
        readable_output = tableToMarkdown('Application Assignment Events', logs)
        outputs = {
            'Okta.Logs.Events(val.uuid && val.uuid === obj.uuid)': createContext(raw_response)
        }
        return (
            readable_output,
            outputs,
            raw_response
        )


    def get_application_authentication_command(client, args):
        args['filter'] = 'eventType eq "user.authentication.sso"'
        raw_response = client.get_logs(args)
        if not raw_response:
            return 'No logs found', {}, raw_response
        logs = client.get_readable_logs(raw_response)
        readable_output = tableToMarkdown('Application Authentication Events', logs)
        outputs = {
            'Okta.Logs.Events(val.uuid && val.uuid === obj.uuid)': createContext(raw_response)
        }
        return (
            readable_output,
            outputs,
            raw_response
        )


    def delete_user_command(client, args):
        if not (args.get('username') or args.get('userId')):
            raise Exception("You must supply either 'Username' or 'userId")
        user_term = args.get('userId') or args.get('username')
        # Deletes a user permanently. This operation can only be performed on users that have a DEPROVISIONED status.
        # This action cannot be recovered!This operation on a user that hasn't been deactivated
        # causes that user to be deactivated. A second delete operation is required to delete the user.
        user = client.get_user(user_term)
        if user.get('status') != 'DEPROVISIONED':
            client.deactivate_user(args.get('userId') or client.get_user_id(args.get('username')))
        raw_response = client.delete_user(user_term)
        readable_output = f"User: {user_term} was Deleted successfully"
        return (
            readable_output,
            {},
            raw_response)


    def clear_user_sessions_command(client, args):
        user_id = args.get('userId')
        raw_response = client.clear_user_sessions(user_id)
        readable_output = f"### User session was cleared for: {user_id}"

        return readable_output, {}, raw_response


    def main():
        """
            PARSE AND VALIDATE INTEGRATION PARAMS
        """
        # get the service API url
        base_url = urljoin(demisto.params()['url'].strip('/'), '/api/v1/')
        apitoken = demisto.params().get('apitoken')
        verify_certificate = not demisto.params().get('insecure', False)
        proxy = demisto.params().get('proxy', False)

        LOG(f'Command being called is {demisto.command()}')

        commands = {
            'test-module': test_module,
            'okta-unlock-user': unlock_user_command,
            'okta-deactivate-user': deactivate_user_command,
            'okta-activate-user': activate_user_command,
            'okta-suspend-user': suspend_user_command,
            'okta-unsuspend-user': unsuspend_user_command,
            'okta-reset-factor': reset_factor_command,
            'okta-set-password': set_password_command,
            'okta-add-to-group': add_user_to_group_command,
            'okta-remove-from-group': remove_from_group_command,
            'okta-get-groups': get_groups_for_user_command,
            'okta-get-user-factors': get_user_factors_command,
            'okta-verify-push-factor': verify_push_factor_command,
            'okta-search': search_command,
            'okta-get-user': get_user_command,
            'okta-create-user': create_user_command,
            'okta-update-user': update_user_command,
            'okta-get-group-members': get_group_members_command,
            'okta-list-groups': list_groups_command,
            'okta-get-logs': get_logs_command,
            'okta-get-failed-logins': get_failed_login_command,
            'okta-get-application-assignments': get_application_assignments_command,
            'okta-get-group-assignments': get_group_assignments_command,
            'okta-get-application-authentication': get_application_authentication_command,
            'okta-delete-user': delete_user_command,
            'okta-clear-user-sessions': clear_user_sessions_command
        }

        command = demisto.command()

        client = Client(
            base_url=base_url,
            verify=verify_certificate,
            headers={
                'Accept': 'application/json',
                'Content-Type': 'application/json',
                'Authorization': f'SSWS {apitoken}'
            },
            proxy=proxy,
            ok_codes=(200, 201, 204))

        try:
            if command in commands:
                human_readable, outputs, raw_response = commands[command](client, demisto.args())
                return_outputs(readable_output=human_readable, outputs=outputs, raw_response=raw_response)

        # Log exceptions
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}')


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()
  subtype: python3
  type: python
system: true
