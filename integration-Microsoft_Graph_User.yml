category: Analytics & SIEM
commonfields:
  id: Microsoft Graph User
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Host URL (e.g., https://graph.microsoft.com)
  name: host
  required: true
  type: 0
- defaultvalue: ""
  display: ID (received from the admin consent - see Detailed Instructions (?)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  name: tenant_id
  required: true
  type: 4
- defaultvalue: ""
  display: Key (received from the admin consent - see Detailed Instructions (?)
  name: enc_key
  required: true
  type: 4
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Use a self-deployed Azure Application
  name: self_deployed
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Unified gateway to security insights - all from a unified Microsoft Graph
  User API.
detaileddescription: |-
  To allow us access to Microsoft Graph User, an admin has to approve our app using an admin consent flow, by clicking on the following [link](https://oproxy.demisto.ninja/ms-graph-user).
  After authorizing the Demisto app, you will get an ID, Token, and Key, which should be inserted in the integration instance configuration's corresponding fields.
display: Microsoft Graph User
image: data:image/png;base64,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
name: Microsoft Graph User
script:
  commands:
  - arguments:
    - description: User ID or userPrincipalName
      name: user
      required: true
    description: "Terminates a user's session from all Office 365 applications, and
      prevents sign in.\nPermissions: - User.ReadWrite (Delegated & Application) "
    name: msgraph-user-terminate-session
  - arguments:
    - description: User ID or userPrincipalName
      name: user
      required: true
    description: Unblock a user.
    name: msgraph-user-unblock
  - arguments:
    - description: User ID or userPrincipalName to update properties for.
      name: user
      required: true
    - description: User fields to update (in JSON format).
      name: updated_fields
      required: true
    description: |-
      Updates the properties of a user object.
      Permissions: - User.ReadWrite (Delegated & Application)
    name: msgraph-user-update
    outputs:
    - contextPath: MSGraphUser.ID
      description: User's ID.
      type: Unknown
    - contextPath: MSGraphUser.DisplayName
      description: User's display name.
      type: Unknown
    - contextPath: MSGraphUser.GivenName
      description: User's given name.
      type: Unknown
    - contextPath: MSGraphUser.BusinessPhones
      description: User's business phone numbers.
      type: Unknown
    - contextPath: MSGraphUser.JobTitle
      description: User's job title.
      type: Unknown
    - contextPath: MSGraphUser.Mail
      description: User's mail address.
      type: Unknown
    - contextPath: MSGraphUser.MobilePhone
      description: User's mobile phone number.
      type: Unknown
    - contextPath: MSGraphUser.OfficeLocation
      description: User's office location.
      type: Unknown
    - contextPath: MSGraphUser.PreferredLanguage
      description: User's preferred language.
      type: Unknown
    - contextPath: MSGraphUser.Surname
      description: User's surname.
      type: Unknown
    - contextPath: MSGraphUser.UserPrincipalName
      description: User's principal name.
      type: Unknown
  - arguments:
    - description: User ID or userPrincipalName to delete.
      name: user
      required: true
    description: |-
      Deletes an existing user.
      Permissions: - Directory.AccessAsUser.All (Delegated) - User.ReadWrite.All (Application)
    execution: true
    name: msgraph-user-delete
  - arguments:
    - auto: PREDEFINED
      defaultValue: "true"
      description: true if the account is enabled; otherwise, false.
      name: account_enabled
      predefined:
      - "true"
      - "false"
    - description: The name to display in the address book.
      name: display_name
      required: true
    - description: Only needs to be specified when creating a new user account if
        you are using a federated domain for the user's userPrincipalName (UPN) property.
      name: on_premises_immutable_id
    - description: The mail alias for the user.
      name: mail_nickname
      required: true
    - description: The password profile for the user.
      name: password
      required: true
    - description: ' The user principal name, for example: foo@test.com. '
      name: user_principal_name
      required: true
    - description: ' Optional properties for the user, for example: "displayName=name,mobilePhone=phone-num" '
      name: other_properties
    description: |-
      Creates a new user.
      Permissions: - User.ReadWrite.All (Delegated & Application)
    name: msgraph-user-create
    outputs:
    - contextPath: MSGraphUser.ID
      description: User's ID.
      type: Unknown
    - contextPath: MSGraphUser.DisplayName
      description: User's display name.
      type: Unknown
    - contextPath: MSGraphUser.GivenName
      description: User's given name.
      type: Unknown
    - contextPath: MSGraphUser.BusinessPhones
      description: User's business phone numbers.
      type: Unknown
    - contextPath: MSGraphUser.JobTitle
      description: User's job title.
      type: Unknown
    - contextPath: MSGraphUser.Mail
      description: User's mail address.
      type: Unknown
    - contextPath: MSGraphUser.MobilePhone
      description: User's mobile phone number.
      type: Unknown
    - contextPath: MSGraphUser.OfficeLocation
      description: User's office location.
      type: Unknown
    - contextPath: MSGraphUser.PreferredLanguage
      description: User's preferred language.
      type: Unknown
    - contextPath: MSGraphUser.Surname
      description: User's surname.
      type: Unknown
    - contextPath: MSGraphUser.UserPrincipalName
      description: User's principal name.
      type: Unknown
  - arguments:
    - description: ' A CSV list of properties by which to filter the results, for
        example: "displayName,jobTitle,mobilePhone" '
      name: properties
    deprecated: true
    description: |-
      Deprecated. This command only returns a single page. Use the msgraph-user-list command instead, which gets newly created, updated, or deleted users without performing a full read of the entire user collection.
      Permissions: - User.Read (Delegated) - User.Read.All (Application)
    name: msgraph-user-get-delta
    outputs:
    - contextPath: MSGraphUser.ID
      description: User's ID.
      type: Unknown
    - contextPath: MSGraphUser.DisplayName
      description: User's display name.
      type: Unknown
    - contextPath: MSGraphUser.GivenName
      description: User's given name.
      type: Unknown
    - contextPath: MSGraphUser.BusinessPhones
      description: User's business phone numbers.
      type: Unknown
    - contextPath: MSGraphUser.JobTitle
      description: User's job title.
      type: Unknown
    - contextPath: MSGraphUser.Mail
      description: User's mail address.
      type: Unknown
    - contextPath: MSGraphUser.MobilePhone
      description: User's mobile phone.
      type: Unknown
    - contextPath: MSGraphUser.OfficeLocation
      description: User's office location.
      type: Unknown
    - contextPath: MSGraphUser.PreferredLanguage
      description: User's preferred language.
      type: Unknown
    - contextPath: MSGraphUser.Surname
      description: User's surname.
      type: Unknown
    - contextPath: MSGraphUser.UserPrincipalName
      description: User's principal name.
      type: Unknown
  - arguments:
    - description: User ID or userPrincipalName
      name: user
      required: true
    - description: ' A CSV list of properties by which to filter the results, for
        example: "displayName,jobTitle,mobilePhone" '
      name: properties
    description: |-
      Retrieves the properties and relationships of a user object. For more information, visit: https://docs.microsoft.com/en-us/graph/api/user-update?view=graph-rest-1.0).
      Permissions: - User.Read (Delegated) - User.Read.All (Application)
    name: msgraph-user-get
    outputs:
    - contextPath: MSGraphUser.ID
      description: User's ID.
      type: Unknown
    - contextPath: MSGraphUser.DisplayName
      description: User's display name.
      type: Unknown
    - contextPath: MSGraphUser.GivenName
      description: User's given name.
      type: Unknown
    - contextPath: MSGraphUser.BusinessPhones
      description: User's business phone numbers.
      type: Unknown
    - contextPath: MSGraphUser.JobTitle
      description: User's job title.
      type: Unknown
    - contextPath: MSGraphUser.Mail
      description: User's mail address.
      type: Unknown
    - contextPath: MSGraphUser.MobilePhone
      description: User's mobile phone number.
      type: Unknown
    - contextPath: MSGraphUser.OfficeLocation
      description: User's office location.
      type: Unknown
    - contextPath: MSGraphUser.PreferredLanguage
      description: User's preferred language.
      type: Unknown
    - contextPath: MSGraphUser.Surname
      description: User's surname.
      type: Unknown
    - contextPath: MSGraphUser.UserPrincipalName
      description: User's principal name.
      type: Unknown
  - arguments:
    - description: 'A CSV list of properties by which to filter the results, for example:
        "displayName,jobTitle,mobilePhone"'
      name: properties
    - description: The URL for the next page in the list.
      name: next_page
    description: |-
      Retrieves a list of user objects.
      Permissions: - User.ReadBasic.All (Delegated) - User.Read.All (Application)
    name: msgraph-user-list
    outputs:
    - contextPath: MSGraphUser.ID
      description: User's ID.
      type: Unknown
    - contextPath: MSGraphUser.DisplayName
      description: User's display name.
      type: Unknown
    - contextPath: MSGraphUser.GivenName
      description: User's given name.
      type: Unknown
    - contextPath: MSGraphUser.BusinessPhones
      description: User's business phone numbers.
      type: Unknown
    - contextPath: MSGraphUser.JobTitle
      description: User's job title.
      type: Unknown
    - contextPath: MSGraphUser.Mail
      description: User's mail address.
      type: Unknown
    - contextPath: MSGraphUser.MobilePhone
      description: User's mobile phone number.
      type: Unknown
    - contextPath: MSGraphUser.OfficeLocation
      description: User's office location.
      type: Unknown
    - contextPath: MSGraphUser.PreferredLanguage
      description: User's preferred language.
      type: Unknown
    - contextPath: MSGraphUser.Surname
      description: User's surname.
      type: Unknown
    - contextPath: MSGraphUser.UserPrincipalName
      description: User's principal name.
      type: Unknown
    - contextPath: MSGraphUser.NextPage
      description: A token to pass to the next list command to retrieve additional
        results.
      type: String
  - arguments:
    - description: The user for which to search direct reports.
      name: user
      required: true
    description: Retrieves the direct reports for a user. Direct reports are the people
      who have that user configured as their manager.
    name: msgraph-direct-reports
    outputs:
    - contextPath: MSGraphUserDirectReports.Manager
      description: The manager's user principal name (UPN).
      type: String
    - contextPath: MSGraphUserDirectReports.Reports.@Odata.Type
      description: A string value that can be used to classify user types in your
        directory, such as "Member" and "Guest".
      type: String
    - contextPath: MSGraphUserDirectReports.Reports.DisplayName
      description: The name displayed in the address book for the user. This is usually
        the combination of the user's first name, middle initial and last name.
      type: String
    - contextPath: MSGraphUserDirectReports.Reports.GivenName
      description: The given name (first name) of the user.
      type: String
    - contextPath: MSGraphUserDirectReports.Reports.ID
      description: The user ID in Microsoft Graph User.
      type: String
    - contextPath: MSGraphUserDirectReports.Reports.JobTitle
      description: The user's job title.
      type: Unknown
    - contextPath: MSGraphUserDirectReports.Reports.Mail
      description: The email address of the user.
      type: Unknown
    - contextPath: MSGraphUserDirectReports.Reports.MobilePhone
      description: The primary cellular telephone number for the user.
      type: Unknown
    - contextPath: MSGraphUserDirectReports.Reports.OfficeLocation
      description: The office location in the user's place of business.
      type: Unknown
    - contextPath: MSGraphUserDirectReports.Reports.PreferredLanguage
      description: 'The preferred language for the user. Should follow ISO 639-1 Code;
        for example: en-US.'
      type: Unknown
    - contextPath: MSGraphUserDirectReports.Reports.Surname
      description: The user's surname (family name or last name).
      type: String
    - contextPath: MSGraphUserDirectReports.Reports.UserPrincipalName
      description: The user principal name (UPN) of the user. The UPN is an Internet-style
        login name for the user based on the Internet standard RFC 822. By convention,
        this should map to the user's email name. The general format is alias@domain,
        where domain must be present in the tenant’s collection of verified domains.
        This property is required when a user is created. The verified domains for
        the tenant can be accessed from the verifiedDomains property of organization.
      type: String
  dockerimage: demisto/crypto:1.0.0.7634
  runonce: false
  script: |2



    from typing import Dict

    # disable insecure warnings

    requests.packages.urllib3.disable_warnings()

    ''' CONSTANTS '''
    BLOCK_ACCOUNT_JSON = '{"accountEnabled": false}'
    UNBLOCK_ACCOUNT_JSON = '{"accountEnabled": true}'
    NO_OUTPUTS: dict = {}
    APP_NAME = 'ms-graph-user'


    def camel_case_to_readable(text):
        """
        'camelCase' -> 'Camel Case'
        """
        if text == 'id':
            return 'ID'
        return ''.join(' ' + char if char.isupper() else char.strip() for char in text).strip().title()


    def parse_outputs(users_data):
        """
        Parse user data as received from Microsoft Graph API into Demisto's conventions
        """
        if isinstance(users_data, list):
            users_readable, users_outputs = [], []
            for user_data in users_data:
                user_readable = {camel_case_to_readable(k): v for k, v in user_data.items() if k != '@removed'}
                if '@removed' in user_data:
                    user_readable['Status'] = 'deleted'
                users_readable.append(user_readable)
                users_outputs.append({k.replace(' ', ''): v for k, v in user_readable.copy().items()})

            return users_readable, users_outputs

        else:
            user_readable = {camel_case_to_readable(k): v for k, v in users_data.items() if k != '@removed'}
            if '@removed' in users_data:
                user_readable['Status'] = 'deleted'
            user_outputs = {k.replace(' ', ''): v for k, v in user_readable.copy().items()}

            return user_readable, user_outputs


    class MsGraphClient:
        """
        Microsoft Graph Mail Client enables authorized access to a user's Office 365 mail data in a personal account.
        """

        def __init__(self, tenant_id, auth_id, enc_key, app_name, base_url, verify, proxy, self_deployed):
            self.ms_client = MicrosoftClient(tenant_id=tenant_id, auth_id=auth_id, enc_key=enc_key, app_name=app_name,
                                             base_url=base_url, verify=verify, proxy=proxy, self_deployed=self_deployed)

        #  If successful, this method returns 204 No Content response code.
        #  Using resp_type=text to avoid parsing error.
        def terminate_user_session(self, user):
            self.ms_client.http_request(
                method='PATCH',
                url_suffix=f'users/{user}',
                data=BLOCK_ACCOUNT_JSON,
                resp_type="text"
            )

        #  Using resp_type=text to avoid parsing error.
        def unblock_user(self, user):
            self.ms_client.http_request(
                method='PATCH',
                url_suffix=f'users/{user}',
                data=UNBLOCK_ACCOUNT_JSON,
                resp_type="text"
            )

        #  If successful, this method returns 204 No Content response code.
        #  Using resp_type=text to avoid parsing error.
        def delete_user(self, user):
            self.ms_client.http_request(
                method='DELETE',
                url_suffix=f'users/{user}',
                resp_type="text"
            )

        def create_user(self, properties):
            self.ms_client.http_request(
                method='POST',
                url_suffix='users',
                json_data=properties)

        #  If successful, this method returns 204 No Content response code.
        #  Using resp_type=text to avoid parsing error.
        def update_user(self, user, updated_fields):
            body = {}
            for key_value in updated_fields.split(','):
                field, value = key_value.split('=', 2)
                body[field] = value
            self.ms_client.http_request(
                method='PATCH',
                url_suffix=f'users/{user}',
                json_data=body,
                resp_type="text")

        def get_delta(self, properties):
            users = self.ms_client.http_request(
                method='GET',
                url_suffix='users/delta',
                params={'$select': properties})
            return users.get('value', '')

        def get_user(self, user, properties):
            user_data = self.ms_client.http_request(
                method='GET',
                url_suffix=f'users/{user}',
                params={'$select': properties})
            user_data.pop('@odata.context', None)
            return user_data

        def list_users(self, properties, page_url):
            if page_url:
                response = self.ms_client.http_request(method='GET', full_url=page_url)
            else:
                response = self.ms_client.http_request(method='GET', url_suffix='users', params={'$select': properties})
            next_page_url = response.get('@odata.nextLink')
            users = response.get('value')
            return users, next_page_url

        def get_direct_reports(self, user):
            res = self.ms_client.http_request(
                method='GET',
                url_suffix=f'users/{user}/directReports')

            res.pop('@odata.context', None)
            return res.get('value', [])


    def test_function(client, _):
        """
           Performs basic GET request to check if the API is reachable and authentication is successful.
           Returns ok if successful.
           """
        client.ms_client.http_request(method='GET', url_suffix='users/')
        return 'ok', None, None


    def terminate_user_session_command(client: MsGraphClient, args: Dict):
        user = args.get('user')
        client.terminate_user_session(user)
        human_readable = f'user: "{user}" session has been terminated successfully'
        return human_readable, None, None


    def unblock_user_command(client: MsGraphClient, args: Dict):
        user = args.get('user')
        client.unblock_user(user)
        human_readable = f'"{user}" unblocked. It might take several minutes for the changes to take affect across all ' \
                         f'applications. '
        return human_readable, None, None


    def delete_user_command(client: MsGraphClient, args: Dict):
        user = args.get('user')
        client.delete_user(user)
        human_readable = f'user: "{user}" was deleted successfully'
        return human_readable, None, None


    def create_user_command(client: MsGraphClient, args: Dict):
        required_properties = {
            'accountEnabled': args.get('account_enabled'),
            'displayName': args.get('display_name'),
            'onPremisesImmutableId': args.get('on_premises_immutable_id'),
            'mailNickname': args.get('mail_nickname'),
            'passwordProfile': {
                "forceChangePasswordNextSignIn": 'true',
                "password": args.get('password')
            },
            'userPrincipalName': args.get('user_principal_name')
        }
        other_properties = {}
        if args.get('other_properties'):
            for key_value in args.get('other_properties', '').split(','):
                key, value = key_value.split('=', 2)
                other_properties[key] = value
            required_properties.update(other_properties)

        # create the user
        client.create_user(required_properties)

        # display the new user and it's properties
        user = required_properties.get('userPrincipalName')
        user_data = client.get_user(user, '*')
        user_readable, user_outputs = parse_outputs(user_data)
        human_readable = tableToMarkdown(name=f"{user} was created successfully:", t=user_readable, removeNull=True)
        outputs = {'MSGraphUser(val.ID == obj.ID)': user_outputs}
        return human_readable, outputs, user_data


    def update_user_command(client: MsGraphClient, args: Dict):
        user = args.get('user')
        updated_fields = args.get('updated_fields')

        client.update_user(user, updated_fields)
        return get_user_command(client, args)


    def get_delta_command(client: MsGraphClient, args: Dict):
        properties = args.get('properties', '') + ',userPrincipalName'
        users_data = client.get_delta(properties)
        headers = list(set([camel_case_to_readable(p) for p in argToList(properties)] + ['ID', 'User Principal Name']))

        users_readable, users_outputs = parse_outputs(users_data)
        human_readable = tableToMarkdown(name='All Graph Users', headers=headers, t=users_readable, removeNull=True)
        outputs = {'MSGraphUser(val.ID == obj.ID)': users_outputs}
        return human_readable, outputs, users_data


    def get_user_command(client: MsGraphClient, args: Dict):
        user = args.get('user')
        properties = args.get('properties', '*')
        user_data = client.get_user(user, properties)

        user_readable, user_outputs = parse_outputs(user_data)
        human_readable = tableToMarkdown(name=f"{user} data", t=user_readable, removeNull=True)
        outputs = {'MSGraphUser(val.ID == obj.ID)': user_outputs}
        return human_readable, outputs, user_data


    def list_users_command(client: MsGraphClient, args: Dict):
        properties = args.get('properties', 'id,displayName,jobTitle,mobilePhone,mail')
        next_page = args.get('next_page', None)
        users_data, result_next_page = client.list_users(properties, next_page)
        users_readable, users_outputs = parse_outputs(users_data)
        metadata = None
        outputs = {'MSGraphUser(val.ID == obj.ID)': users_outputs}

        if result_next_page:
            metadata = "To get further results, enter this to the next_page parameter:\n" + str(result_next_page)

            # .NextPage.indexOf(\'http\')>=0 : will make sure the NextPage token will always be updated because it's a url
            outputs['MSGraphUser(val.NextPage.indexOf(\'http\')>=0)'] = {'NextPage': result_next_page}

        human_readable = tableToMarkdown(name='All Graph Users', t=users_readable, removeNull=True, metadata=metadata)

        return human_readable, outputs, users_data


    def get_direct_reports_command(client: MsGraphClient, args: Dict):
        user = args.get('user')

        raw_reports = client.get_direct_reports(user)

        reports_readable, reports = parse_outputs(raw_reports)
        human_readable = tableToMarkdown(name=f"{user} - direct reports", t=reports_readable, removeNull=True)
        outputs = {
            'MSGraphUserDirectReports(val.Manager == obj.Manager)': {
                'Manager': user,
                'Reports': reports
            }
        }

        return human_readable, outputs, raw_reports


    def main():
        params: dict = demisto.params()
        url = params.get('host', '').rstrip('/') + '/v1.0/'
        tenant = params.get('tenant_id')
        auth_and_token_url = params.get('auth_id', '')
        enc_key = params.get('enc_key')
        verify = not params.get('insecure', False)
        self_deployed: bool = params.get('self_deployed', False)
        proxy = params.get('proxy', False)

        commands = {
            'test-module': test_function,
            'msgraph-user-unblock': unblock_user_command,
            'msgraph-user-terminate-session': terminate_user_session_command,
            'msgraph-user-update': update_user_command,
            'msgraph-user-delete': delete_user_command,
            'msgraph-user-create': create_user_command,
            'msgraph-user-get-delta': get_delta_command,
            'msgraph-user-get': get_user_command,
            'msgraph-user-list': list_users_command,
            'msgraph-direct-reports': get_direct_reports_command
        }
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            client: MsGraphClient = MsGraphClient(tenant_id=tenant, auth_id=auth_and_token_url, enc_key=enc_key,
                                                  app_name=APP_NAME, base_url=url, verify=verify, proxy=proxy,
                                                  self_deployed=self_deployed)

            human_readable, entry_context, raw_response = commands[command](client, demisto.args())  # type: ignore
            return_outputs(readable_output=human_readable, outputs=entry_context, raw_response=raw_response)

        except Exception as err:
            return_error(str(err))



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.import traceback




    import requests
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Tuple

    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line


    class MicrosoftClient(BaseClient):

        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str = '',
                     token_retrieval_url: str = 'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = 'https://graph.microsoft.com/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str = '',
                     verify: bool = True,
                     self_deployed: bool = False,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]

            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id)
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope
                self.redirect_uri = redirect_uri

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify

        def http_request(self, *args, resp_type='json', headers=None, return_empty_response=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            if headers:
                default_headers.update(headers)

            response = super()._http_request(   # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))

            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self):
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            refresh_token = integration_context.get('current_refresh_token', '')
            valid_until = integration_context.get('valid_until')
            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            auth_type = self.auth_type
            if auth_type == OPROXY_AUTH_TYPE:
                access_token, expires_in, refresh_token = self._oproxy_authorize()
            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            integration_context = {
                'access_token': access_token,
                'current_refresh_token': refresh_token,
                'valid_until': time_now + expires_in,
            }

            demisto.setIntegrationContext(integration_context)
            return access_token

        def _oproxy_authorize(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key)
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self, refresh_token: str = ''):
            if self.grant_type == AUTHORIZATION_CODE:
                return self._get_self_deployed_token_auth_code(refresh_token)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                return self._get_self_deployed_token_client_credentials()

        def _get_self_deployed_token_client_credentials(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.scope:
                data['scope'] = self.scope
            if self.resource:
                data['resource'] = self.resource

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(self, refresh_token: str = '') -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'resource': self.resource,
                'redirect_uri': self.redirect_uri
            }
            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            # refresh_token = response_json.get('refresh_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
                brand_name = calling_context.get('IntegrationBrand', '')
                instance_name = calling_context.get('IntegrationInstance', '')
                headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
                headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
                if hasattr(demisto, 'demistoVersion'):
                    demisto_version = demisto.demistoVersion()
                    headers['X-Content-Server-Version'] = '{}-{}'.format(demisto_version.get('version'),
                                                                         demisto_version.get("buildNumber"))
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers



    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
