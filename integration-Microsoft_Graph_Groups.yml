category: IT Services
commonfields:
  id: Microsoft Graph Groups
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Server URL
  name: url
  required: true
  type: 0
- defaultvalue: ""
  display: ID (received from the admin consent - see Detailed Instructions (?)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  name: tenant_id
  required: true
  type: 4
- defaultvalue: ""
  display: Key (received from the admin consent - see Detailed Instructions (?)
  name: enc_key
  required: true
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Use a self-deployed Azure Application
  name: self_deployed
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Microsoft Graph Groups enables you to create and manage different types
  of groups and group functionality according to your requirements.
detaileddescription: |
  To allow access to Microsoft Graph Groups, an administrator has to approve the Demisto app using an admin consent flow, by clicking on the following [link](https://oproxy.demisto.ninja/ms-graph-groups).
  After authorizing the Demisto app, you will get an ID, Token, and Key, which needs to be added to the integration instance configuration's corresponding fields.

  Required Permissions in the MS Graph Groups App:
  Directory.ReadWrite.All - Delegated
  Directory.ReadWrite.All - Application
  Group.ReadWrite.All - Application
display: Microsoft Graph Groups
image: data:image/png;base64,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
name: Microsoft Graph Groups
script:
  commands:
  - arguments:
    - description: Sorts groups in an organization by the field values. For example,
        displayName.
      name: order_by
    - description: The URL to the next results page.
      name: next_link
    - defaultValue: "100"
      description: Sets the page size of the results.
      name: top
    - description: Filters group results. For example, startswith(displayName,'J'),
        groupTypes/any(c:c+eq+'Unified').
      name: filter
    description: Provides a list of groups.
    name: msgraph-groups-list-groups
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business
        impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, which is unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName,
        which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: Indicates the last time at which the group was synced with the
        on-premises directory. The Timestamp type represents date and time information
        using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019
        is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether this group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox.
        For example: ["SMTP: support@demisto.com", "smtp: support@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: Timestamp of when the group was last renewed, which represents
        the time and date information using ISO 8601 format. Always in UTC time. For
        example, midnight UTC on Jan 1, 2019 is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Can be: "Private",
        "Public", or "Hiddenmembership". Blank values are treated as public.'
      type: String
    - contextPath: MSGraphGroup.NextLink
      description: The URL of the next results page.
      type: String
  - arguments:
    - description: The ID of the group.
      name: group_id
      required: true
    description: Returns details of a group.
    name: msgraph-groups-get-group
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business
        impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName,
        which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: Indicates the last time at which the group was synced with the
        on-premises directory.The Timestamp type represents date and time information
        using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019
        is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether the group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox.
        For example: ["SMTP: support@demisto.com", "smtp: support@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: The timestamp of when the group was last renewed. This cannot be
        modified directly and is only updated via the renew service action. The Timestamp
        type represents date and time information using ISO 8601 format in UTC time.
        For example, midnight UTC on Jan 1, 2019 is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Possible values
        are: Private, Public, or Hiddenmembership. Blank values are treated as public.'
      type: String
  - arguments:
    - description: The display name of the group.
      name: display_name
      required: true
    - auto: PREDEFINED
      description: Set to true for mail-enabled groups. False for groups without an
        email.
      name: mail_enabled
      predefined:
      - "false"
      - "true"
    - description: The mail alias for the group.
      name: mail_nickname
      required: true
    - auto: PREDEFINED
      description: Set to true for security groups. False for non security groups
        (regular groups).
      name: security_enabled
      predefined:
      - "false"
      - "true"
      required: true
    description: Create a group.
    name: msgraph-groups-create-group
    outputs:
    - contextPath: MSGraphGroups.Classification
      description: A classification for the group (such as low, medium or high business
        impact).
      type: String
    - contextPath: MSGraphGroups.CreatedDateTime
      description: The timestamp when the group was created.
      type: String
    - contextPath: MSGraphGroups.DeletedDateTime
      description: The timestamp when the group was deleted.
      type: String
    - contextPath: MSGraphGroups.Description
      description: An optional description for the group.
      type: String
    - contextPath: MSGraphGroups.GroupTypes
      description: |-
        Specifies the group type and its membership.
        If the group collection contains a Unified value, the group is an Office 365 group; otherwise it's a security group.
        If the group collection includes DynamicMembership, the group has dynamic membership; otherwise, membership is static.
      type: String
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.IsAssignableToRole
      description: Whether the group is assigned to a specific role.
      type: String
    - contextPath: MSGraphGroup.Mail
      description: The SMTP address for the group. For example, "serviceadmins@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroup.MailEnabled
      description: Specifies whether the group is mail-enabled.
      type: Boolean
    - contextPath: MSGraphGroup.MailNickname
      description: The mail alias for the group, unique in the organization.
      type: String
    - contextPath: MSGraphGroup.OnPremisesDomainName
      description: Contains the on-premises domain FQDN. Also called dnsDomainName,
        which is synchronized from the on-premises directory.
      type: String
    - contextPath: MSGraphGroup.OnPremisesLastSyncDateTime
      description: Indicates the last time at which the group was synced with the
        on-premises directory.The Timestamp type represents date and time information
        using ISO 8601 format in UTC time. For example, midnight UTC on Jan 1, 2019
        is '2019-01-01T00:00:00Z'.
      type: String
    - contextPath: MSGraphGroup.OnPremisesSyncEnabled
      description: |
        Whether this group is synced from an on-premises directory (true). This group was originally synced from an on-premises directory but is no longer synced (false). Null if this object has never been synced from an on-premises directory (default).
      type: String
    - contextPath: MSGraphGroup.ProxyAddresses
      description: 'Email addresses for the group that directs to the same group mailbox.
        For example, ["SMTP: support@demisto.com", "smtp: support@demisto.com"].'
      type: String
    - contextPath: MSGraphGroup.RenewedDateTime
      description: 'Timestamp of when the group was last renewed. This cannot be modified
        directly and is only updated via the renew service action. The Timestamp type
        represents date and time information using ISO 8601 format and is always in
        UTC time. For example, midnight UTC on Jan 1, 2014 would look like this: ''2014-01-01T00:00:00Z''.'
      type: String
    - contextPath: MSGraphGroup.SecurityEnabled
      description: Specifies whether the group is a security group.
      type: Boolean
    - contextPath: MSGraphGroup.Visibility
      description: 'Specifies the visibility of an Office 365 group. Possible values
        are: Private, Public, or Hiddenmembership; blank values are treated as public.'
      type: String
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    description: Deletes a group.
    name: msgraph-groups-delete-group
    outputs:
    - contextPath: MSGraphGroups.ID
      description: The unique identifier for the group.
      type: String
    - contextPath: MSGraphGroup.Deleted
      description: Specifies whether the group was deleted.
      type: Boolean
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    - description: The URL for the next results page.
      name: next_link
    - defaultValue: "100"
      description: Sets the page size of results.
      name: top
    - description: Filters members results. For example, startswith(displayName,'user').
      name: filter
    description: Lists group members.
    name: msgraph-groups-list-members
    outputs:
    - contextPath: MSGraphGroups.Members.BussinessPhones
      description: The telephone numbers for the user.
      type: String
    - contextPath: MSGraphGroups.Members.GivenName
      description: The given name (first name) of the user.
      type: String
    - contextPath: MSGraphGroups.Members.MobilePhone
      description: The primary mobile telephone number for the user.
      type: String
    - contextPath: MSGraphGroups.Members.DisplayName
      description: |-
        The name displayed in the address book for the user.
        Usually the combination of the user's first name, middle initial and last name.
      type: String
    - contextPath: MSGraphGroups.Members.UserPrincipalName
      description: |-
        The user principal name (UPN) of the user.
        The UPN is an Internet-style login name for the user based on the Internet standard RFC 822.
        By convention, this should map to the user's email name.
        The general format is alias@domain, where the domain must be present in the tenant’s collection of verified domains.
      type: Unknown
    - contextPath: MSGraphGroups.Members.OfficeLocation
      description: The office location in the user's place of business.
      type: String
    - contextPath: MSGraphGroups.Members.Mail
      description: The SMTP address for the user. For example, "jeff@contoso.onmicrosoft.com".
      type: String
    - contextPath: MSGraphGroups.Members.PreferredLanguage
      description: The preferred language for the user. Should follow ISO 639-1 Code.
        For example, "en-US".
      type: String
    - contextPath: MSGraphGroups.Members.Surname
      description: The user's surname (family name or last name).
      type: String
    - contextPath: MSGraphGroups.Members.JobTitle
      description: The user’s job title.
      type: String
    - contextPath: MSGraphGroups.Members.ID
      description: The unique identifier for the user.
      type: String
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    - description: The user ID.
      name: user_id
      required: true
    description: Add a member to a group.
    name: msgraph-groups-add-member
  - arguments:
    - description: The group ID.
      name: group_id
      required: true
    - description: The user ID.
      name: user_id
      required: true
    description: Removes a member from a group.
    name: msgraph-groups-remove-member
  dockerimage: demisto/crypto:1.0.0.7634
  runonce: false
  script: |
    from typing import Dict, Tuple, Optional, Any

    import urllib3


    # Disable insecure warnings

    urllib3.disable_warnings()

    INTEGRATION_CONTEXT_NAME = 'MSGraphGroups'
    NO_OUTPUTS: dict = {}
    APP_NAME = 'ms-graph-groups'


    def camel_case_to_readable(text: str) -> str:
        """'camelCase' -> 'Camel Case'

        Args:
            text: the text to transform

        Returns:
            A Camel Cased string.
        """
        if text == 'id':
            return 'ID'
        return ''.join(' ' + char if char.isupper() else char.strip() for char in text).strip().title()


    def parse_outputs(groups_data: Dict[str, str]) -> Tuple[dict, dict]:
        """Parse group data as received from Microsoft Graph API into Demisto's conventions

        Args:
            groups_data: a dictionary containing the group data

        Returns:
            A Camel Cased dictionary with the relevant fields.
            groups_readable: for the human readable
            groups_outputs: for the entry context
        """
        # Unnecessary fields, dropping as to not load the incident context.
        fields_to_drop = ['@odata.context', '@odata.nextLink', '@odata.deltaLink', '@odata.type', '@removed',
                          'resourceProvisioningOptions', 'securityIdentifier', 'onPremisesSecurityIdentifier',
                          'onPremisesNetBiosName', 'onPremisesProvisioningErrors', 'onPremisesSamAccountName',
                          'resourceBehaviorOptions', 'creationOptions', 'preferredDataLocation']
        if isinstance(groups_data, list):
            groups_readable, groups_outputs = [], []
            for group_data in groups_data:
                group_readable = {camel_case_to_readable(i): j for i, j in group_data.items() if i not in fields_to_drop}
                if '@removed' in group_data:
                    group_readable['Status'] = 'deleted'
                groups_readable.append(group_readable)
                groups_outputs.append({k.replace(' ', ''): v for k, v in group_readable.copy().items()})

            return groups_readable, groups_outputs

        group_readable = {camel_case_to_readable(i): j for i, j in groups_data.items() if i not in fields_to_drop}
        if '@removed' in groups_data:
            group_readable['Status'] = 'deleted'
        group_outputs = {k.replace(' ', ''): v for k, v in group_readable.copy().items()}

        return group_readable, group_outputs


    class MsGraphClient:
        """
          Microsoft Graph Mail Client enables authorized access to a user's Office 365 mail data in a personal account.
          """

        def __init__(self, tenant_id, auth_id, enc_key, app_name, base_url, verify, proxy, self_deployed):
            self.ms_client = MicrosoftClient(tenant_id=tenant_id, auth_id=auth_id, enc_key=enc_key, app_name=app_name,
                                             base_url=base_url, verify=verify, proxy=proxy, self_deployed=self_deployed)

        def test_function(self):
            """Performs basic GET request to check if the API is reachable and authentication is successful.

            Returns:
                ok if successful.
            """
            self.ms_client.http_request(method='GET', url_suffix='groups', params={'$orderby': 'displayName'})
            demisto.results('ok')

        def list_groups(self, order_by: str = None, next_link: str = None, top: int = None, filter_: str = None):
            """Returns all groups by sending a GET request.

            Args:
                order_by: the group fields to order by the response.
                next_link: the link for the next page of results, if exists. see Microsoft documentation for more details.
                    docs.microsoft.com/en-us/graph/api/group-list?view=graph-rest-1.0
                top: sets the page size of results.
                filter_: filters results.
            Returns:
                Response from API.
            """
            if next_link:  # pagination
                return self.ms_client.http_request(method='GET', full_url=next_link)
            # default value = 100
            params = {'$top': top}
            if order_by:
                params['$orderby'] = order_by  # type: ignore
            if filter_:
                params['$filter'] = filter_  # type: ignore
            return self.ms_client.http_request(
                method='GET',
                url_suffix='groups',
                params=params)

        def get_group(self, group_id: str) -> Dict:
            """Returns a single group by sending a GET request.

            Args:
                group_id: the group id.

            Returns:
                Response from API.
            """
            group = self.ms_client.http_request(method='GET', url_suffix=f'groups/{group_id}')
            return group

        def create_group(self, properties: Dict[str, Optional[Any]]) -> Dict:
            """Create a single group by sending a POST request.

            Args:
                properties: the group properties.

            Returns:
                Response from API.
            """
            group = self.ms_client.http_request(method='POST', url_suffix='groups', json_data=properties)
            return group

        def delete_group(self, group_id: str):
            """Delete a single group by sending a DELETE request.

            Args:
                group_id: the group id to delete.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            #  Using resp_type="text" to avoid parsing error in the calling method.
            self.ms_client.http_request(method='DELETE ', url_suffix=f'groups/{group_id}', resp_type="text")

        def list_members(self, group_id: str, next_link: str = None, top: int = None, filter_: str = None):
            """List all group members by sending a GET request.

            Args:
                group_id: the group id to list its members.
                next_link: the link for the next page of results, if exists. see Microsoft documentation for more details.
                    docs.microsoft.com/en-us/graph/api/group-list-members?view=graph-rest-1.0
                top: sets the page size of results.
                filter_: filters results.
            Returns:
                Response from API.
            """
            if next_link:  # pagination
                return self.ms_client.http_request(method='GET', full_url=next_link)
            params = {'$top': top}
            if filter_:
                params['$filter'] = filter_  # type: ignore

            return self.ms_client.http_request(
                method='GET',
                url_suffix=f'groups/{group_id}/members',
                params=params)

        def add_member(self, group_id: str, properties: Dict[str, str]):
            """Add a single member to a group by sending a POST request.
            Args:
                group_id: the group id to add the member to.
                properties: the member properties.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            #  Using resp_type="text" to avoid parsing error in the calling method.
            self.ms_client.http_request(
                method='POST',
                url_suffix=f'groups/{group_id}/members/$ref',
                json_data=properties,
                resp_type="text")

        def remove_member(self, group_id: str, user_id: str):
            """Remove a single member to a group by sending a DELETE request.
            Args:
                group_id: the group id to add the member to.
                user_id: the user id to remove.
            """
            #  If successful, this method returns 204 No Content response code.
            #  It does not return anything in the response body.
            #  Using resp_type="text" to avoid parsing error in the calling method.
            self.ms_client.http_request(
                method='DELETE',
                url_suffix=f'groups/{group_id}/members/{user_id}/$ref', resp_type="text")


    def test_function_command(client: MsGraphClient, args: Dict):
        """Performs a basic GET request to check if the API is reachable and authentication is successful.

        Args:
            client: Client object with request
            args: Usually demisto.args()
        """
        client.test_function()


    def list_groups_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Lists all groups and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        order_by = args.get('order_by')
        next_link = args.get('next_link')
        top = args.get('top')
        filter_ = args.get('filter')
        groups = client.list_groups(order_by, next_link, top, filter_)

        groups_readable, groups_outputs = parse_outputs(groups['value'])

        next_link_response = ''
        if '@odata.nextLink' in groups:
            next_link_response = groups['@odata.nextLink']

        if next_link_response:
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID).NextLink': next_link_response,
                             f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': groups_outputs}
            title = 'Groups (Note that there are more results. Please use the next_link argument to see them.):'
        else:
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': groups_outputs}
            title = 'Groups:'

        human_readable = tableToMarkdown(name=title, t=groups_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail'],
                                         removeNull=True)

        return human_readable, entry_context, groups


    def get_group_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Get a group by group id and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        group = client.get_group(group_id)

        group_readable, group_outputs = parse_outputs(group)
        human_readable = tableToMarkdown(name="Groups:", t=group_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail',
                                                  'Security Enabled', 'Visibility'],
                                         removeNull=True)
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(obj.ID === {group_id})': group_outputs}
        return human_readable, entry_context, group


    def create_group_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Create a group and return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        required_properties = {
            'displayName': str(args.get('display_name')),
            'mailNickname': str(args.get('mail_nickname')),
            'mailEnabled': args.get('mail_enabled') == 'true',
            'securityEnabled': args.get('security_enabled')
        }

        # create the group
        group = client.create_group(required_properties)

        # display the new group and it's properties
        group_readable, group_outputs = parse_outputs(group)
        human_readable = tableToMarkdown(name=f"{required_properties['displayName']} was created successfully:",
                                         t=group_readable,
                                         headers=['ID', 'Display Name', 'Description', 'Created Date Time', 'Mail',
                                                  'Security Enabled', 'Mail Enabled'],
                                         removeNull=True)
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_outputs}
        return human_readable, entry_context, group


    def delete_group_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Delete a group by group id and return outputs in Demisto's format

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        client.delete_group(group_id)

        # get the group data from the context
        group_data = demisto.dt(demisto.context(), f'{INTEGRATION_CONTEXT_NAME}(val.ID === "{group_id}")')
        if isinstance(group_data, list):
            group_data = group_data[0]

        # add a field that indicates that the group was deleted
        group_data['Deleted'] = True  # add a field with the members to the group
        entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}

        human_readable = f'Group: "{group_id}" was deleted successfully.'
        return human_readable, entry_context, NO_OUTPUTS


    def list_members_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """List a group members by group id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        next_link = args.get('next_link')
        top = args.get('top')
        filter_ = args.get('filter')
        members = client.list_members(group_id, next_link, top, filter_)

        if not members['value']:
            human_readable = f'The group {group_id} has no members.'
            return human_readable, NO_OUTPUTS, NO_OUTPUTS

        members_readable, members_outputs = parse_outputs(members['value'])

        # get the group data from the context
        group_data = demisto.dt(demisto.context(), f'{INTEGRATION_CONTEXT_NAME}(val.ID === "{group_id}")')
        if isinstance(group_data, list):
            group_data = group_data[0]

        if '@odata.nextLink' in members:
            next_link_response = members['@odata.nextLink']
            group_data['Members'] = members_outputs  # add a field with the members to the group
            group_data['Members']['NextLink'] = next_link_response
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}
            title = f'Group {group_id} members ' \
                    f'(Note that there are more results. Please use the next_link argument to see them.):'
        else:
            group_data['Members'] = members_outputs  # add a field with the members to the group
            entry_context = {f'{INTEGRATION_CONTEXT_NAME}(val.ID === obj.ID)': group_data}
            title = f'Group {group_id} members:'

        human_readable = tableToMarkdown(name=title, t=members_readable,
                                         headers=['ID', 'Display Name', 'Job Title', 'Mail'],
                                         removeNull=True)

        return human_readable, entry_context, members


    def add_member_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Add a member to a group by group id and user id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        user_id = str(args.get('user_id'))
        required_properties = {
            "@odata.id": f'https://graph.microsoft.com/v1.0/users/{user_id}'}
        client.add_member(group_id, required_properties)

        human_readable = f'User {user_id} was added to the Group {group_id} successfully.'
        return human_readable, NO_OUTPUTS, NO_OUTPUTS


    def remove_member_command(client: MsGraphClient, args: Dict) -> Tuple[str, Dict, Dict]:
        """Remove a member from a group by group id and user id. return outputs in Demisto's format.

        Args:
            client: Client object with request
            args: Usually demisto.args()

        Returns:
            Outputs.
        """
        group_id = str(args.get('group_id'))
        user_id = str(args.get('user_id'))
        client.remove_member(group_id, user_id)

        human_readable = f'User {user_id} was removed from the Group "{group_id}" successfully.'
        return human_readable, NO_OUTPUTS, NO_OUTPUTS


    def main():
        """
        PARSE AND VALIDATE INTEGRATION PARAMS
        """
        params: dict = demisto.params()
        base_url = params.get('url', '').rstrip('/') + '/v1.0/'
        tenant = params.get('tenant_id')
        auth_and_token_url = params.get('auth_id')
        enc_key = params.get('enc_key')
        verify = not params.get('insecure', False)
        proxy = params.get('proxy')
        self_deployed: bool = params.get('self_deployed', False)

        commands = {
            'test-module': test_function_command,
            'msgraph-groups-list-groups': list_groups_command,
            'msgraph-groups-get-group': get_group_command,
            'msgraph-groups-create-group': create_group_command,
            'msgraph-groups-delete-group': delete_group_command,
            'msgraph-groups-list-members': list_members_command,
            'msgraph-groups-add-member': add_member_command,
            'msgraph-groups-remove-member': remove_member_command
        }
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            client = MsGraphClient(base_url=base_url, tenant_id=tenant, auth_id=auth_and_token_url, enc_key=enc_key,
                                   app_name=APP_NAME, verify=verify, proxy=proxy, self_deployed=self_deployed)
            # Run the command
            human_readable, entry_context, raw_response = commands[command](client, demisto.args())
            # create a war room entry
            return_outputs(readable_output=human_readable, outputs=entry_context, raw_response=raw_response)

        except Exception as err:
            return_error(str(err))



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.import traceback




    import requests
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Tuple

    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line


    class MicrosoftClient(BaseClient):

        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str = '',
                     token_retrieval_url: str = 'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = 'https://graph.microsoft.com/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str = '',
                     verify: bool = True,
                     self_deployed: bool = False,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]

            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id)
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope
                self.redirect_uri = redirect_uri

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify

        def http_request(self, *args, resp_type='json', headers=None, return_empty_response=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            if headers:
                default_headers.update(headers)

            response = super()._http_request(   # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))

            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self):
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            refresh_token = integration_context.get('current_refresh_token', '')
            valid_until = integration_context.get('valid_until')
            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            auth_type = self.auth_type
            if auth_type == OPROXY_AUTH_TYPE:
                access_token, expires_in, refresh_token = self._oproxy_authorize()
            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            integration_context = {
                'access_token': access_token,
                'current_refresh_token': refresh_token,
                'valid_until': time_now + expires_in,
            }

            demisto.setIntegrationContext(integration_context)
            return access_token

        def _oproxy_authorize(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key)
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self, refresh_token: str = ''):
            if self.grant_type == AUTHORIZATION_CODE:
                return self._get_self_deployed_token_auth_code(refresh_token)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                return self._get_self_deployed_token_client_credentials()

        def _get_self_deployed_token_client_credentials(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.scope:
                data['scope'] = self.scope
            if self.resource:
                data['resource'] = self.resource

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(self, refresh_token: str = '') -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'resource': self.resource,
                'redirect_uri': self.redirect_uri
            }
            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            # refresh_token = response_json.get('refresh_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
                brand_name = calling_context.get('IntegrationBrand', '')
                instance_name = calling_context.get('IntegrationInstance', '')
                headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
                headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
                if hasattr(demisto, 'demistoVersion'):
                    demisto_version = demisto.demistoVersion()
                    headers['X-Content-Server-Version'] = '{}-{}'.format(demisto_version.get('version'),
                                                                         demisto_version.get("buildNumber"))
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers



    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
