category: Authentication
commonfields:
  id: Microsoft_Graph_Files
  version: -1
configuration:
- defaultvalue: https://graph.microsoft.com
  display: Server URL
  name: host
  required: true
  type: 0
- defaultvalue: ""
  display: ID (received from the admin consent - see Detailed Instructions)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the admin consent - see Detailed Instructions)
  name: tenant_id
  required: false
  type: 4
- defaultvalue: ""
  display: Key (received from the admin consent - see Detailed Instructions)
  name: enc_key
  required: false
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Use a self-deployed Azure Application
  name: self_deployed
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Use the Microsoft Graph Files integration to enable your app get authorized
  access to files in OneDrive, SharePoint, and MS Teams across your entire organization.
  This integration requires admin consent.
detaileddescription: |
  To allow access to Microsoft Graph Files, an administrator has to approve the Demisto app using the [admin consent flow](https://oproxy.demisto.ninja/ms-graph-files).

  After authorizing the Demisto app, you receive an ID, Token, and Key, all of which need to be entered to the corresponding fields when configuring the integration instance.

  ## Required Permissions in the MS Graph Files App

  - Directory.Read.All - Delegated
  - Files.ReadWrite.All - Delegated
  - Files.ReadWrite.All - Application
  - Sites.ReadWrite.All - Delegated
  - Sites.ReadWrite.All - Application
  - User.Read - Delegated
display: Microsoft Graph Files
image: data:image/png;base64,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
name: Microsoft_Graph_Files
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: The MS Graph resource. Can be "drives", "groups", "sites", or "users".
      isArray: true
      name: object_type
      predefined:
      - drives
      - groups
      - sites
      - users
      required: true
    - description: MS Graph resource id.
      name: object_type_id
      predefined:
      - ""
      required: true
    - description: The ID of the item to delete.
      name: item_id
      required: true
    description: Deletes an item from OneDrive.
    name: msgraph-delete-file
  - arguments:
    - auto: PREDEFINED
      description: The MS Graph resource. Can be "drives", "groups", "sites", or "users".
      name: object_type
      predefined:
      - drives
      - groups
      - users
      - sites
      required: true
    - description: The ID of the item to upload.
      name: object_type_id
      required: true
    - description: The ID of the folder in which to upload the file.
      name: parent_id
      required: true
    - description: A name for the file to upload.
      name: file_name
      required: true
    - description: The Demisto entry ID of the file.
      name: entry_id
      required: true
    description: Uploads a file from Demisto to the specified MS Graph resource.
    name: msgraph-upload-new-file
    outputs:
    - contextPath: MsGraphFiles.UploadedFiles.ParentReference.DriveId
      description: Unique identifier of the drive that contains the item.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.ParentReference.DriveType
      description: Identifies the drive type.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.ParentReference.ID
      description: Unique identifier of the item in the drive.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.ParentReference.Path
      description: The path of the item.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.LastModifiedDateTime
      description: Timestamp of when the item was last modified.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.File.MimeType
      description: The file type.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.File.Hashes
      description: The file hash type.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.CreatedDateTime
      description: Timestamp of when the item was created.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.WebUrl
      description: URL to the resource in the browser.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.OdataContext
      description: The OData query.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.FileSystemInfo.CreatedDateTime
      description: Timestamp of when the item was created on a client.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.FileSystemInfo.LastModifiedDateTime
      description: Timestamp of when the item was last modified on a client.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.LastModifiedBy.DisplayName
      description: The item display name.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.LastModifiedBy.Type
      description: The application, user, or device that last modified the item.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.CreatedBy.DisplayName
      description: The identity of the user, device,or application that created the
        item.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.CreatedBy.ID
      description: The ID of the creator.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.CreatedBy.Type
      description: The application, user, or device that created the item.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.DownloadUrl
      description: URL to download this file's content.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.Size
      description: The file size.
      type: Number
    - contextPath: MsGraphFiles.UploadedFiles.ID
      description: The file ID.
      type: String
    - contextPath: MsGraphFiles.UploadedFiles.Name
      description: The file name.
      type: String
    - contextPath: MsGraph.UploadedFiles.File
      description: The MS Graph file object.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The MS Graph resource. Can be "drives", "groups", "sites", or "users".
      name: object_type
      predefined:
      - drives
      - groups
      - sites
      - users
      required: true
    - description: The MS Graph resource ID.
      name: object_type_id
      required: true
    - description: The MS Graph item ID.
      name: item_id
      required: true
    - description: The Demisto entry ID of the file.
      name: entry_id
      required: true
    description: Replaces the content of the file in the specified MS Graph resource.
    name: msgraph-replace-existing-file
    outputs:
    - contextPath: MsGraphFiles.ReplacedFiles.ParentReference.DriveId
      description: Unique identifier of the drive that contains the item.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.ParentReference.DriveType
      description: The drive type.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.ParentReference.ID
      description: Unique identifier of the item in the drive.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.ParentReference.Path
      description: The path of the item.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.LastModifiedDateTime
      description: Timestamp of when the item was last modified.
      type: Date
    - contextPath: MsGraphFiles.ReplacedFiles.File.MimeType
      description: The file type.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.File.Hashes
      description: The file hash type.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.CreatedDateTime
      description: Timestamp of when the item was created.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.WebUrl
      description: URL to the resource in the browser.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.OdataContext
      description: The OData query.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.FileSystemInfo.CreatedDateTime
      description: Timestamp of when the item was created on a client.
      type: Date
    - contextPath: MsGraphFiles.ReplacedFiles.FileSystemInfo.LastModifiedDateTime
      description: Timestamp of when the item was last modified on a client.
      type: Date
    - contextPath: MsGraphFiles.ReplacedFiles.LastModifiedBy.DisplayName
      description: The item display name.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.LastModifiedBy.ID
      description: Identity of the application that last modified the item.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.CreatedBy.DisplayName
      description: Identity of the user, device, or application that created the item.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.CreatedBy.ID
      description: The ID of the creator.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.CreatedBy.Type
      description: Application, user, or device.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.DownloadUrl
      description: URL to download the file's content.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.Size
      description: File's size
      type: Number
    - contextPath: MsGraphFiles.ReplacedFiles.Id
      description: The file ID.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.Name
      description: The file name.
      type: String
    - contextPath: MsGraphFiles.ReplacedFiles.File
      description: The MS Graph file object.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The MS Graph resource. Can be "drives", "groups", "sites", or "users".
      name: object_type
      predefined:
      - drives
      - groups
      - sites
      - users
      required: true
    - description: The MS Graph resource ID.
      name: object_type_id
      required: true
    - description: The ID of the drive in which to upload the new folder.
      name: parent_id
      required: true
    - description: The name of the new folder.
      name: folder_name
      required: true
    description: Creates a new folder in a drive with the specified parent item or
      path.
    name: msgraph-create-new-folder
    outputs:
    - contextPath: MsGraph.Folder
      description: The MS Graph folder object.
      type: Unknown
    - contextPath: Msgraphfiles.CreatedFolder.ParentReference.DriveId
      description: Unique identifier of the drive that contains the item.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.ParentReference.DriveType
      description: The drive type.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.ParentReference.ID
      description: Unique identifier of the item in the drive.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.ParentReference.Path
      description: The path to the item
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.LastModifiedDateTime
      description: Timestamp of when the item was last modified.
      type: Date
    - contextPath: Msgraphfiles.CreatedFolder.Name
      description: The folder name.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.CreatedDateTime
      description: Timestamp of when the item was created.
      type: Date
    - contextPath: Msgraphfiles.CreatedFolder.WebUrl
      description: URL to the resource in the browser.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.OdataContext
      description: The OData query.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.FileSystemInfo.CreatedDateTime
      description: Timestamp of when the item was created on a client.
      type: Date
    - contextPath: Msgraphfiles.CreatedFolder.FileSystemInfo.LastModifiedDateTime
      description: Timestamp of when the item was last modified on a client.
      type: Date
    - contextPath: Msgraphfiles.CreatedFolder.LastModifiedBy.DisplayName
      description: The item display name.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.LastModifiedBy.ID
      description: Identity of the application that last modified the item.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.CreatedBy.DisplayName
      description: Identity of the user, device,or application that created the item.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.CreatedBy.ID
      description: The ID of the creator.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.ChildCount
      description: The number of sub-items in the folder.
      type: Number
    - contextPath: Msgraphfiles.CreatedFolder.ID
      description: The folder ID.
      type: String
    - contextPath: Msgraphfiles.CreatedFolder.Size
      description: The folder size.
      type: Number
  - arguments:
    - description: The ID of the site for which to return available drive resources.
      name: site_id
    - description: The maximum number of results to return.
      name: limit
    - description: The URL for the next results page.
      name: next_page_url
    description: Returns the list of document libraries (drives) available for a target
      site.
    name: msgraph-list-drives-in-site
    outputs:
    - contextPath: MsGraphFiles.ListDrives.Value.LastModifiedDateTime
      description: Timestamp of when the item was last modified.
      type: Date
    - contextPath: MsGraphFiles.ListDrives.Value.Description
      description: A human-readable description of the drive.
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.CreatedDateTime
      description: Timestamp of when the drive was created.
      type: Date
    - contextPath: MsGraphFiles.ListDrives.Value.WebUrl
      description: URL to the resource in the browser.
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.CreatedBy
      description: Identity of the user, application, or device that created the drive.
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.Owner.DisplayName
      description: The display name of the user, device, or application that owns
        the drive.
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.Owner.ID
      description: The ID of the user, device, or application that owns the drive.
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.Owner.Type
      description: The owner type. Can be "user", "device", or "application".
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.DriveType
      description: The drive type.
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.ID
      description: The drive ID.
      type: String
    - contextPath: MsGraphFiles.ListDrives.Value.Name
      description: The name of the drive.
      type: String
    - contextPath: MsGraphFiles.ListDrives.OdataContext
      description: The OData query.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The MS Graph resource. Can be "drives", "groups", "sites", or "users".
      name: object_type
      predefined:
      - drives
      - groups
      - sites
      - users
      required: true
    - description: The MS Graph resource ID.
      name: object_type_id
      required: true
    - description: The Ms Graph item ID.
      name: item_id
    - description: The maximum number of results to return.
      name: limit
    - description: The URL for the next results page.
      name: next_page_url
    description: Returns a list of files and folders in the specified drive.
    name: msgraph-list-drive-content
    outputs:
    - contextPath: MsGraphFiles.ListChildren.Children.Value.OdataNextLink
      description: The URL for the next results page.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.ParentReference.DriveId
      description: Unique identifier of the drive that contains the item.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.ParentReference.DriveType
      description: The drive type.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.ParentReference.ID
      description: Unique identifier of the item in the drive.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.ParentReference.Path
      description: The path to the item.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.LastModifiedDateTime
      description: Timestamp of when the item was last modified.
      type: Date
    - contextPath: MsGraphFiles.ListChildren.Children.Value.Name
      description: The file name.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.CreatedDateTime
      description: Timestamp of when the item was created.
      type: Date
    - contextPath: MsGraphFiles.ListChildren.Children.Value.WebUrl
      description: URL to the resource in the browser.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.FileSystemInfo.CreatedDateTime
      description: Timestamp of when the item was created on a client.
      type: Date
    - contextPath: MsGraphFiles.ListChildren.Children.Value.FileSystemInfo.LastModifiedDateTime
      description: Timestamp of when the item was last modified on a client.
      type: Date
    - contextPath: MsGraphFiles.ListChildren.Children.Value.LastModifiedBy.DisplayName
      description: The item display name.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.LastModifiedBy.ID
      description: Identity of the application, user, or device that last modified
        the item.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.CreatedBy.DisplayName
      description: Identity of the user, device, or application that created the item.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.CreatedBy.ID
      description: The ID of the creator.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Value.CreatedBy.Type
      description: The created by type. Can be "application", "user", or "device".
      type: String
    - contextPath: MsGraphFiles.ListChildren.ID
      description: The file ID or folder ID.
      type: String
    - contextPath: MsGraphFiles.ListChildren.Children.Size
      description: The file size or folder size.
      type: Number
    - contextPath: MsGraphFiles.ListChildren.Children.OdataContext
      description: The OData query.
      type: String
  - arguments: []
    description: Returns a list of the tenant sites.
    name: msgraph-list-sharepoint-sites
    outputs:
    - contextPath: MsGraph.Sites
      description: The MS Graph site object.
      type: Unknown
    - contextPath: MsGraphFiles.OdataContext
      description: The OData query.
      type: String
    - contextPath: MsGraphFiles.OdataNextLink
      description: The URL for the next results page.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.LastModifiedDateTime
      description: Timestamp of when the item was last modified.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.DisplayName
      description: The item display name.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.Description
      description: The item description.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.CreatedDateTime
      description: Timestamp of when the site was created.
      type: Date
    - contextPath: MsGraphFiles.ListSites.Value.WebUrl
      description: URL to the resource in the browser.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.OdataContext
      description: The OData query.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.SiteCollection.Hostname
      description: The hostname for the site collection.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.ID
      description: The site ID.
      type: String
    - contextPath: MsGraphFiles.ListSites.Value.Name
      description: The site name.
      type: String
  - arguments:
    - auto: PREDEFINED
      description: The MS Graph resource. Can be "drives", "groups", "sites", or "users".
      name: object_type
      predefined:
      - drives
      - groups
      - sites
      - users
      required: true
    - description: The MS Graph resource ID.
      name: object_type_id
      required: true
    - description: The MS Graph item ID.
      name: item_id
      required: true
    description: Downloads the file contents of the drive item.
    name: msgraph-download-file
    outputs:
    - contextPath: File.Size
      description: The file size.
      type: String
    - contextPath: File.SHA1
      description: The SHA1 hash of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: String
    - contextPath: File.SHA512
      description: The SHA512 hash of the file.
      type: String
    - contextPath: File.Name
      description: The file name.
      type: String
    - contextPath: File.SSDeep
      description: The SSDeep hash of the file.
      type: String
    - contextPath: File.EntryID
      description: The Demisto file ID.
      type: Unknown
    - contextPath: File.Info
      description: Information about the file.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.MD5
      description: The MD5 hash of the file.
      type: String
  dockerimage: demisto/python_pancloud:1.0.0.7740
  runonce: false
  script: |2




    """ IMPORTS """

    from urllib.parse import parse_qs, urlparse

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    """ GLOBALS/PARAMS """

    INTEGRATION_NAME = "MsGraphFiles"
    APP_NAME = "ms-graph-files"

    RESPONSE_KEYS_DICTIONARY = {
        "@odata.context": "OdataContext",
        "@microsoft.graph.downloadUrl": "DownloadUrl",
        "id": "ID",
        "@odata.nextLink": "OdataNextLink",
    }

    EXCLUDE_LIST = ["eTag", "cTag", "quota"]


    def parse_key_to_context(obj):
        """Parse graph api data as received from Microsoft Graph API into Demisto's conventions

        Args:
            item object: a dictionary containing the item data

        Returns:
            A Camel Cased dictionary with the relevant fields.
            groups_readable: for the human readable
            groups_outputs: for the entry context
        """
        parsed_obj = {}
        for key, value in obj.items():
            if key in EXCLUDE_LIST:
                continue
            new_key = RESPONSE_KEYS_DICTIONARY.get(key, key)
            parsed_obj[new_key] = value
            if type(value) == dict:
                parsed_obj[new_key] = parse_key_to_context(value)

        under_score_obj = createContext(parsed_obj, keyTransform=camel_case_to_underscore)
        context_entry = createContext(under_score_obj, keyTransform=string_to_context_key)

        if "Id" in list(context_entry.keys()):
            context_entry["ID"] = context_entry["Id"]
            del context_entry["Id"]
        if "CreatedBy" in list(context_entry.keys()):
            context_entry["CreatedBy"] = remove_identity_key(context_entry["CreatedBy"])
        if "LastModifiedBy" in list(context_entry.keys()):
            context_entry["LastModifiedBy"] = remove_identity_key(
                context_entry["LastModifiedBy"]
            )
        return context_entry


    def remove_identity_key(source):
        """
        this function removes identity key (application, device or user) from LastModifiedBy and CreatedBy keys and
        convert it to "type" key.
        :param source: LastModifiedBy and CreatedBy dictionaries
        :return: camel case dictionary with identity key as type.
        """
        if not isinstance(source, dict):
            LOG("Input is not dictionary. Exist function.")
            return source

        dict_keys = list(source.keys())
        if len(dict_keys) != 1:
            demisto.log("Got more then one identity creator. Exit function")
            return source

        identity_key = dict_keys[0]
        new_source = {}
        if source[identity_key].get("ID"):
            new_source["ID"] = source[identity_key].get("ID")

        new_source["DisplayName"] = source[identity_key].get("DisplayName")
        new_source["Type"] = identity_key

        return new_source


    def url_validation(url):
        """
        this function tests if a user provided a valid next link url
        :param url: next_link_url from graph api
        :return: checked url if url is valid. demisto error if not.
        """
        parsed_url = urlparse(url)
        # test if exits $skiptoken
        url_parameters = parse_qs(parsed_url.query)
        if not url_parameters.get("$skiptoken") or not url_parameters["$skiptoken"]:
            raise DemistoException(
                f"Url: {url} is not valid. Please provide another one. missing $skiptoken"
            )
        return url


    class MsGraphClient:
        """
        Microsoft Graph Client enables authorized access to organization's files in OneDrive, SharePoint, and MS Teams.
        """

        def __init__(self, tenant_id, auth_id, enc_key, app_name, base_url, verify, proxy, self_deployed, ok_codes):
            self.ms_client = MicrosoftClient(
                tenant_id=tenant_id, auth_id=auth_id, enc_key=enc_key, app_name=app_name,
                base_url=base_url, verify=verify, proxy=proxy, self_deployed=self_deployed, ok_codes=ok_codes)

        def list_sharepoint_sites(self):
            """
            This function returns a list of the tenant sites
            :return: graph api raw response
            """
            query_string = {"search": "*"}
            return self.ms_client.http_request(
                method="GET",
                url_suffix="sites",
                params=query_string,
            )

        def list_drives_in_site(self, site_id=None, limit=None, next_page_url=None):
            """
            Returns the list of Drive resources available for a target Site
            :param site_id: selected Site ID.
            :param limit: sets the page size of results.
            :param next_page_url: the URL for the next results page.
            :return:
            """
            if not any([site_id, next_page_url]):
                raise DemistoException(
                    "Please pass at least one argument to this command: \n"
                    "site_id: if you want to get all sites.\n"
                    "limit: if you want to limit the number of command's results. \n"
                    "next_page_url: if you have used the limit argument."
                )

            params = {"$top": limit} if limit else ""

            if next_page_url:
                url = url_validation(next_page_url)
                return self.ms_client.http_request(method="GET", full_url=url, params=params)

            url_suffix = f"sites/{site_id}/drives"
            return self.ms_client.http_request(method="GET", params=params, url_suffix=url_suffix)

        def list_drive_content(self, object_type, object_type_id, item_id=None, limit=None, next_page_url=None):
            """
            This command list all the drive's files and folders
            :param object_type: ms graph resource.
            :param object_type_id: ms graph resource id.
            :param item_id: ms graph item_id. optional.
            :param limit: sets the page size of results. optional.
            :param next_page_url: the URL for the next results page. optional.
            :return: graph api raw response
            """
            params = {"$top": limit} if limit else ""

            if next_page_url:
                url = url_validation(next_page_url)
                return self.ms_client.http_request(method="GET", full_url=url, params=params)

            if object_type == "drives":
                uri = f"{object_type}/{object_type_id}/items/{item_id}/children"
            elif object_type in ["groups", "sites", "users"]:
                uri = f"{object_type}/{object_type_id}/drive/items/{item_id}/children"

            return self.ms_client.http_request(
                method="GET",
                url_suffix=uri,
                params=params,
            )

        def replace_existing_file(self, object_type, object_type_id, item_id, entry_id):
            """
            replace file context in MS Graph resource
            :param object_type: ms graph resource.
            :param object_type_id: ms graph resource id.
            :param item_id: item_id: ms graph item_id.
            :param entry_id: demisto file entry id
            :return: graph api raw response
            """

            file_path = demisto.getFilePath(entry_id).get("path", None)
            if not file_path:
                raise DemistoException(
                    f"Could not find file path to the next entry id: {entry_id}. \n"
                    f"Please provide another one."
                )
            if object_type == "drives":
                uri = f"{object_type}/{object_type_id}/items/{item_id}/content"

            elif object_type in ["groups", "sites", "users"]:
                uri = f"{object_type}/{object_type_id}/drive/items/{item_id}/content"
            with open(file_path, "rb") as file:
                headers = {"Content-Type": "application/octet-stream"}
                return self.ms_client.http_request(
                    method="PUT", data=file, headers=headers, url_suffix=uri
                )

        def delete_file(self, object_type, object_type_id, item_id):
            """
            Delete a DriveItem by using its ID
            :param object_type: ms graph resource.
            :param object_type_id: ms graph resource id.
            :param item_id: ms graph item_id.
            :return: graph api raw response
            """
            if object_type == "drives":
                uri = f"{object_type}/{object_type_id}/items/{item_id}"

            elif object_type in ["groups", "sites", "users"]:
                uri = f"{object_type}/{object_type_id}/drive/items/{item_id}"

            # send request
            self.ms_client.http_request(
                method="DELETE",
                url_suffix=uri,
                resp_type="text")

            return "Item was deleted successfully"

        def upload_new_file(self, object_type, object_type_id, parent_id, file_name, entry_id):
            """
            this function upload new file to a selected folder(parent_id)
            :param object_type: drive/ group/ me/ site/ users
            :param object_type_id: the selected object type id.
            :param parent_id: an ID of the folder to upload the file to.
            :param file_name: file name
            :param entry_id: demisto file entry ID
            :return: graph api raw response
            """
            file_path = demisto.getFilePath(entry_id).get("path")

            if "drives" == object_type:
                uri = f"{object_type}/{object_type_id}/items/{parent_id}:/{file_name}:/content"

            elif object_type in ["groups", "users", "sites"]:
                uri = f"{object_type}/{object_type_id}/drive/items/{parent_id}:/{file_name}:/content"

            with open(file_path, "rb") as file:
                headers = {"Content-Type": "application/octet-stream"}
                return self.ms_client.http_request(
                    method="PUT", headers=headers, url_suffix=uri, data=file)

        def download_file(self, object_type, object_type_id, item_id):
            """
            Download the contents of the file of a DriveItem.
            :param object_type: ms graph resource.
            :param object_type_id: the selected object type id.
            :param item_id: ms graph item_id.
            :return: graph api raw response
            """
            if object_type == "drives":
                uri = f"{object_type}/{object_type_id}/items/{item_id}/content"

            elif object_type in ["groups", "sites", "users"]:
                uri = f"{object_type}/{object_type_id}/drive/items/{item_id}/content"

            # send request
            return self.ms_client.http_request(method="GET", url_suffix=uri, resp_type='response')

        def create_new_folder(self, object_type, object_type_id, parent_id, folder_name):
            """
            Create a new folder in a Drive with a specified parent item or path.
            :param object_type: ms graph resource.
            :param object_type_id: the selected object type id.
            :param parent_id: an ID of the Drive to upload the folder to.
            :param folder_name: folder name
            :return: graph api raw response
            """
            if object_type == "drives":
                uri = f"{object_type}/{object_type_id}/items/{parent_id}/children"

            elif object_type in ["groups", "sites", "users"]:
                uri = f"{object_type}/{object_type_id}/drive/items/{parent_id}/children"

            # send request
            payload = {
                "name": folder_name,
                "folder": {},
                "@microsoft.graph.conflictBehavior": "rename",
            }

            return self.ms_client.http_request(method="POST", json_data=payload, url_suffix=uri)


    def module_test(client: MsGraphClient, *_):
        """
        Performs basic get request to get item samples
        """
        try:
            client.ms_client.http_request(
                url_suffix="sites/root",
                params={"top": "1"},
                timeout=7,
                method="GET")

        except Exception as e:
            raise DemistoException(
                f"Test failed. please check if Server Url is correct. \n {e}"
            )
        return 'ok'


    def download_file_command(client: MsGraphClient, args):
        """
        This function runs download file command
        :return: FileResult object
        """
        object_type = args.get("object_type")
        object_type_id = args.get("object_type_id")
        item_id = args.get("item_id")

        result = client.download_file(
            object_type=object_type, object_type_id=object_type_id, item_id=item_id
        )
        stored_img = fileResult(item_id, result.content)
        return stored_img


    def list_drive_content_human_readable_object(parsed_drive_items):
        human_readable_content_obj = {
            "Name": parsed_drive_items.get("Name"),
            "ID": parsed_drive_items.get("ID"),
            "CreatedBy": parsed_drive_items.get("CreatedBy").get("DisplayName"),
            "CreatedDateTime": parsed_drive_items.get("CreatedDateTime"),
            "Description": parsed_drive_items.get("Description"),
            "Size": parsed_drive_items.get("Size"),
            "LastModifiedDateTime": parsed_drive_items.get("LastModifiedDateTime"),
            "WebUrl": parsed_drive_items.get("WebUrl"),
        }
        return human_readable_content_obj


    def list_drive_content_command(client: MsGraphClient, args):
        """
        This function runs list drive children command
        :return: human_readable, context, result
        """
        object_type = args.get("object_type")
        object_type_id = args.get("object_type_id")
        item_id = args.get("item_id")
        limit = args.get("limit")
        next_page_url = args.get("next_page_url")

        if not item_id:
            item_id = "root"

        result = client.list_drive_content(
            object_type=object_type,
            object_type_id=object_type_id,
            item_id=item_id,
            limit=limit,
            next_page_url=next_page_url,
        )

        title = f"{INTEGRATION_NAME} - drivesItems information:"

        parsed_drive_items = [parse_key_to_context(item) for item in result["value"]]
        human_readable_content = [
            list_drive_content_human_readable_object(item) for item in parsed_drive_items
        ]
        human_readable = tableToMarkdown(
            title, human_readable_content, headerTransform=pascalToSpace
        )

        drive_items_outputs = {
            "OdataContext": result["@odata.context"],
            "Value": parsed_drive_items,
        }
        context = {
            f"{INTEGRATION_NAME}.ListChildren(val.ItemID == obj.ItemID)": {
                "ParentID": item_id,
                "Children": drive_items_outputs,
            }
        }

        return human_readable, context, result


    def list_share_point_sites_human_readable_object(parsed_drive_items):
        human_readable_content_obj = {
            "Name": parsed_drive_items.get("Name"),
            "ID": parsed_drive_items.get("ID"),
            "CreatedDateTime": parsed_drive_items.get("CreatedDateTime"),
            "LastModifiedDateTime": parsed_drive_items.get("LastModifiedDateTime"),
            "WebUrl": parsed_drive_items.get("WebUrl"),
        }
        return human_readable_content_obj


    def list_sharepoint_sites_command(client: MsGraphClient, *_):
        """
        This function runs list tenant site command
        :return: human_readable, context, result
        """
        result = client.list_sharepoint_sites()

        parsed_sites_items = [parse_key_to_context(item) for item in result["value"]]

        human_readable_content = [
            list_share_point_sites_human_readable_object(item)
            for item in parsed_sites_items
        ]

        context_entry = {
            "OdataContext": result.get("@odata.context"),
            "Value": parsed_sites_items,
        }
        context = {f"{INTEGRATION_NAME}.ListSites(val.ID === obj.ID)": context_entry}

        title = "List Sites:"
        human_readable = tableToMarkdown(
            title, human_readable_content, headerTransform=pascalToSpace
        )

        return human_readable, context, result


    def list_drives_human_readable_object(parsed_drive_items):
        human_readable_content_obj = {
            "Name": parsed_drive_items.get("Name"),
            "ID": parsed_drive_items.get("ID"),
            "CreatedBy": parsed_drive_items.get("CreatedBy").get("DisplayName"),
            "CreatedDateTime": parsed_drive_items.get("CreatedDateTime"),
            "Description": parsed_drive_items.get("Description"),
            "DriveType": parsed_drive_items.get("DriveType"),
            "LastModifiedDateTime": parsed_drive_items.get("LastModifiedDateTime"),
            "WebUrl": parsed_drive_items.get("WebUrl"),
        }
        return human_readable_content_obj


    def list_drives_in_site_command(client: MsGraphClient, args):
        """
        This function run the list drives in site command
        :return: human_readable, context, result
        """
        site_id = args.get("site_id")
        limit = args.get("limit")
        next_page_url = args.get("next_page_url")

        if next_page_url:
            url_validation(next_page_url)

        result = client.list_drives_in_site(
            site_id=site_id, limit=limit, next_page_url=next_page_url
        )
        parsed_drive_items = [parse_key_to_context(item) for item in result["value"]]

        human_readable_content = [
            list_drives_human_readable_object(item) for item in parsed_drive_items
        ]

        context_entry = {
            "OdataContext": result.get("@odata.context", None),
            "Value": parsed_drive_items,
        }

        title = f"{INTEGRATION_NAME} - Drives information:"
        # Creating human readable for War room
        human_readable = tableToMarkdown(
            title, human_readable_content, headerTransform=pascalToSpace
        )

        # context == output
        context = {f"{INTEGRATION_NAME}.ListDrives(val.ID === obj.ID)": context_entry}

        return human_readable, context, result


    def replace_an_existing_file_command(client: MsGraphClient, args):
        """
        This function runs the replace existing file command
        :return: human_readable, context, result
        """
        object_type = args.get("object_type")
        item_id = args.get("item_id")
        entry_id = args.get("entry_id")
        object_type_id = args.get("object_type_id")

        result = client.replace_existing_file(
            object_type, object_type_id, item_id, entry_id
        )
        context_entry = parse_key_to_context(result)

        human_readable_content = {
            "ID": context_entry.get("ID"),
            "Name": context_entry.get("Name"),
            "CreatedBy": context_entry.get("CreatedBy").get("DisplayName"),
            "CreatedDateTime": context_entry.get("CreatedDateTime"),
            "LastModifiedBy": context_entry.get("LastModifiedBy").get("DisplayName"),
            "Size": context_entry.get("Size"),
            "WebUrl": context_entry.get("WebUrl"),
        }

        title = f"{INTEGRATION_NAME} - File information:"
        # Creating human readable for War room
        human_readable = tableToMarkdown(
            title, human_readable_content, headerTransform=pascalToSpace
        )

        # context == output
        context = {f"{INTEGRATION_NAME}.ReplacedFiles(val.ID === obj.ID)": context_entry}

        return human_readable, context, result


    def upload_new_file_command(client: MsGraphClient, args):
        """
        This function uploads new file to graph api
        :return: human_readable, context, result
        """
        object_type = args.get("object_type")
        object_type_id = args.get("object_type_id")
        parent_id = args.get("parent_id")
        file_name = args.get("file_name")
        entry_id = args.get("entry_id")

        result = client.upload_new_file(
            object_type, object_type_id, parent_id, file_name, entry_id
        )
        context_entry = parse_key_to_context(result)

        human_readable_content = {
            "ID": context_entry.get("ID"),
            "Name": context_entry.get("Name"),
            "CreatedBy": context_entry.get("CreatedBy").get("DisplayName"),
            "CreatedDateTime": context_entry.get("CreatedDateTime"),
            "LastModifiedBy": context_entry.get("LastModifiedBy").get("DisplayName"),
            "Size": context_entry.get("Size"),
            "WebUrl": context_entry.get("WebUrl"),
        }

        title = f"{INTEGRATION_NAME} - File information:"
        # Creating human readable for War room
        human_readable = tableToMarkdown(title, human_readable_content)

        # context == output
        context = {f"{INTEGRATION_NAME}.UploadedFiles(val.ID === obj.ID)": context_entry}
        return human_readable, context, result


    def create_new_folder_command(client: MsGraphClient, args):
        """
        This function runs create new folder command
        :return: human_readable, context, result
        """
        object_type = args.get("object_type")
        parent_id = args.get("parent_id")
        folder_name = args.get("folder_name")
        object_type_id = args.get("object_type_id")

        result = client.create_new_folder(
            object_type, object_type_id, parent_id, folder_name
        )

        context_entry = parse_key_to_context(result)

        human_readable_content = {
            "ID": context_entry.get("ID"),
            "Name": context_entry.get("Name"),
            "CreatedBy": context_entry.get("CreatedBy").get("DisplayName"),
            "CreatedDateTime": context_entry.get("CreatedDateTime"),
            "ChildCount": context_entry.get("Folder"),
            "LastModifiedBy": context_entry.get("LastModifiedBy").get("DisplayName"),
            "Size": context_entry.get("Size"),
            "WebUrl": context_entry.get("WebUrl"),
        }
        title = f"{INTEGRATION_NAME} - Folder information:"
        # Creating human readable for War room

        human_readable = tableToMarkdown(
            title, human_readable_content, headerTransform=pascalToSpace
        )

        # context == output
        context = {f"{INTEGRATION_NAME}.CreatedFolders(val.ID === obj.ID)": context_entry}

        return human_readable, context, result


    def delete_file_command(client: MsGraphClient, args):
        """
        runs delete file command
        :return: raw response and action result test
        """
        object_type = args.get("object_type")
        item_id = args.get("item_id")
        object_type_id = args.get("object_type_id")

        text = client.delete_file(object_type, object_type_id, item_id)

        context_entry = text

        title = f"{INTEGRATION_NAME} - File information:"
        # Creating human readable for War room
        human_readable = tableToMarkdown(title, context_entry, headers=item_id)

        return human_readable, text  # == raw response


    def main():
        params: dict = demisto.params()
        base_url: str = params.get('host', '').rstrip('/') + '/v1.0/'
        tenant = params.get('tenant_id')
        auth_id = params.get('auth_id')
        enc_key = params.get('enc_key')
        use_ssl: bool = not params.get('insecure', False)
        proxy: bool = params.get('proxy', False)
        self_deployed: bool = params.get('self_deployed', False)
        ok_codes: tuple = (200, 204, 201)

        try:
            client = MsGraphClient(base_url=base_url, tenant_id=tenant, auth_id=auth_id, enc_key=enc_key, app_name=APP_NAME,
                                   verify=use_ssl, proxy=proxy, self_deployed=self_deployed, ok_codes=ok_codes)

            LOG(f"Command being called is {demisto.command()}")

            if demisto.command() == "test-module":
                # This is the call made when pressing the integration Test button.
                result = module_test(client)
                demisto.results(result)
            elif demisto.command() == "msgraph-delete-file":
                readable_output, raw_response = delete_file_command(client, demisto.args())
                return_outputs(readable_output=readable_output, raw_response=raw_response)
            elif demisto.command() == "msgraph-list-sharepoint-sites":
                return_outputs(*list_sharepoint_sites_command(client, demisto.args()))
            elif demisto.command() == "msgraph-download-file":
                # it has to be demisto.results instead of return_outputs.
                # because fileResult contains 'content': '' and if that key is empty return_outputs returns error.
                demisto.results(download_file_command(client, demisto.args()))
            elif demisto.command() == "msgraph-list-drive-content":
                return_outputs(*list_drive_content_command(client, demisto.args()))
            elif demisto.command() == "msgraph-create-new-folder":
                return_outputs(*create_new_folder_command(client, demisto.args()))
            elif demisto.command() == "msgraph-replace-existing-file":
                return_outputs(*replace_an_existing_file_command(client, demisto.args()))
            elif demisto.command() == "msgraph-list-drives-in-site":
                return_outputs(*list_drives_in_site_command(client, demisto.args()))
            elif demisto.command() == "msgraph-upload-new-file":
                return_outputs(*upload_new_file_command(client, demisto.args()))

        # Log exceptions
        except Exception as err:
            return_error(
                f"Failed to execute {demisto.command()} command. Error: {str(err)}", err
            )



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.import traceback




    import requests
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Tuple

    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line


    class MicrosoftClient(BaseClient):

        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str = '',
                     token_retrieval_url: str = 'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = 'https://graph.microsoft.com/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str = '',
                     verify: bool = True,
                     self_deployed: bool = False,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]

            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id)
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope
                self.redirect_uri = redirect_uri

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify

        def http_request(self, *args, resp_type='json', headers=None, return_empty_response=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            if headers:
                default_headers.update(headers)

            response = super()._http_request(   # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))

            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self):
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            refresh_token = integration_context.get('current_refresh_token', '')
            valid_until = integration_context.get('valid_until')
            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            auth_type = self.auth_type
            if auth_type == OPROXY_AUTH_TYPE:
                access_token, expires_in, refresh_token = self._oproxy_authorize()
            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            integration_context = {
                'access_token': access_token,
                'current_refresh_token': refresh_token,
                'valid_until': time_now + expires_in,
            }

            demisto.setIntegrationContext(integration_context)
            return access_token

        def _oproxy_authorize(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key)
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self, refresh_token: str = ''):
            if self.grant_type == AUTHORIZATION_CODE:
                return self._get_self_deployed_token_auth_code(refresh_token)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                return self._get_self_deployed_token_client_credentials()

        def _get_self_deployed_token_client_credentials(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.scope:
                data['scope'] = self.scope
            if self.resource:
                data['resource'] = self.resource

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(self, refresh_token: str = '') -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'resource': self.resource,
                'redirect_uri': self.redirect_uri
            }
            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            # refresh_token = response_json.get('refresh_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
                brand_name = calling_context.get('IntegrationBrand', '')
                instance_name = calling_context.get('IntegrationInstance', '')
                headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
                headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
                if hasattr(demisto, 'demistoVersion'):
                    demisto_version = demisto.demistoVersion()
                    headers['X-Content-Server-Version'] = '{}-{}'.format(demisto_version.get('version'),
                                                                         demisto_version.get("buildNumber"))
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers



    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()
  subtype: python3
  type: python
system: true
