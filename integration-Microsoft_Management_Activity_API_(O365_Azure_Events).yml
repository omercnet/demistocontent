category: Data Enrichment & Threat Intelligence
commonfields:
  id: Microsoft Management Activity API (O365 Azure Events)
  version: -1
configuration:
- defaultvalue: https://manage.office.com/api/v1.0/
  display: Base URL
  name: base_url
  required: false
  type: 0
- defaultvalue: ""
  display: ID (received from the authorization step - see Detailed Instructions (?)
    section)
  name: auth_id
  required: false
  type: 4
- defaultvalue: ""
  display: Key (received from the authorization step - see Detailed Instructions (?)
    section)
  name: enc_key
  required: false
  type: 4
- defaultvalue: ""
  display: Token (received from the authorization step - see Detailed Instructions
    (?) section)
  name: refresh_token
  required: false
  type: 4
- defaultvalue: ""
  display: Use a self-deployed Azure application
  name: self_deployed
  required: false
  type: 8
- defaultvalue: ""
  display: The authentication code you got for the service. For instructions on how
    to receive it, see the detailed description ('?') section.
  name: auth_code
  required: false
  type: 4
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: 10 minutes
  display: First fetch time range (<number> <time unit>, e.g., 1 hour, 30 minutes)
  name: first_fetch_delta
  required: false
  type: 0
- defaultvalue: ""
  display: Content types to fetch
  name: content_types_to_fetch
  options:
  - Audit.AzureActiveDirectory
  - Audit.Exchange
  - Audit.SharePoint
  - Audit.General
  required: false
  type: 16
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: ""
  display: Record types to fetch (Comma-separated list of the record types you wish
    to fetch. Content records with a record  type that isn't specified will not be
    fetched. If this field is left empty, all record types will be fetched.)
  name: record_types_filter
  required: false
  type: 0
- defaultvalue: ""
  display: Workloads to fetch (Comma-separated list of the workloads you wish to fetch.
    Content records with a workload that isn't specified will not be fetched. If this
    field is left empty, all workloads will be fetched.)
  name: workloads_filter
  required: false
  type: 0
- defaultvalue: ""
  display: Operations to (Comma-separated list of the operations you wish to fetch.
    Content records with an operation that isn't specified will not be fetched. If
    this field is left empty, all operations will be fetched.)
  name: operations_filter
  required: false
  type: 0
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: The Microsoft Management Activity API integration enables you to subscribe
  or unsubscribe to different audits, receive their content and fetch new content
  as incidents.
detaileddescription: "To read the integration's description and authentication instructions
  more conveniently, you are  welcome to browse them here:\nhttps://xsoar.pan.dev/docs/reference/integrations/microsoft-management-activity-api-(O365/Azure-Events)\n\nMicrosoft
  Management Activity API (O365/Azure Events) should be used to retrieve content records
  from the various Microsoft Management Activity content types.\nThrough the integration
  you can subscribe to new content types or stop your subscription, list the available
  content of each content type, and most importantly - fetch new content records from
  content types of your choice as Demisto incidents.\n\n## Grant Demisto Authorization
  in Microsoft Management Activity API\nTo allow us to access Microsoft Management
  Activity API you will be required to give us authorization to access it.\n\n1. To
  grant authorization, click the [HERE](https://oproxy.demisto.ninja/ms-management-api).\n2.
  After you click the link, click the **Start Authorization Process** button.\n3.
  When prompted, accept the Microsoft authorization request for the required permissions.\nYou
  will get an ID, Token, and Key, which you need to enter in the corresponding fields
  when configuring an integration instnace..\n\n## Self-Deployed Configuration\n1.
  Enter the following URL.\nNote that CLIENT_ID and REDIRECT_URI should be replaced
  by your own client ID and redirect URI, accordingly.\nhttps://login.windows.net/common/oauth2/authorize?response_type=code&resource=https://manage.office.com&client_id=CLIENT_ID&redirect_uri=REDIRECT_URI\n2.
  When prompted, accept the Microsoft authorization request for the required permissions.\n3.
  The URL will change and will have the following structure:\nSOME_PREFIX?code=AUTH_CODE&session_state=SESSION_STATE\nTake
  the AUTH_CODE (without the “code=” prefix) and enter it to the instance configuration
  under the “Authentication” code section.\nMoreover, enter your client secret as
  the “Key” parameter and your client ID as the “ID” parameter. \n"
display: Microsoft Management Activity API (O365 Azure Events)
image: data:image/png;base64,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
name: Microsoft Management Activity API (O365 Azure Events)
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: The content type to subscribe to.
      name: content_type
      predefined:
      - Audit.AzureActiveDirectory
      - Audit.Exchange
      - Audit.SharePoint
      - Audit.General
      required: true
    description: Starts a subscription to a given content type
    name: ms-management-activity-start-subscription
  - arguments:
    - auto: PREDEFINED
      description: The content type to unsubscribe from.
      name: content_type
      predefined:
      - Audit.AzureActiveDirectory
      - Audit.Exchange
      - Audit.SharePoint
      - Audit.General
      required: true
    description: Stops a subscription to a given content type
    name: ms-management-activity-stop-subscription
  - arguments: []
    description: List the content types you are currently subscribed to
    name: ms-management-activity-list-subscriptions
    outputs:
    - contextPath: MicrosoftManagement.Subscription
      description: List of current subscriptions
      type: string
  - arguments:
    - auto: PREDEFINED
      description: The content type for which to receive content.
      name: content_type
      predefined:
      - Audit.AzureActiveDirectory
      - Audit.Exchange
      - Audit.SharePoint
      - Audit.General
      required: true
    - description: 'The earliest time to get content from. If start_time is specified,
        end_time must also be specified. The start_time must be before the end_time,
        can be at most 7 days ago, and has to be within 24 hours from end_time. Required
        format: YYYY-MM-DDTHH-MM-SS. If not specified, start time will be 24 hours
        ago.'
      name: start_time
    - description: 'The latest time to get content from. If end_time is specified,
        start_time must be also specified. The start_time must be before the end_time
        and has to be within 24 hours from start_time. Required format: YYYY-MM-DDTHH-MM-SS.
        If not specified, end_time will be now.'
      name: end_time
    - description: A comma-separated list of the record types to fetch. Content records
        with a record  type that isn't specified will not be fetched. If this field
        is left empty, all record types will be fetched.
      name: record_types_filter
    - description: A comma-separated list of the workloads to fetch. Content records
        with a workload that isn't specified will not be fetched. If this field is
        left empty, all workloads will be fetched.
      name: workloads_filter
    - description: A comma-separated list of the operations to fetch. Content records
        with an operation that isn't specified will not be fetched. If this field
        is left empty, all operations will be fetched.
      name: operations_filter
    description: Returns all content of a specific content type.
    name: ms-management-activity-list-content
    outputs:
    - contextPath: MicrosoftManagement.ContentRecord.ID
      description: The ID of the record.
      type: number
    - contextPath: MicrosoftManagement.ContentRecord.CreationTime
      description: The creation time of the record.
      type: date
    - contextPath: MicrosoftManagement.ContentRecord.RecordType
      description: The type of the record.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.Operation
      description: The operation described in the record.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.UserType
      description: The type of the related user.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.OrganizationID
      description: The ID of the organization relevant to the record.
      type: number
    - contextPath: MicrosoftManagement.ContentRecord.UserKey
      description: The key of the related user.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.ClientIP
      description: The IP of the record's client.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.Scope
      description: The scope of the record.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.Workload
      description: The workload of the record.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.ResultsStatus
      description: The results status of the record.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.ObjectID
      description: The ID of the record's object.
      type: string
    - contextPath: MicrosoftManagement.ContentRecord.UserID
      description: The ID of the record's user.
      type: string
  dockerimage: demisto/pyjwt3:1.0.0.4946
  isfetch: true
  runonce: false
  script: |2


    import jwt
    import json
    import requests

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    # CONSTANTS
    DATE_FORMAT = '%Y-%m-%dT%H:%M:%S'
    APP_NAME = 'ms-management-api'

    CONTENT_TYPE_TO_TYPE_ID_MAPPING = {
        'ExchangeAdmin': 1,
        'ExchangeItem': 2,
        'ExchangeItemGroup': 3,
        'SharePoint': 4,
        'SharePointFileOperation': 6,
        'AzureActiveDirectory': 8,
        'AzureActiveDirectoryAccountLogon': 9,
        'DataCenterSecurityCmdlet': 10,
        'ComplianceDLPSharePoint': 11,
        'Sway': 12,
        'ComplianceDLPExchange': 13,
        'SharePointSharingOperation': 14,
        'AzureActiveDirectoryStsLogon': 15,
        'SecurityComplianceCenterEOPCmdlet': 18,
        'PowerBIAudit': 20,
        'CRM': 21,
        'Yammer': 22,
        'SkypeForBusinessCmdlets': 23,
        'Discovery': 24,
        'MicrosoftTeams': 25,
        'ThreatIntelligence': 28,
        'MailSubmission': 29,
        'MicrosoftFlow': 30,
        'AeD': 31,
        'MicrosoftStream': 32,
        'ComplianceDLPSharePointClassification': 33,
        'Project': 35,
        'SharePointListOperation': 36,
        'DataGovernance': 38,
        'SecurityComplianceAlerts': 40,
        'ThreatIntelligenceUrl': 41,
        'SecurityComplianceInsights': 42,
        'WorkplaceAnalytics': 44,
        'PowerAppsApp': 45,
        'ThreatIntelligenceAtpContent': 47,
        'TeamsHealthcare': 49,
        'DataInsightsRestApiAudit': 52,
        'SharePointListItemOperation': 54,
        'SharePointContentTypeOperation': 55,
        'SharePointFieldOperation': 56,
        'AirInvestigation': 64,
        'Quarantine': 65,
        'MicrosoftForms': 66
    }
    # Transferring content types to lowercase to prevent user errors (such as 'quarantine' instead of 'Quarantine')
    CONTENT_TYPE_TO_TYPE_ID_MAPPING = {key.lower(): value for key, value in CONTENT_TYPE_TO_TYPE_ID_MAPPING.items()}


    class Client(BaseClient):
        """
        Client will implement the service API, and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        def __init__(self, base_url: str, verify: bool,
                     proxy: bool, self_deployed, refresh_token, auth_and_token_url,
                     enc_key, auth_code, tenant_id):
            super().__init__(base_url=base_url, verify=verify, proxy=proxy)
            self.tenant_id = tenant_id
            self.suffix_template = '{}/activity/feed/subscriptions/{}'
            self.access_token = None
            self.self_deployed = self_deployed
            self.refresh_token = refresh_token
            self.auth_and_token_url = auth_and_token_url
            self.enc_key = enc_key
            self.ms_client = MicrosoftClient(self_deployed=self.self_deployed,
                                             tenant_id=self.tenant_id,
                                             auth_id=self.auth_and_token_url,
                                             enc_key=self.enc_key,
                                             app_name=APP_NAME,
                                             base_url=base_url,
                                             grant_type=AUTHORIZATION_CODE,
                                             verify=verify,
                                             proxy=proxy,
                                             refresh_token=self.refresh_token,
                                             ok_codes=(200, 201, 202, 204),
                                             scope='',
                                             auth_code=auth_code,
                                             resource='https://manage.office.com',
                                             token_retrieval_url='https://login.windows.net/common/oauth2/token')

        def get_access_token_data(self):
            access_token_jwt = self.ms_client.get_access_token()
            token_data = jwt.decode(access_token_jwt, verify=False)
            return access_token_jwt, token_data

        def get_authentication_string(self):
            return f'Bearer {self.access_token}'

        def get_blob_data_request(self, blob_url):
            auth_string = self.get_authentication_string()
            headers = {
                'Content-Type': 'application/json',
                'Authorization': auth_string
            }
            response = self._http_request(
                method='GET',
                url_suffix='',
                full_url=blob_url,
                headers=headers
            )
            return response

        def list_content_request(self, content_type, start_time, end_time):
            auth_string = self.get_authentication_string()
            headers = {
                'Authorization': auth_string
            }
            params = {
                'contentType': content_type
            }

            if start_time and end_time:
                params['startTime'] = start_time
                params['endTime'] = end_time

            response = self._http_request(
                method='GET',
                url_suffix=self.suffix_template.format(self.tenant_id, 'content'),
                headers=headers,
                params=params
            )
            return response

        def list_subscriptions_request(self):
            auth_string = self.get_authentication_string()
            headers = {
                'Authorization': auth_string
            }
            response = self._http_request(
                method='GET',
                url_suffix=self.suffix_template.format(self.tenant_id, 'list'),
                headers=headers
            )
            return response

        def start_or_stop_subscription_request(self, content_type, start_or_stop_suffix):

            auth_string = self.get_authentication_string()
            headers = {
                'Authorization': auth_string
            }
            params = {
                'contentType': content_type
            }
            response = self._http_request(
                method='POST',
                url_suffix=self.suffix_template.format(self.tenant_id, start_or_stop_suffix),
                headers=headers,
                params=params,
                ok_codes=(200, 201, 202, 203, 204),
                return_empty_response=True
            )
            return response


    def test_module(client):
        params = demisto.params()
        fetch_delta = params.get('first_fetch_delta', '10 minutes')
        user_input_fetch_start_date = parse_date_range(fetch_delta)
        if datetime.now() - timedelta(days=7) - timedelta(minutes=5) >= user_input_fetch_start_date:
            return 'Error: first fetch time delta should not be over one week.'
        if client.self_deployed and not params.get('auth_code'):
            return 'Error: in the self_deployed authentication flow the authentication code parameter cannot be empty.'
        return 'The basic parameters are ok, authentication cannot be checked using the test module'


    def get_start_or_stop_subscription_human_readable(content_type, start_or_stop):
        if start_or_stop == 'start':
            human_readable = f'Successfully started subscription to content type: {content_type}'
        else:
            human_readable = f'Successfully stopped subscription to content type: {content_type}'
        return human_readable


    def get_start_or_stop_subscription_context(content_type, start_or_stop):
        is_subscription_enabled = True if start_or_stop == 'start' else False
        subscription_context = {
            'ContentType': content_type,
            'Enabled': is_subscription_enabled
        }
        entry_context = {
            'MicrosoftManagement.Subscription(val.ContentType && val.ContentType === obj.ContentType)': subscription_context
        }
        return entry_context


    def start_or_stop_subscription_command(client, args, start_or_stop):
        content_type = args.get('content_type')
        client.start_or_stop_subscription_request(content_type, start_or_stop)
        human_readable = get_start_or_stop_subscription_human_readable(content_type, start_or_stop)
        entry_context = get_start_or_stop_subscription_context(content_type, start_or_stop)

        return_outputs(
            readable_output=human_readable,
            outputs=entry_context,
            raw_response={}
        )


    def get_enabled_subscriptions_content_types(enabled_subscriptions):
        enabled_subscriptions_content_types = [subscription.get('contentType') for subscription in enabled_subscriptions
                                               if subscription.get('status') == 'enabled']
        return enabled_subscriptions_content_types


    def get_subscriptions_context(enabled_subscriptions):
        subscriptions_contexts = []
        for subscription_content_type in enabled_subscriptions:
            subscription_context = {
                'ContentType': subscription_content_type,
                'Enabled': True
            }
            subscriptions_contexts.append(subscription_context)
        return subscriptions_contexts


    def list_subscriptions_command(client):
        subscriptions = client.list_subscriptions_request()
        enabled_subscriptions_content_types = get_enabled_subscriptions_content_types(
            subscriptions)  # Subscriptions are defined by their content type
        enabled_subscriptions_context = get_subscriptions_context(enabled_subscriptions_content_types)
        human_readable = tableToMarkdown('Current Subscriptions', enabled_subscriptions_content_types,
                                         headers='Current Subscriptions')
        entry_context = {
            'MicrosoftManagement.Subscription(val.ContentType && val.ContentType === obj.ContentType)': enabled_subscriptions_context
        }
        return_outputs(
            readable_output=human_readable,
            raw_response=enabled_subscriptions_context,
            outputs=entry_context
        )


    def build_event_context(event_record):
        event_context = {
            'CreationTime': event_record.get('CreationTime'),
            'ID': event_record.get('Id'),
            'RecordType': event_record.get('RecordType'),
            'Operation': event_record.get('Operation'),
            'OrganizationID': event_record.get('OrganizationId'),
            'UserType': event_record.get('UserType'),
            'UserKey': event_record.get('UserKey'),
            'Workload': event_record.get('Workload'),
            'ResultsStatus': event_record.get('ResultStatus'),
            'ObjectID': event_record.get('ObjectId'),
            'UserID': event_record.get('UserId'),
            'ClientIP': event_record.get('ClientIP'),
            'Scope': event_record.get('Scope'),
        }

        # Remove keys with None value
        event_context = assign_params(**event_context)
        return event_context


    def get_content_records_context(content_records):
        content_records_context = []
        for content_record in content_records:
            record_context = build_event_context(content_record)
            content_records_context.append(record_context)
        return content_records_context


    def get_all_content_type_records(client, content_type, start_time, end_time):
        content_blobs = client.list_content_request(content_type, start_time, end_time)
        # The list_content request returns a list of content records, each containing a url that holds the actual data
        content_uris = [content_blob.get('contentUri') for content_blob in content_blobs]
        content_records = []
        for uri in content_uris:
            content_records_in_uri = client.get_blob_data_request(uri)
            content_records.extend(content_records_in_uri)
        return content_records


    def create_events_human_readable(events_context, content_type):
        headers = ['ID', 'CreationTime', 'Workload', 'Operation']
        content_header = f'Content for content type {content_type}'
        human_readable = tableToMarkdown(content_header, events_context, headers=headers)
        return human_readable


    def get_filter_accepted_values_list(filtered_field, filter_data):
        filter_accepted_values_string = filter_data.get(filtered_field)
        if filter_accepted_values_string:
            return filter_accepted_values_string.split(',')
        return None


    def verify_record_type_is_legal(record_type):
        record_type_lowercase = record_type.lower()
        if record_type_lowercase not in CONTENT_TYPE_TO_TYPE_ID_MAPPING:
            return_error(f'Error: {record_type} is not a legal record type in the Microsoft Management Activity API.')


    def record_types_to_type_ids(record_types_to_fetch):
        record_type_ids_to_fetch = []

        for record_type in record_types_to_fetch:
            verify_record_type_is_legal(record_type)
            # To lowercase to avoid user errors, such as 'quarantine' and 'Quarantine'
            record_type_lowercase = record_type.lower()
            record_type_id = CONTENT_TYPE_TO_TYPE_ID_MAPPING[record_type_lowercase]
            record_type_ids_to_fetch.append(record_type_id)
        return record_type_ids_to_fetch


    def does_record_match_filters(record, filter_accepted_record_type_ids, filter_accepted_workloads,
                                  filter_accepted_operations):
        should_filter_by_record_types = filter_accepted_record_type_ids is not None
        record_matches_record_type_filter = not should_filter_by_record_types or record.get('RecordType') in \
            filter_accepted_record_type_ids

        should_filter_by_workloads = filter_accepted_workloads is not None
        record_matches_workloads_filter = not should_filter_by_workloads or record.get('Workload') in \
            filter_accepted_workloads

        should_filter_by_operations = filter_accepted_operations is not None
        record_matches_operations_filter = not should_filter_by_operations or record.get('Operation') in \
            filter_accepted_operations

        return record_matches_record_type_filter and record_matches_workloads_filter and record_matches_operations_filter


    def filter_records(content_records, filter_data):
        filter_accepted_workloads = get_filter_accepted_values_list('workloads_filter', filter_data)
        filter_accepted_operations = get_filter_accepted_values_list('operations_filter', filter_data)
        filter_accepted_record_types = get_filter_accepted_values_list('record_types_filter', filter_data)

        # User specifies the record types by type name, but the API returns the record types by ID.
        # Therefore we transform the names to IDs.
        filter_accepted_record_type_ids = record_types_to_type_ids(
            filter_accepted_record_types) if filter_accepted_record_types else None

        filtered_records = []
        for record in content_records:
            if does_record_match_filters(record, filter_accepted_record_type_ids, filter_accepted_workloads,
                                         filter_accepted_operations):
                filtered_records.append(record)
        return filtered_records


    def list_content_command(client, args):
        content_type = args['content_type']
        start_time = args.get('start_time')
        end_time = args.get('end_time')

        content_records = get_all_content_type_records(client, content_type, start_time, end_time)
        filtered_content_records = filter_records(content_records, args)
        content_records_context = get_content_records_context(filtered_content_records)
        human_readable = create_events_human_readable(content_records_context, content_type)
        return_outputs(
            readable_output=human_readable,
            outputs={
                'MicrosoftManagement.ContentRecord(val.ID && val.ID === obj.ID)': content_records_context
            },
            raw_response=content_records
        )


    def get_content_types_to_fetch(client):
        content_types_to_fetch = demisto.params().get('content_types_to_fetch')
        if not content_types_to_fetch:
            # Was not supplied by the user, so we will return all content types the user is subscribed to
            subscriptions = client.list_subscriptions_request()
            content_types_to_fetch = get_enabled_subscriptions_content_types(
                subscriptions)
        return content_types_to_fetch


    def get_fetch_end_time_based_on_start_time(fetch_start_datetime):
        is_fetch_start_time_over_10_minutes_ago = (datetime.now() - timedelta(minutes=10) >= fetch_start_datetime)
        if is_fetch_start_time_over_10_minutes_ago:
            # Start and end time can't be over 24, so the fetch will end 24  hours after it's start.
            fetch_end_datetime = fetch_start_datetime + timedelta(minutes=10)
        else:
            fetch_end_datetime = datetime.now()
        return fetch_end_datetime


    def get_fetch_start_and_end_time(last_run, first_fetch_datetime):
        if not last_run:
            fetch_start_datetime = first_fetch_datetime
        else:
            last_fetch = last_run.get('last_fetch')
            fetch_start_datetime = datetime.strptime(last_fetch, DATE_FORMAT)

        fetch_end_datetime = get_fetch_end_time_based_on_start_time(fetch_start_datetime)

        # The API expects strings of format YYYY:DD:MMTHH:MM:SS
        fetch_start_time_str = fetch_start_datetime.strftime(DATE_FORMAT)
        fetch_end_time_str = fetch_end_datetime.strftime(DATE_FORMAT)
        return fetch_start_time_str, fetch_end_time_str


    def get_all_content_records_of_specified_types(client, content_types_to_fetch, start_time, end_time):
        all_content_records = []
        content_types_to_fetch = content_types_to_fetch.split(',') if type(content_types_to_fetch) is str \
            else content_types_to_fetch
        for content_type in content_types_to_fetch:
            content_records_of_current_type = get_all_content_type_records(client, content_type, start_time, end_time)
            all_content_records.extend(content_records_of_current_type)
        return all_content_records


    def content_records_to_incidents(content_records, start_time, end_time):
        incidents = []
        start_time_datetime = datetime.strptime(start_time, DATE_FORMAT)
        latest_creation_time_datetime = start_time_datetime

        record_ids_already_found = set()

        for content_record in content_records:
            incident_creation_time_str = content_record['CreationTime']
            incident_creation_time_datetime = datetime.strptime(incident_creation_time_str, DATE_FORMAT)

            if incident_creation_time_datetime < start_time_datetime:
                pass
            incident_creation_time_in_incidents_format = incident_creation_time_str + 'Z'
            record_id = content_record['Id']
            incident = {
                'name': f'Microsoft Management Activity: {record_id}',
                'occurred': incident_creation_time_in_incidents_format,
                'rawJSON': json.dumps(content_record)
            }

            if incident['name'] in record_ids_already_found:
                pass
            else:
                record_ids_already_found.add(incident['name'])

            incidents.append(incident)
            if incident_creation_time_datetime > latest_creation_time_datetime:
                latest_creation_time_datetime = incident_creation_time_datetime

        latest_creation_time_str = datetime.strftime(latest_creation_time_datetime, DATE_FORMAT)

        if len(content_records) == 0 or latest_creation_time_str == start_time:
            latest_creation_time_str = end_time

        return incidents, latest_creation_time_str


    def fetch_incidents(client, last_run, first_fetch_datetime):
        start_time, end_time = get_fetch_start_and_end_time(last_run, first_fetch_datetime)
        content_types_to_fetch = get_content_types_to_fetch(client)
        content_records = get_all_content_records_of_specified_types(client, content_types_to_fetch, start_time, end_time)
        filtered_content_records = filter_records(content_records, demisto.params())
        incidents, last_fetch = content_records_to_incidents(filtered_content_records, start_time, end_time)
        next_run = {'last_fetch': last_fetch}
        return next_run, incidents


    def main():
        base_url = demisto.params().get('base_url', 'https://manage.office.com/api/v1.0/')
        verify_certificate = not demisto.params().get('insecure', False)

        first_fetch_delta = demisto.params().get('first_fetch_delta', '10 minutes').strip()
        first_fetch_datetime, _ = parse_date_range(first_fetch_delta)

        proxy = demisto.params().get('proxy', False)

        LOG(f'Command being called is {demisto.command()}')
        try:
            args = demisto.args()
            params = demisto.params()
            refresh_token = params.get('refresh_token', '')
            self_deployed = params.get('self_deployed', False)
            tenant_id = refresh_token if self_deployed else ''
            auth_id = params['auth_id']
            enc_key = params['enc_key']

            refresh_token = (demisto.getIntegrationContext().get('current_refresh_token') or refresh_token)

            client = Client(
                base_url=base_url,
                tenant_id=tenant_id,
                verify=verify_certificate,
                proxy=proxy,
                self_deployed=self_deployed,
                refresh_token=refresh_token,
                auth_and_token_url=auth_id,
                enc_key=enc_key,
                auth_code=params.get('auth_code', '')
            )

            access_token, token_data = client.get_access_token_data()
            client.access_token = access_token
            client.tenant_id = token_data['tid']

            if demisto.command() == 'test-module':
                result = test_module(client)
                demisto.results(result)

            elif demisto.command() == 'fetch-incidents':
                next_run, incidents = fetch_incidents(
                    client=client,
                    last_run=demisto.getLastRun(),
                    first_fetch_datetime=first_fetch_datetime)

                demisto.setLastRun(next_run)
                demisto.incidents(incidents)

            elif demisto.command() == 'ms-management-activity-start-subscription':
                start_or_stop_subscription_command(client, args, 'start')

            elif demisto.command() == 'ms-management-activity-stop-subscription':
                start_or_stop_subscription_command(client, args, 'stop')

            elif demisto.command() == 'ms-management-activity-list-subscriptions':
                list_subscriptions_command(client)

            elif demisto.command() == 'ms-management-activity-list-content':
                list_content_command(client, args)

        # Log exceptions
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}')



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.import traceback




    import requests
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Tuple

    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line


    class MicrosoftClient(BaseClient):

        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str = '',
                     token_retrieval_url: str = 'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = 'https://graph.microsoft.com/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str = '',
                     verify: bool = True,
                     self_deployed: bool = False,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]

            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id)
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope
                self.redirect_uri = redirect_uri

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify

        def http_request(self, *args, resp_type='json', headers=None, return_empty_response=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            if headers:
                default_headers.update(headers)

            response = super()._http_request(   # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))

            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self):
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            refresh_token = integration_context.get('current_refresh_token', '')
            valid_until = integration_context.get('valid_until')
            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            auth_type = self.auth_type
            if auth_type == OPROXY_AUTH_TYPE:
                access_token, expires_in, refresh_token = self._oproxy_authorize()
            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            integration_context = {
                'access_token': access_token,
                'current_refresh_token': refresh_token,
                'valid_until': time_now + expires_in,
            }

            demisto.setIntegrationContext(integration_context)
            return access_token

        def _oproxy_authorize(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key)
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self, refresh_token: str = ''):
            if self.grant_type == AUTHORIZATION_CODE:
                return self._get_self_deployed_token_auth_code(refresh_token)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                return self._get_self_deployed_token_client_credentials()

        def _get_self_deployed_token_client_credentials(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.scope:
                data['scope'] = self.scope
            if self.resource:
                data['resource'] = self.resource

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(self, refresh_token: str = '') -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'resource': self.resource,
                'redirect_uri': self.redirect_uri
            }
            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            # refresh_token = response_json.get('refresh_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
                brand_name = calling_context.get('IntegrationBrand', '')
                instance_name = calling_context.get('IntegrationInstance', '')
                headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
                headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
                if hasattr(demisto, 'demistoVersion'):
                    demisto_version = demisto.demistoVersion()
                    headers['X-Content-Server-Version'] = '{}-{}'.format(demisto_version.get('version'),
                                                                         demisto_version.get("buildNumber"))
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers



    if __name__ in ['__main__', '__builtin__', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
