category: Analytics & SIEM
commonfields:
  id: Cortex Data Lake
  version: -1
configuration:
- defaultvalue: ""
  display: Token
  name: refresh_token
  required: true
  type: 4
- defaultvalue: ""
  display: ID
  name: reg_id
  required: true
  type: 4
- defaultvalue: ""
  display: Key
  name: auth_key
  required: true
  type: 4
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: 24 hours
  display: First fetch time (<number> <time unit>, e.g., 12 hours, 7 days, 3 months,
    1 year)
  name: first_fetch_timestamp
  required: false
  type: 0
- defaultvalue: ""
  display: Severity of events to fetch (Firewall)
  name: firewall_severity
  options:
  - all
  - Critical
  - High
  - Medium
  - Low
  - Informational
  - Unused
  required: false
  type: 16
- defaultvalue: ""
  display: Subtype of events to fetch (Firewall)
  name: firewall_subtype
  options:
  - all
  - attack
  - url
  - virus
  - spyware
  - vulnerability
  - file
  - scan
  - flood
  - packet
  - resource
  - data
  - url-content
  - wildfire
  - extpcap
  - wildfire-virus
  - http-hdr-insert
  - http-hdr
  - email-hdr
  - spyware-dns
  - spyware-wildfire-dns
  - spyware-wpc-dns
  - spyware-custom-dns
  - spyware-cloud-dns
  - spyware-raven
  - spyware-wildfire-raven
  - spyware-wpc-raven
  - wpc-virus
  - sctp
  required: false
  type: 16
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- additionalinfo: |-
    How many incidents will be fetched per query.
    Caution: high number could create overload. Default is 10.
  defaultvalue: "10"
  display: Incidents fetched per query
  name: limit
  required: false
  type: 0
- defaultvalue: "false"
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: "false"
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Palo Alto Networks Cortex Data Lake provides cloud-based, centralized
  log storage and aggregation for your on premise, virtual (private cloud and public
  cloud) firewalls, for Prisma Access, and for cloud-delivered services such as Cortex
  XDR
detaileddescription: "## Overview\n---\n\nPalo Alto Networks Cortex Data Lake provides
  cloud-based, centralized log storage and aggregation for your on premise, virtual
  (private cloud and public cloud) firewalls, for Prisma Access, and for cloud-delivered
  services such as Cortex XDR\nThis integration was integrated and tested with version
  2 of Cortex Data Lake\n\n\n\n---\n\n## Configure Cortex Data Lake on Demisto\n\n---\n\n1.
  Go to the [HUB](https://apps.paloaltonetworks.com/apps) and select the `Cortexâ„¢
  XSOAR` app\n2. In the War Room, run the command `!GetLicenseID` to get the `license
  ID`.\n3. Go to __Settings__ > __ABOUT__ > __License__ to get the `Customer Name`.\n4.
  Insert the `license ID` and the `Customer Name` in the required fields and complete
  the authentication process in order  \nto get the __Authentication Token__  __Registration
  ID__ __Encryption Key__\n5. Navigate to __Settings__ > __Integrations__ > __Servers
  & Services__.\n6. Search for Palo Alto Networks Cortex v2.\n7. Click __Add instance__
  to create and configure a new integration instance.\n    * __Name__: a textual name
  for the integration instance.\n    * __Authentication Token__: From the authentication
  process\n    * __Registration ID__: From the authentication process\n    * __Encryption
  Key__: From the authentication process\n    * __proxy__: Use system proxy settings\n
  \   * __insecure__: Trust any certificate (not secure)\n    * __Fetch incidents__:
  Whether to fetch incidents or not\n    * __first_fetch_timestamp__: First fetch
  time (<number> <time unit>, e.g., 12 hours, 7 days, 3 months, 1 year)\n    * __Severity
  of events to fetch (Firewall)__: Select from all,Critical,High,Medium,Low,Informational,Unused\n
  \   * __Subtype of events to fetch (Firewall)__: Select from all,attack,url,virus,spyware,vulnerability,file,scan,flood,packet,resource,data,url-content,wildfire,extpcap,wildfire-virus,http-hdr-insert,http-hdr,email-hdr,spyware-dns,spyware-wildfire-dns,spyware-wpc-dns,spyware-custom-dns,spyware-cloud-dns,spyware-raven,spyware-wildfire-raven,spyware-wpc-raven,wpc-virus,sctp\n8.
  Click __Test__ to validate the URLs, token, and connection.\n"
display: Cortex Data Lake
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAACXBIWXMAAAsSAAALEgHS3X78AAAD6klEQVR4nO2cS24bMQyGyaL75AbJCeo5QIH6BnVPkOkN3BPER8gN4tzA3XQbB+gBHHTbRbzq1kH3ZaGA4ygUNaPxxBOA4AcIqPWgHv9QosZOkYjAscs719Y2LrBxXGDjuMDGcYGN4wIbxwU2jgtsHBfYOC6wcVxg47jAxnGBjeMCG+f9W04PEacAENIDES2TCs7wNR77+2BEPAeABQBcRNl3RDRNKjuDGdWDEbEGgCsAOEkKnaPQW2BErHhbPY2ydwCwJqJN0uCluNdJQf/+Q79VUiAgonWS+WyjEuMvIRwjDwPs7OL14eMpJrGfm2+YGyLOAeAPAPwloh9Jb1HlogQAQaAwAGpJD5otfiC0dksuW/LnYH+u2SiwpaVg91SxsVbqdqXFQDtr0bYW5cFJKlEniLsR9eZc9hsA/gHAL22d9ja0TKWT4olkbMgHYxNPhs9kWZ4Ic4DAT7YUG28ucMm8owd/7xBR2UdOH7R1alLJFh06+STybnhyQbhz3kJmAHCmbDG1yH8MdbXtKGICACsWs4tvvDDNw1ixdzR9TsJ2KLbsJY8/5jL6951Snt3ymS3bzZHMl4gWHHQ2Aed+3ogoA9EbIqqjtj8z/SSdZBMvVvwEPQnaUn+m5MmnUPME+SQ3aarUlR5cUifpU2nTq77iwYmH9jj+5BrJneFg210ePBOf6zbPI6JVkpl64VVSI8+swHM0kgBGqfPanLPXSTrv+MEzOWCbcFa8Y94rOhTTK4pui0xbeLFtE9EuXzWhM1oODwwixjYrcQ175G3v2JyJbb7hrmPrbpjyUSOPs2nPNXtBL4FDyD6ksyMxaTE7eIFGRIthTnjHqw8dRte7aLkw86RGN9u4BgcVpWTv1RH37CVbkf+d44USG69BeBuHSuoMFDveEVxw+UF0CbxkL2i4DOcMX77jAZ6GQSCidtbJbb3PYEu21jkvYsViN3wecnaNBSLOhLhhvb+Idb8+WGQt8hIRnryQxxH1Wl7EC9vLC70WRa8y48lG0XxN2rX1lUuvEEUfcg+uxHj3LzuUMuIgNxlHW2otFCLJztSUaS9fdOyEMFLgdY8XHdPSRWtLYwusjDN5GBXnKJpLn2tS4+VLRFxxhzMlUt3yZHNRdmh3G30ObW8RsYkwm3M5bLFXHdeKHZ+58ed4rBt+zxtfxxYF23VsUztqNPqc77LuQuQtZbzA6w7iWAtHZF0aOI72dWFHIOFfFx6J0X7RwV75VQQPjhWB4Vnkit9lOyPwpn/h7z/ZOT7+XzgYx39VaRwX2DgusHFcYOO4wMZxgY3jAhvHBTaOC2wcF9g4LrBxXGDjuMDGcYEtAwD/AbjPSozwVJX9AAAAAElFTkSuQmCC
name: Cortex Data Lake
script:
  commands:
  - arguments:
    - defaultValue: SELECT * FROM `firewall.traffic` limit 10
      description: 'A free-text SQL query. For example, query="SELECT * FROM `firewall.traffic`
        limit 10". There are multiple tables in Loggings, for example: threat, traffic,
        and so on. Refer to the Cortex Logging service schema reference for the full
        list.'
      name: query
    - defaultValue: "100"
      description: The number of logs to return.
      name: limit
    description: Runs a query on the Cortex logging service.
    execution: true
    name: cdl-query-logs
    outputs:
    - contextPath: CDL.Logging.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.CharacteristicOfApp
      description: Identifies the behaviorial characteristic of the application associated
        with the network traffic.
      type: Number
    - contextPath: CDL.Logging.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.IsNat
      description: Indicates if the firewall is performing network address translation
        (NAT) for the logged traffic.
      type: number
    - contextPath: CDL.Logging.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
      type: String
    - contextPath: CDL.Logging.NatSource
      description: If source NAT was performed, the post-NAT source IP address.
      type: String
    - contextPath: CDL.Logging.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.FileSHA256
      description: The binary hash (SHA256) of the file sent for virus analysis.
      type: String
    - contextPath: CDL.Logging.FileName
      description: The name of the infected file.
      type: String
    - contextPath: CDL.Logging.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
  - arguments:
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00"
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00"
      name: end_time
    - defaultValue: "10"
      description: The number of logs to return.
      name: limit
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 hours, 7 days, 3
        months, 1 year)
      name: time_range
      predefined:
      - minutes
      - days
      - weeks
    description: Runs a query on the Cortex logging service, according to preset queries.
    name: cdl-get-critical-threat-logs
    outputs:
    - contextPath: CDL.Logging.Threat.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Threat.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1.
      type: String
    - contextPath: CDL.Logging.Threat.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategoryis related
        to the application's category, which is identified in category_of_app.
      type: String
    - contextPath: CDL.Logging.Threat.PcapID
      description: Packet capture (pcap) ID. This is used to correlate threat pcap
        files with extended pcaps taken as a part of the session flow. All threat
        logs will contain either a pcap_id of 0 (no associated pcap) , or an ID referencing
        the extended pcap file.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
        The IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.Flags
      description: Bit field which provides details on the session, such as whether
        the session use IPv6, whether the session was denied due to a URL filtering
        rule, and/or whether the log corresponds to a transaction within an HTTP proxy
        session.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatID
      description: Numerical identifier for the threat type. All threats encountered
        by Palo Alto Networks firewalls are assigned a unique identifier
      type: String
    - contextPath: CDL.Logging.Threat.NatSource
      description: If source NAT was performed, the post-NAT source IP address. The
        IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.IsURLDenied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.Threat.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Threat.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
    - contextPath: CDL.Logging.Threat.IsPhishing
      description: ndicates whether enterprise credentials were submitted by an end
        user.
      type: Boolean
    - contextPath: CDL.Logging.Threat.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Threat.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Threat.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: Number
    - contextPath: CDL.Logging.Threat.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Threat.CharacteristicOfApp
      description: Identifies the behaviorial characteristic of the application associated
        with the network traffic.
      type: Unknown
    - contextPath: CDL.Logging.Threat.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.Threat.Vsys
      description: String representation of the unique identifier for a virtual system
        on a Palo Alto Networks firewall.
      type: String
    - contextPath: CDL.Logging.Threat.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.Threat.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Threat.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Threat.RuleMatched
      description: Unique identifier for the security policy rule that the network
        traffic matched.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatCategory
      description: Threat category of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Threat.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.Threat.Direction
      description: Indicates the direction of the attack.
      type: String
    - contextPath: CDL.Logging.Threat.FileName
      description: The name of the file that is blocked.
      type: String
    - contextPath: CDL.Logging.Threat.VendorSeverity
      description: Severity associated with the event.
      type: String
    - contextPath: CDL.Logging.Threat.LogTime
      description: Time the log was received in Cortex Data Lake.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, this is its serial number.
      type: String
    - contextPath: CDL.Logging.Threat.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: Number
    - contextPath: CDL.Logging.Threat.URLDomain
      description: The name of the internet domain that was visited in this session.
      type: String
    - contextPath: CDL.Logging.Threat.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Threat.SourcePort
      description: Source port utilized by the session.
      type: Number
  - arguments:
    - defaultValue: '''1970-01-01 00:00:00'''
      description: Query start time. For example, start_time="2018-04-26 00:00:00"
      name: start_time
    - description: Query end time. For example, end_time="2018-04-26 00:00:00"
      name: end_time
    - defaultValue: "10"
      description: Amount of logs.
      name: limit
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 hours, 7 days, 3
        months, 1 year)
      name: time_range
      predefined:
      - minutes
      - days
      - weeks
    description: Runs a query on the Cortex logging service, according to preset queries.
    name: cdl-get-social-applications
    outputs:
    - contextPath: CDL.Logging.Traffic.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSourcePort
      description: Post-NAT source port.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Traffic.Packets
      description: Number of total packets (transmit and receive) seen for the session.
      type: String
    - contextPath: CDL.Logging.Traffic.CharacteristicOfApp
      description: Identifies the behaviorial characteristic of the application associated
        with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.Vsys
      description: Virtual system associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1.
      type: String
    - contextPath: CDL.Logging.Traffic.LogTime
      description: Time the log was received in Cortex Data Lake.
      type: date
    - contextPath: CDL.Logging.Traffic.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category,
      type: String
    - contextPath: CDL.Logging.Traffic.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestinationPort
      description: Post-NAT destination port.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalTimeElapsed
      description: Total time taken for the network session to complete.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceName
      description: Device name of the source of the log
      type: String
    - contextPath: CDL.Logging.Traffic.Subtype
      description: The log sub type.
      type: String
    - contextPath: CDL.Logging.Traffic.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Traffic.TunneledApp
      description: Is app tunneled.
      type: String
    - contextPath: CDL.Logging.Traffic.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionEndReason
      description: The reason a session terminated.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSource
      description: If source NAT was performed, the post-NAT source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionStartIP
      description: Time when the session was established.
      type: date
    - contextPath: CDL.Logging.Traffic.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: date
    - contextPath: CDL.Logging.Traffic.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceID
      description: D that uniquely identifies the source of the log. If the source
        is a firewall, this is its serial number.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalBytes
      description: Number of total bytes (transmit and receive).
      type: String
    - contextPath: CDL.Logging.Traffic.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: String
    - contextPath: CDL.Logging.Traffic.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Traffic.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Traffic.SourcePort
      description: Source port utilized by the session.
      type: String
    - contextPath: CDL.Logging.Traffic.Tunnel
      description: Type of tunnel.
      type: String
  - arguments:
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00"
      name: start_time
    - description: The query end time. For example, end_time="2018-04-26 00:00:00"
      name: end_time
    - defaultValue: "10"
      description: The number of logs to return.
      name: limit
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 hours, 7 days, 3
        months, 1 year)
      name: time_range
      predefined:
      - minutes
      - days
      - weeks
    - description: The SHA256 hash of the file for the query. For example, SHA256="503ca1a4fc0d48b18c0336f544ba0f0abf305ae3a3f49b3c2b86b8645d6572dc"
        would return all logs associated with this file.
      name: SHA256
      required: true
    description: Runs a query on the threat table with the query 'SELECT * FROM `firewall.threat`
      WHERE file_sha_256 = <file_hash>'
    name: cdl-search-by-file-hash
    outputs:
    - contextPath: CDL.Logging.Threat.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Threat.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1.
      type: String
    - contextPath: CDL.Logging.Threat.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategoryis related
        to the application's category, which is identified in category_of_app.
      type: String
    - contextPath: CDL.Logging.Threat.PcapID
      description: Packet capture (pcap) ID. This is used to correlate threat pcap
        files with extended pcaps taken as a part of the session flow. All threat
        logs will contain either a pcap_id of 0 (no associated pcap) , or an ID referencing
        the extended pcap file.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
        The IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.Flags
      description: Bit field which provides details on the session, such as whether
        the session use IPv6, whether the session was denied due to a URL filtering
        rule, and/or whether the log corresponds to a transaction within an HTTP proxy
        session.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatID
      description: Numerical identifier for the threat type. All threats encountered
        by Palo Alto Networks firewalls are assigned a unique identifier
      type: String
    - contextPath: CDL.Logging.Threat.NatSource
      description: If source NAT was performed, the post-NAT source IP address. The
        IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.IsURLDenied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.Threat.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Threat.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
    - contextPath: CDL.Logging.Threat.IsPhishing
      description: ndicates whether enterprise credentials were submitted by an end
        user.
      type: Boolean
    - contextPath: CDL.Logging.Threat.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Threat.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Threat.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: Number
    - contextPath: CDL.Logging.Threat.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Threat.CharacteristicOfApp
      description: Identifies the behaviorial characteristic of the application associated
        with the network traffic.
      type: Unknown
    - contextPath: CDL.Logging.Threat.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.Threat.Vsys
      description: String representation of the unique identifier for a virtual system
        on a Palo Alto Networks firewall.
      type: String
    - contextPath: CDL.Logging.Threat.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.Threat.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Threat.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Threat.RuleMatched
      description: Unique identifier for the security policy rule that the network
        traffic matched.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatCategory
      description: Threat category of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Threat.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.Threat.Direction
      description: Indicates the direction of the attack.
      type: String
    - contextPath: CDL.Logging.Threat.FileName
      description: The name of the file that is blocked.
      type: String
    - contextPath: CDL.Logging.Threat.VendorSeverity
      description: Severity associated with the event.
      type: String
    - contextPath: CDL.Logging.Threat.LogTime
      description: Time the log was received in Cortex Data Lake.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, this is its serial number.
      type: String
    - contextPath: CDL.Logging.Threat.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: Number
    - contextPath: CDL.Logging.Threat.URLDomain
      description: The name of the internet domain that was visited in this session.
      type: String
    - contextPath: CDL.Logging.Threat.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Threat.SourcePort
      description: Source port utilized by the session.
      type: Number
  - arguments:
    - description: A source IP address or an array of source IPs addresses for which
        to search, for example 1.1.1.1,2.2.2.2.
      name: source_ip
    - description: A rule name or an array of rule names to search.
      name: rule
    - description: A source zone  name or an array of source zone names to search.
      name: from_zone
    - description: A destination zone name or an array of zone names to search.
      name: to_zone
    - description: Source port utilized by the session. Can be port number or an array
        of destination port numbers to search. For example '443' or '443,445'
      name: source_port
    - description: An action name or an array of action names to search.
      name: action
    - description: A free-text query for which to search. This forms the WHERE part
        of the query, for example, !cdl-query-traffic-logs query="source_ip.value
        LIKE '192.168.1.*' AND dest_ip.value='8.8.8.8' And dest_port=1234"
      name: query
    - auto: PREDEFINED
      defaultValue: all
      description: 'The fields that are selected in the query. Selection can be "all"
        (same as *) or a comma saparated list of specific fields in the table. '
      name: fields
      predefined:
      - all
      - vendor_name
      - log_source
      - log_source_id
      - log_source_name
      - customer_id
      - log_time
      - log_source_tz_offset
      - log_type
      - sub_type
      - source_ip
      - source_port
      - dest_ip
      - dest_port
      - protocol
      - action_source
      - bytes_total
      - bytes_received
      - bytes_sent
      - ep_assoc_id
      - chunks_total
      - chunks_received
      - chunks_sent
      - packets_total
      - packets_received
      - packets_sent
      - session_start_time
      - total_time_elapsed
      - session_end_reason
      - traffic_flags
      - url_category
      - action
      - action_flags
      - app
      - app_category
      - characteristics_of_app
      - container_of_app
      - dg_hier_level_1
      - dg_hier_level_2
      - dg_hier_level_3
      - dg_hier_level_4
      - dest_uuid
      - dest_location
      - dest_user
      - dest_user_info
      - is_exported
      - is_forwarded
      - from_zone
      - http2_connection
      - inbound_if
      - inbound_if_details
      - is_saas_app
      - is_dup_log
      - is_prisma_branch
      - is_prisma_mobile
      - log_set
      - monitor_tag_imei
      - nat_dest_port
      - nat_dest
      - nat_source_port
      - nat_source
      - non_standard_dest_port
      - outbound_if
      - outbound_if_details
      - parent_session_id
      - parent_start_time
      - count_of_repeats
      - risk_of_app
      - rule_matched
      - rule_matched_uuid
      - sanctioned_state_of_app
      - sequence_no
      - session_id
      - source_uuid
      - source_location
      - source_user
      - source_user_info
      - app_sub_category
      - technology_of_app
      - time_generated
      - to_zone
      - tunnel
      - tunneled_app
      - tunnelid_imsi
      - users
      - vsys_id
      - vsys
      - vsys_name
      - flags
      - is_decrypt_mirror
      - is_sym_return
      - is_container
      - is_server_to_client
      - is_client_to_server
      - is_transaction
      - is_non_std_dest_port
      - is_captive_portal
      - is_nat
      - is_proxy
      - is_packet_capture
      - is_phishing
      - is_mptcp_on
      - is_recon_excluded
      - is_url_denied
      - is_tunnel_inspected
      - is_source_x_fwded
      - is_ipv6
      - is_decrypted_payload_fwded
      - is_decryption_log
      - is_l7_inspection_b4_session
      - sess_owner_rt_midx
      - session_tracker
      - container_id
      - pod_namespace
      - pod_name
      - source_device_class
      - source_device_vendor
      - source_device_model
      - source_device_os
      - source_device_mac
      - dest_device_class
      - dest_device_vendor
      - dest_device_model
      - dest_device_os
      - dest_device_mac
      - link_change_count
      - policy_id
      - link_switches
      - sdwan_cluster
      - sdwan_device_type
      - sdwan_cluster_type
      - sdwan_site
      - dynusergroup_name
      - ingestion_time
      - record_size
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00"
      name: start_time
    - default: true
      description: The query end time. For example, end_time="2018-04-26 00:00:00".
      name: end_time
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 hours, 7 days, 3
        months, 1 year)
      name: time_range
      predefined:
      - minutes
      - days
      - weeks
    - defaultValue: "5"
      description: The number of logs to return. Default is 5.
      name: limit
    - description: A destination IP address or an array of destination IPs addresses
        for which to search, for example 1.1.1.1,2.2.2.2.
      name: dest_ip
    - description: Destination port utilized by the session. Can be port number or
        an array of destination port numbers to search. For example '443' or '443,445'
      name: dest_port
    description: Searches the Cortex firewall.traffic table. Traffic logs contain
      entries for the end of each network session
    name: cdl-query-traffic-logs
    outputs:
    - contextPath: CDL.Logging.Traffic.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSourcePort
      description: Post-NAT source port.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Traffic.Packets
      description: Number of total packets (transmit and receive) seen for the session.
      type: String
    - contextPath: CDL.Logging.Traffic.CharacteristicOfApp
      description: Identifies the behaviorial characteristic of the application associated
        with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.Vsys
      description: Virtual system associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Traffic.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1.
      type: String
    - contextPath: CDL.Logging.Traffic.LogTime
      description: Time the log was received in Cortex Data Lake.
      type: date
    - contextPath: CDL.Logging.Traffic.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategory is related
        to the application's category,
      type: String
    - contextPath: CDL.Logging.Traffic.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestinationPort
      description: Post-NAT destination port.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.RuleMatched
      description: Name of the security policy rule that the network traffic matched.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalTimeElapsed
      description: Total time taken for the network session to complete.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceName
      description: Device name of the source of the log
      type: String
    - contextPath: CDL.Logging.Traffic.Subtype
      description: The log sub type.
      type: String
    - contextPath: CDL.Logging.Traffic.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Traffic.TunneledApp
      description: Is app tunneled.
      type: String
    - contextPath: CDL.Logging.Traffic.IsPhishing
      description: Indicates whether enterprise credentials were submitted by an end
        user.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionEndReason
      description: The reason a session terminated.
      type: String
    - contextPath: CDL.Logging.Traffic.NatSource
      description: If source NAT was performed, the post-NAT source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Traffic.SessionStartIP
      description: Time when the session was established.
      type: date
    - contextPath: CDL.Logging.Traffic.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: date
    - contextPath: CDL.Logging.Traffic.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Traffic.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Traffic.LogSourceID
      description: D that uniquely identifies the source of the log. If the source
        is a firewall, this is its serial number.
      type: String
    - contextPath: CDL.Logging.Traffic.TotalBytes
      description: Number of total bytes (transmit and receive).
      type: String
    - contextPath: CDL.Logging.Traffic.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: String
    - contextPath: CDL.Logging.Traffic.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Traffic.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Traffic.SourcePort
      description: Source port utilized by the session.
      type: String
    - contextPath: CDL.Logging.Traffic.Tunnel
      description: Type of tunnel.
      type: String
  - arguments:
    - description: Original source IP address. Enter an IP address or an array of
        IP addresses for which to search, for example 1.1.1.1,2.2.2.2.
      name: source_ip
    - description: Original destination IP address. Enter an IP address or an array
        of IP addresses for which to search, for example 1.1.1.1,2.2.2.2.
      name: dest_ip
    - description: Name of the security policy rule that the network traffic matched.
        Enter a rule name or array of rule names to search.
      name: rule_matched
    - description: The networking zone from which the traffic originated. Enter zone
        or array of zones to search.
      name: from_zone
    - description: Networking zone to which the traffic was sent. Enter zone or array
        of zones to search.
      name: to_zone
    - description: Source port utilized by the session. Enter a port or array of ports
        to search.
      name: source_port
    - description: Network traffic's destination port. Enter a port or array of ports
        to search.
      name: dest_port
    - auto: PREDEFINED
      description: The action that the firewall took for the network traffic. Enter
        an action or array of actions to search.
      name: action
      predefined:
      - unknown
      - n-a
      - aged-out
      - decoder
      - tcp-reuse
      - resources-unavailable
      - tcp-fin
      - tcp-rst-from-server
      - tcp-rst-from-client
      - policy-deny
      - threat
      - decrypt-error
      - decrypt-unsupport-param
      - decrypt-cert-validation
      - request-timeout
      - shutdown-from-endpoint
      - abort-from-endpoint
      - split-tunnel
    - description: The binary hash (SHA256) of the file. Enter a SHA256 hash or array
        of SHA256 hashes to search.
      name: file_sha_256
    - description: The name of the file that is blocked. Enter a file name or array
        of file names to search.
      name: file_name
    - description: Free input query to search. This is the WHERE part of the query.
        so an example will be !cdl-query-traffic-logs query="source_ip.value LIKE
        '192.168.1.*' AND dest_ip.value = '192.168.1.12'"
      name: query
    - auto: PREDEFINED
      defaultValue: all
      description: The fields that are selected in the query. Selection can be "all"
        (same as *) or listing of specific fields in the table. List of fields can
        be found after viewing all the outputed fields with all.
      isArray: true
      name: fields
      predefined:
      - vendor_name
      - log_source
      - log_source_id
      - log_source_name
      - customer_id
      - log_time
      - log_source_tz_offset
      - log_type
      - sub_type
      - source_ip
      - source_port
      - dest_ip
      - dest_port
      - protocol
      - threat_id
      - threat_name
      - threat_category
      - cloud_hostname
      - direction_of_attack
      - url_domain
      - url_idx
      - file_name
      - cloud
      - file_sha_256
      - file_type
      - sender_of_virus
      - recipient_of_virus
      - subject_of_email
      - report_id
      - verdict
      - vendor_severity
      - severity
      - pcap
      - pcap_id
      - sig_flags
      - url_category
      - action
      - action_flags
      - app
      - app_category
      - characteristics_of_app
      - container_of_app
      - dg_hier_level_1
      - dg_hier_level_2
      - dg_hier_level_3
      - dg_hier_level_4
      - dest_uuid
      - dest_location
      - dest_user
      - dest_user_info
      - is_exported
      - is_forwarded
      - from_zone
      - http2_connection
      - inbound_if
      - inbound_if_details
      - is_saas_app
      - is_dup_log
      - is_prisma_branch
      - is_prisma_mobile
      - log_set
      - monitor_tag_imei
      - nat_dest_port
      - nat_dest
      - nat_source_port
      - nat_source
      - non_standard_dest_port
      - outbound_if
      - outbound_if_details
      - parent_session_id
      - parent_start_time
      - count_of_repeats
      - risk_of_app
      - rule_matched
      - rule_matched_uuid
      - sanctioned_state_of_app
      - sequence_no
      - session_id
      - source_uuid
      - source_location
      - source_user
      - source_user_info
      - app_sub_category
      - technology_of_app
      - time_generated
      - to_zone
      - tunnel
      - tunneled_app
      - tunnelid_imsi
      - users
      - vsys_id
      - vsys
      - vsys_name
      - flags
      - is_decrypt_mirror
      - is_sym_return
      - is_container
      - is_server_to_client
      - is_client_to_server
      - is_transaction
      - is_non_std_dest_port
      - is_captive_portal
      - is_nat
      - is_proxy
      - is_packet_capture
      - is_phishing
      - is_mptcp_on
      - is_recon_excluded
      - is_url_denied
      - is_tunnel_inspected
      - is_source_x_fwded
      - is_ipv6
      - container_id
      - pod_namespace
      - pod_name
      - source_device_class
      - source_device_vendor
      - source_device_model
      - source_device_os
      - source_device_mac
      - dest_device_class
      - dest_device_vendor
      - dest_device_model
      - dest_device_os
      - dest_device_mac
      - content_version
      - dynusergroup_name
      - ingestion_time
      - record_size
    - defaultValue: '''1970-01-01 00:00:00'''
      description: The query start time. For example, start_time="2018-04-26 00:00:00"
      name: start_time
    - default: true
      description: The query end time. For example, end_time="2018-04-26 00:00:00"
      name: end_time
    - auto: PREDEFINED
      description: First log time (<number> <time unit>, e.g., 12 hours, 7 days, 3
        months, 1 year)
      name: time_range
      predefined:
      - minutes
      - days
      - weeks
    - description: The number of logs to return. Default is 5.
      name: limit
    description: Searches the Cortex panw.threat table, which is the threat logs table
      for PAN-OS/Panorama.
    name: cdl-query-threat-logs
    outputs:
    - contextPath: CDL.Logging.Threat.SessionID
      description: Identifies the firewall's internal identifier for a specific network
        session.
      type: String
    - contextPath: CDL.Logging.Threat.Action
      description: Identifies the action that the firewall took for the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.App
      description: Application associated with the network traffic.
      type: String
    - contextPath: CDL.Logging.Threat.IsNat
      description: Indicates whether the firewall is performing network address translation
        (NAT) for the logged traffic. If it is, this value is 1.
      type: String
    - contextPath: CDL.Logging.Threat.SubcategoryOfApp
      description: Identifies the application's subcategory. The subcategoryis related
        to the application's category, which is identified in category_of_app.
      type: String
    - contextPath: CDL.Logging.Threat.PcapID
      description: Packet capture (pcap) ID. This is used to correlate threat pcap
        files with extended pcaps taken as a part of the session flow. All threat
        logs will contain either a pcap_id of 0 (no associated pcap) , or an ID referencing
        the extended pcap file.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestination
      description: If destination NAT performed, the post-NAT destination IP address.
        The IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.Flags
      description: Bit field which provides details on the session, such as whether
        the session use IPv6, whether the session was denied due to a URL filtering
        rule, and/or whether the log corresponds to a transaction within an HTTP proxy
        session.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationPort
      description: Network traffic's destination port. If this value is 0, then the
        app is using its standard port.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatID
      description: Numerical identifier for the threat type. All threats encountered
        by Palo Alto Networks firewalls are assigned a unique identifier
      type: String
    - contextPath: CDL.Logging.Threat.NatSource
      description: If source NAT was performed, the post-NAT source IP address. The
        IP address is an IPv4/IPv6 address in hex format.
      type: String
    - contextPath: CDL.Logging.Threat.IsURLDenied
      description: Indicates whether the session was denied due to a URL filtering
        rule.
      type: Boolean
    - contextPath: CDL.Logging.Threat.Users
      description: Source/Destination user. If neither is available, source_ip is
        used.
      type: String
    - contextPath: CDL.Logging.Threat.TimeGenerated
      description: Time when the log was generated on the firewall's data plane.
      type: Date
    - contextPath: CDL.Logging.Threat.IsPhishing
      description: ndicates whether enterprise credentials were submitted by an end
        user.
      type: Boolean
    - contextPath: CDL.Logging.Threat.AppCategory
      description: Identifies the high-level family of the application.
      type: String
    - contextPath: CDL.Logging.Threat.SourceLocation
      description: Source country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.DestinationLocation
      description: Destination country or internal region for private addresses.
      type: String
    - contextPath: CDL.Logging.Threat.ToZone
      description: Networking zone to which the traffic was sent.
      type: String
    - contextPath: CDL.Logging.Threat.RiskOfApp
      description: Indicates how risky the application is from a network security
        perspective.
      type: Number
    - contextPath: CDL.Logging.Threat.NatSourcePort
      description: Post-NAT source port.
      type: Number
    - contextPath: CDL.Logging.Threat.CharacteristicOfApp
      description: Identifies the behaviorial characteristic of the application associated
        with the network traffic.
      type: Unknown
    - contextPath: CDL.Logging.Threat.FromZone
      description: The networking zone from which the traffic originated.
      type: String
    - contextPath: CDL.Logging.Threat.Vsys
      description: String representation of the unique identifier for a virtual system
        on a Palo Alto Networks firewall.
      type: String
    - contextPath: CDL.Logging.Threat.Protocol
      description: IP protocol associated with the session.
      type: String
    - contextPath: CDL.Logging.Threat.NatDestinationPort
      description: Post-NAT destination port.
      type: Number
    - contextPath: CDL.Logging.Threat.DestinationIP
      description: Original destination IP address.
      type: String
    - contextPath: CDL.Logging.Threat.SourceIP
      description: Original source IP address.
      type: String
    - contextPath: CDL.Logging.Threat.RuleMatched
      description: Unique identifier for the security policy rule that the network
        traffic matched.
      type: String
    - contextPath: CDL.Logging.Threat.ThreatCategory
      description: Threat category of the detected threat.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceName
      description: Name of the source of the log.
      type: String
    - contextPath: CDL.Logging.Threat.Subtype
      description: Identifies the log subtype.
      type: String
    - contextPath: CDL.Logging.Threat.Direction
      description: Indicates the direction of the attack.
      type: String
    - contextPath: CDL.Logging.Threat.FileName
      description: The name of the file that is blocked.
      type: String
    - contextPath: CDL.Logging.Threat.VendorSeverity
      description: Severity associated with the event.
      type: String
    - contextPath: CDL.Logging.Threat.LogTime
      description: Time the log was received in Cortex Data Lake.
      type: String
    - contextPath: CDL.Logging.Threat.LogSourceID
      description: ID that uniquely identifies the source of the log. If the source
        is a firewall, this is its serial number.
      type: String
    - contextPath: CDL.Logging.Threat.VsysID
      description: A unique identifier for a virtual system on a Palo Alto Networks
        firewall.
      type: Number
    - contextPath: CDL.Logging.Threat.URLDomain
      description: The name of the internet domain that was visited in this session.
      type: String
    - contextPath: CDL.Logging.Threat.URLCategory
      description: The URL category.
      type: String
    - contextPath: CDL.Logging.Threat.SourcePort
      description: Source port utilized by the session.
      type: Number
  dockerimage: demisto/python_pancloud_v2:1.0.0.6519
  isfetch: true
  runonce: false
  script: |
    from dateutil import parser



    ''' IMPORTS '''
    import os
    import requests
    import json
    from pancloud import QueryService, Credentials, exceptions
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Any, List, Tuple, Callable

    # disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBAL CONSTS '''
    ACCESS_TOKEN_CONST = 'access_token'  # guardrails-disable-line
    REFRESH_TOKEN_CONST = 'refresh_token'  # guardrails-disable-line
    EXPIRES_IN = 'expires_in'
    INSTANCE_ID_CONST = 'instance_id'
    API_URL_CONST = 'api_url'
    REGISTRATION_ID_CONST = 'reg_id'
    ENCRYPTION_KEY_CONST = 'auth_key'
    DEFAULT_API_URL = 'https://api.us.cdl.paloaltonetworks.com'
    MINUTES_60 = 60 * 60
    SECONDS_30 = 30


    class Client(BaseClient):
        """
        Client will implement the service API, and should not contain any Demisto logic.
        Should only do requests and return data.
        """

        def __init__(self, token_retrieval_url, registration_id, use_ssl, proxy, refresh_token, enc_key):
            headers = {
                'Authorization': registration_id,
                'Accept': 'application/json'
            }
            super().__init__(base_url=token_retrieval_url, headers=headers, verify=use_ssl, proxy=proxy)
            self.refresh_token = refresh_token
            self.enc_key = enc_key
            self.use_ssl = use_ssl
            # Trust environment settings for proxy configuration
            self.trust_env = proxy
            self._get_access_token()

        def _get_access_token(self):
            """
            Checks if access token exists in the integration context and return it if it exists, if not, a new token
            is generated and saved in the integration context along with the query api_url and the instance_id
            Returns:
                The access token from the integration context or from the request.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get(ACCESS_TOKEN_CONST)
            valid_until = integration_context.get(EXPIRES_IN)
            if access_token and valid_until:
                if int(time.time()) < valid_until:
                    self.access_token = access_token
                    self.api_url = integration_context.get(API_URL_CONST, DEFAULT_API_URL)
                    self.instance_id = integration_context.get(INSTANCE_ID_CONST)
            access_token, api_url, instance_id, refresh_token, expires_in = self._oproxy_authorize()
            updated_integration_context = {
                ACCESS_TOKEN_CONST: access_token,
                EXPIRES_IN: int(time.time()) + expires_in - SECONDS_30,
                API_URL_CONST: api_url,
                INSTANCE_ID_CONST: instance_id
            }
            if refresh_token:
                updated_integration_context.update({REFRESH_TOKEN_CONST: refresh_token})
            demisto.setIntegrationContext(updated_integration_context)
            self.access_token = access_token
            self.api_url = api_url
            self.instance_id = instance_id

        def _oproxy_authorize(self) -> Tuple[str, str, str, str, int]:
            oproxy_response = self._http_request('POST',
                                                 '/cdl-token',
                                                 json_data={'token': get_encrypted(self.refresh_token, self.enc_key)},
                                                 timeout=(60 * 3, 60 * 3),
                                                 retries=3,
                                                 backoff_factor=10,
                                                 status_list_to_retry=[400])
            access_token = oproxy_response.get(ACCESS_TOKEN_CONST)
            api_url = oproxy_response.get('url')
            refresh_token = oproxy_response.get(REFRESH_TOKEN_CONST)
            instance_id = oproxy_response.get(INSTANCE_ID_CONST)
            expires_in = int(oproxy_response.get(EXPIRES_IN, MINUTES_60))
            if not access_token or not api_url or not instance_id:
                raise DemistoException(f'Missing attribute in response: access_token, instance_id or api are missing.\n'
                                       f'Oproxy response: {oproxy_response}')
            return access_token, api_url, instance_id, refresh_token, expires_in

        def query_loggings(self, query: str) -> Tuple[List[dict], list]:
            """
            This function handles all the querying of Cortex Logging service

            Args:
                query: The sql string query.

            Returns:
                A list of records according to the query
            """
            query_data = {'query': self.add_instance_id_to_query(query),
                          'language': 'csql'}
            query_service = self.initial_query_service()
            response = query_service.create_query(query_params=query_data, enforce_json=True)
            query_result = response.json()

            if not response.ok:
                status_code = response.status_code
                try:
                    # For some error responses the messages are in 'query_result['errors'] and for some they are simply
                    # in 'query_result
                    errors = query_result.get('errors', query_result)
                    error_message = ''.join([message.get('message') for message in errors])
                except AttributeError:
                    error_message = query_result

                raise DemistoException(f'Error in query to Cortex Data Lake [{status_code}] - {error_message}')

            try:
                raw_results = [r.json() for r in query_service.iter_job_results(job_id=query_result.get('jobId'),
                                                                                result_format='valuesDictionary',
                                                                                max_wait=2000)]
            except exceptions.HTTPError as e:
                raise DemistoException(f'Received error {str(e)} when querying logs.')

            extended_results: List[Dict] = []
            for result in raw_results:
                page = result.get('page', {})
                data = page.get('result', {}).get('data', [])
                if data:
                    extended_results.extend(data)

            return extended_results, raw_results

        def initial_query_service(self) -> QueryService:
            credentials = Credentials(
                access_token=self.access_token,
                verify=self.use_ssl
            )
            query_service = QueryService(
                url=self.api_url,
                credentials=credentials,
                trust_env=self.trust_env
            )
            return query_service

        def add_instance_id_to_query(self, query: str) -> str:
            """
            On apollo v2 all table names must have the instance_id at the top of their hierarchy.
            This function adds the instance_id to the query.
            For example:
            For the query "SELECT * FROM `test`" with instance_id=1234 this function will return "SELECT * FROM `1234.test`"
            Args:
                query: A query for CDL
            Returns:
                A query with instance_id
            """
            FIND_FROM_STATEMENT_REGEX_PATTERN = r'(?i)FROM `'
            query = re.sub(FIND_FROM_STATEMENT_REGEX_PATTERN, f'FROM `{self.instance_id}.', query)
            return query


    ''' HELPER FUNCTIONS '''


    def human_readable_time_from_epoch_time(epoch_time: int, utc_time: bool = False):
        """
        Divides the epoch time by 1e6 since the epoch format has 6 trailing zeroes
        Since incidents need the time in utc format (ends in 'Z') but the SQL syntax cannot parse a UTC formatted date well
        it is parameterized
        Args:
            utc_time: A boolean that states weather to add the 'Z' at the end of the date string
            epoch_time: Epoch time as it is in the raw_content
        Returns:
            human readable time in the format of '1970-01-01T02:00:00'
        """
        result = datetime.fromtimestamp(epoch_time / 1e6).isoformat() if epoch_time else None
        if result:
            result += 'Z' if utc_time else ''
        return result


    def common_context_transformer(row_content):
        """
            This function retrieves data from a row of raw data into context path locations

            Args:
                row_content: a dict representing raw data of a row

            Returns:
                a dict with context paths and their corresponding value
            """
        return {
            'Action': row_content.get('action', {}).get('value'),
            'App': row_content.get('app'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'RuleMatched': row_content.get('rule_matched'),
            'CharacteristicOfApp': row_content.get('characteristics_of_app'),
            'LogSourceName': row_content.get('log_source_name'),
            'IsNat': row_content.get('is_nat'),
            'NatDestinationPort': row_content.get('nat_dest_port'),
            'NatDestination': row_content.get('nat_dest', {}).get('value'),
            'NatSource': row_content.get('nat_source', {}).get('value'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'AppCategory': row_content.get('app_category'),
            'SourceLocation': row_content.get('source_location'),
            'DestinationLocation': row_content.get('dest_location'),
            'FileSHA256': row_content.get('file_sha_256'),
            'FileName': row_content.get('file_name'),
            'TimeGenerated': human_readable_time_from_epoch_time(row_content.get('time_generated', 0))
        }


    def traffic_context_transformer(row_content: dict) -> dict:
        """
        This function retrieves data from a row of raw data into context path locations

        Args:
            row_content: a dict representing raw data of a row

        Returns:
            a dict with context paths and their corresponding value
        """

        return {
            'Action': row_content.get('action', {}).get('value'),
            'RiskOfApp': row_content.get('risk_of_app'),
            'NatSourcePort': row_content.get('nat_source_port'),
            'SessionID': row_content.get('session_id'),
            'Packets': row_content.get('packets_total'),
            'CharacteristicOfApp': row_content.get('characteristics_of_app'),
            'App': row_content.get('app'),
            'Vsys': row_content.get('vsys'),
            'IsNat': row_content.get('is_nat'),
            'LogTime': human_readable_time_from_epoch_time(row_content.get('log_time', 0)),
            'SubcategoryOfApp': row_content.get('app_sub_category'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'NatDestinationPort': row_content.get('nat_dest_port'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'NatDestination': row_content.get('nat_dest', {}).get('value'),
            'RuleMatched': row_content.get('rule_matched'),
            'DestinationPort': row_content.get('dest_port'),
            'TotalTimeElapsed': row_content.get('total_time_elapsed'),
            'LogSourceName': row_content.get('log_source_name'),
            'Subtype': row_content.get('sub_type', {}).get('value'),
            'Users': row_content.get('users'),
            'TunneledApp': row_content.get('tunneled_app'),
            'IsPhishing': row_content.get('is_phishing'),
            'SessionEndReason': row_content.get('session_end_reason', {}).get('value'),
            'NatSource': row_content.get('nat_source', {}).get('value'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'SessionStartIP': human_readable_time_from_epoch_time(row_content.get('session_start_time', 0)),
            'TimeGenerated': human_readable_time_from_epoch_time(row_content.get('time_generated', 0)),
            'AppCategory': row_content.get('app_category'),
            'SourceLocation': row_content.get('source_location'),
            'DestinationLocation': row_content.get('dest_location'),
            'LogSourceID': row_content.get('log_source_id'),
            'TotalBytes': row_content.get('bytes_total'),
            'VsysID': row_content.get('vsys_id'),
            'ToZone': row_content.get('to_zone'),
            'URLCategory': row_content.get('url_category', {}).get('value'),
            'SourcePort': row_content.get('source_port'),
            'Tunnel': row_content.get('tunnel', {}).get('value')
        }


    def threat_context_transformer(row_content: dict) -> dict:
        """
        This function retrieves data from a row of raw data into context path locations

        Args:
            row_content: a dict representing raw data of a row

        Returns:
            a dict with context paths and their corresponding value
        """
        return {
            'SessionID': row_content.get('session_id'),
            'Action': row_content.get('action', {}).get('value'),
            'App': row_content.get('app'),
            'IsNat': row_content.get('is_nat'),
            'SubcategoryOfApp': row_content.get('app_sub_category'),
            'PcapID': row_content.get('pcap_id'),
            'NatDestination': row_content.get('nat_dest', {}).get('value'),
            'Flags': row_content.get('flags'),
            'DestinationPort': row_content.get('dest_port'),
            'ThreatID': row_content.get('threat_id'),
            'NatSource': row_content.get('nat_source', {}).get('value'),
            'IsURLDenied': row_content.get('is_url_denied'),
            'Users': row_content.get('users'),
            'TimeGenerated': human_readable_time_from_epoch_time(row_content.get('time_generated', 0)),
            'IsPhishing': row_content.get('is_phishing'),
            'AppCategory': row_content.get('app_category'),
            'SourceLocation': row_content.get('source_location'),
            'DestinationLocation': row_content.get('dest_location'),
            'ToZone': row_content.get('to_zone'),
            'RiskOfApp': row_content.get('risk_of_app'),
            'NatSourcePort': row_content.get('nat_source_port'),
            'CharacteristicOfApp': row_content.get('characteristics_of_app'),
            'FromZone': row_content.get('from_zone'),
            'Vsys': row_content.get('vsys'),
            'Protocol': row_content.get('protocol', {}).get('value'),
            'NatDestinationPort': row_content.get('nat_dest_port'),
            'DestinationIP': row_content.get('dest_ip', {}).get('value'),
            'SourceIP': row_content.get('source_ip', {}).get('value'),
            'RuleMatched': row_content.get('rule_matched'),
            'ThreatCategory': row_content.get('threat_category', {}).get('value'),
            'LogSourceName': row_content.get('log_source_name'),
            'Subtype': row_content.get('sub_type', {}).get('value'),
            'Direction': row_content.get('direction_of_attack', {}).get('value'),
            'FileName': row_content.get('file_name'),
            'VendorSeverity': row_content.get('vendor_severity', {}).get('value'),
            'LogTime': human_readable_time_from_epoch_time(row_content.get('log_time', 0)),
            'LogSourceID': row_content.get('log_source_id'),
            'VsysID': row_content.get('vsys_id'),
            'URLDomain': row_content.get('url_domain'),
            'URLCategory': row_content.get('url_category', {}).get('value'),
            'SourcePort': row_content.get('source_port'),
            'FileSHA256': row_content.get('file_sha_256')
        }


    def records_to_human_readable_output(fields: str, table_name: str, results: list) -> str:
        """
        This function gets all relevant data for the human readable output of a specific table.
        By design if the user queries all fields of the table (i.e. enters '*' in the query) than the outputs
        shown in the war room will be the same for each query - the outputs will be the headers list in the code.
        If the user selects different fields in the query than those fields will be shown to the user.

        Args:
            fields: The field of the table named table_name
            table_name: The name of the table
            results: The results needs to be shown

        Returns:
            A markdown table of the outputs
        """
        filtered_results: list = []

        if fields == '*':
            for result in results:
                filtered_result = {
                    'Source Address': result.get('source_ip', {}).get('value'),
                    'Destination Address': result.get('dest_ip', {}).get('value'),
                    'Application': result.get('app'),
                    'Action': result.get('action', {}).get('value'),
                    'RuleMatched': result.get('rule_matched'),
                    'TimeGenerated': human_readable_time_from_epoch_time(result.get('time_generated')),
                }
                filtered_results.append(filtered_result)
        else:
            for result in results:
                filtered_result = {}
                for root in result.keys():
                    parsed_tree: dict = parse_tree_by_root_to_leaf_paths(root, result[root])
                    filtered_result.update(parsed_tree)
                filtered_results.append(filtered_result)

        return tableToMarkdown(f'Logs {table_name} table', filtered_results, removeNull=True)


    def parse_tree_by_root_to_leaf_paths(root: str, body) -> dict:
        """
        This function receives a dict (root and a body) and parses it according to the upcoming example:
        Input: root = 'a', body = {'b': 2, 'c': 3, 'd': {'e': 5, 'f': 6, 'g': {'h': 8, 'i': 9}}}.
        So the dict is {'a': {'b': 2, 'c': 3, 'd': {'e': 5, 'f': 6, 'g': {'h': 8, 'i': 9}}}}
        The expected output is {'a.b': 2, 'a.c': 3, 'a.d.e': 5, 'a.d.f': 6, 'a.d.g.h': 8, 'a.d.g.i': 9}
        Basically what this function does is when it gets a tree it creates a dict from it which it's keys are all
        root to leaf paths and the corresponding values are the values in the leafs
        Please note that the implementation is similar to DFS on trees (which means we don't have to check for visited
        nodes since there are no cycles)

        Args:
            root: The root string
            body: The body of the root

        Returns:
            The parsed tree
        """
        parsed_tree: dict = {}
        help_stack: list = [(root, body)]

        while help_stack:
            node: tuple = help_stack.pop()
            root_to_node_path: str = node[0]
            body = node[1]
            if isinstance(body, dict):
                for key, value in body.items():
                    # for each node we append a tuple of it's body and the path from the root to it
                    help_stack.append((root_to_node_path + '.' + key, value))
            elif isinstance(body, list):
                for element in body:
                    help_stack.append((root_to_node_path, element))
            else:
                parsed_tree[root_to_node_path] = body
        return parsed_tree


    def build_where_clause(args: dict) -> str:
        """
        This function transforms the relevant entries of dict into the where part of a SQL query

        Args:
            args: The arguments dict

        Returns:
            A string represents the where part of a SQL query
        """

        args_dict = {
            'source_ip': 'source_ip.value',
            'dest_ip': 'dest_ip.value',
            'rule_matched': 'rule_matched',
            'from_zone': 'from_zone',
            'to_zone': 'to_zone',
            'source_port': 'source_port',
            'dest_port': 'dest_port',
            'action': 'action.value',
            'file_sha_256': 'file_sha_256',
            'file_name': 'file_name',
        }
        non_string_keys = {'dest_port', 'source_port'}
        if 'query' in args:
            # if query arg is supplied than we just need to parse it and only it
            return args['query'].strip()

        # We want to add only keys that are part of the query
        string_query_fields = {key: value for key, value in args.items() if key in args_dict and key not in non_string_keys}
        or_statements = []
        for key, values in string_query_fields.items():
            string_values_list: list = argToList(values)
            field = args_dict[key]
            or_statements.append(' OR '.join([f'{field} = "{value}"' for value in string_values_list]))
        # ports are digested as ints and cannot be sent as strings
        non_string_query_fields = {key: value for key, value in args.items() if key in non_string_keys}
        for key, values in non_string_query_fields.items():
            non_string_values_list: list = argToList(values)
            field = args_dict[key]
            or_statements.append(' OR '.join([f'{field} = {value}' for value in non_string_values_list]))
        where_clause = ' AND '.join([f'({or_statement})' for or_statement in or_statements if or_statement])
        return where_clause


    def get_encrypted(auth_id: str, key: str) -> str:
        """

        Args:
            auth_id (str): auth_id from oproxy
            key (str): key from oproxy

        Returns:
            The encrypted auth_id with the time it was encrypted using AESGCM algorithm
        """

        def create_nonce() -> bytes:
            return os.urandom(12)

        def encrypt(string: str, enc_key: str) -> bytes:
            """

            Args:
                enc_key (str):
                string (str):

            Returns:
                bytes:
            """
            # String to bytes
            decoded_key = base64.b64decode(enc_key)
            # Create key
            aes_gcm = AESGCM(decoded_key)
            # Create nonce
            nonce = create_nonce()
            # Create ciphered data
            data = string.encode()
            ct = aes_gcm.encrypt(nonce, data, None)
            return base64.b64encode(nonce + ct)

        now = int(time.time())
        return encrypt(f'{now}:{auth_id}', key).decode('utf-8')


    def prepare_fetch_incidents_query(fetch_timestamp: str,
                                      fetch_severity: list,
                                      fetch_subtype: list,
                                      fetch_limit: str) -> str:
        """
        Prepares the SQL query for fetch incidents command
        Args:
            fetch_limit: Indicates how many incidents should be queried
            fetch_timestamp: The date from which threat logs should be queried
            fetch_severity: Severity associated with the incident.
            fetch_subtype: Identifies the log subtype.

        Returns:
            SQL query that matches the arguments
        """
        query = f'SELECT * FROM `firewall.threat` '  # guardrails-disable-line
        query += f'WHERE (TIME(time_generated) Between TIME(TIMESTAMP("{fetch_timestamp}")) ' \
                 f'AND TIME(CURRENT_TIMESTAMP))'
        if fetch_subtype and 'all' not in fetch_subtype:
            sub_types = [f'sub_type.value = "{sub_type}"' for sub_type in fetch_subtype]
            query += f' AND ({" OR ".join(sub_types)})'
        if fetch_severity and 'all' not in fetch_severity:
            severities = [f'vendor_severity.value = "{severity}"' for severity in fetch_severity]
            query += f' AND ({" OR ".join(severities)})'
        query += f' ORDER BY time_generated ASC LIMIT {fetch_limit}'
        return query


    def convert_log_to_incident(log: dict) -> dict:
        time_generated = log.get('time_generated', 0)
        occurred = human_readable_time_from_epoch_time(time_generated, utc_time=True)
        incident = {
            'name': 'Cortex Firewall Threat',
            'rawJSON': json.dumps(log, ensure_ascii=False),
            'occurred': occurred
        }
        return incident


    ''' COMMANDS FUNCTIONS '''


    def test_module(client: Client):
        query = 'SELECT * FROM `firewall.traffic` limit 1'
        client.query_loggings(query)
        return_outputs('ok')


    def query_logs_command(args: dict, client: Client) -> Tuple[str, Dict[str, List[dict]], List[Dict[str, Any]]]:
        """
        Return the result of querying the Logging service
        """
        query = args.get('query', '')
        limit = args.get('limit', '')

        if 'limit' not in query.lower():
            query += f' LIMIT {limit}'

        records, raw_results = client.query_loggings(query)

        table_name = get_table_name(records)
        transformed_results = [common_context_transformer(record) for record in records]
        human_readable = tableToMarkdown('Logs ' + table_name + ' table', transformed_results, removeNull=True)
        ec = {
            'CDL.Logging': transformed_results
        }
        return human_readable, ec, raw_results


    def get_table_name(records: List[Dict[str, Any]]):
        """
        Table name is stored in log_type attribute of the records
        Args:
            records: Records to get the table name of

        Returns:
            The records table name
        """
        return next(record.get('log_type', {}).get('value') for record in records if record.get('log_type')) or ''


    def get_critical_logs_command(args: dict, client: Client) -> Tuple[str, Dict[str, List[dict]], List[Dict[str, Any]]]:
        """
        Queries Cortex Logging according to a pre-set query
        """
        logs_amount = args.get('limit')
        query_start_time, query_end_time = query_timestamp(args)
        query = f'SELECT * FROM `firewall.threat` WHERE severity = "Critical" '  # guardrails-disable-line
        query += f'AND (TIME(time_generated) BETWEEN TIME(TIMESTAMP("{query_start_time}")) AND ' \
                 f'TIME(TIMESTAMP("{query_end_time}"))) LIMIT {logs_amount}'

        records, raw_results = client.query_loggings(query)

        transformed_results = [threat_context_transformer(record) for record in records]

        human_readable = tableToMarkdown('Logs threat table', transformed_results, removeNull=True)
        ec = {
            'CDL.Logging.Threat': transformed_results
        }
        return human_readable, ec, raw_results


    def query_timestamp(args: dict) -> Tuple[datetime, datetime]:
        start_time = args.get('start_time', '')
        end_time = args.get('end_time', '')
        time_range = args.get('time_range', '')
        if time_range:
            query_start_time, query_end_time = parse_date_range(time_range)
        else:
            # parses user input to datetime object
            query_start_time = parser.parse(start_time)
            # if end_time is not given- will be replaced with current time
            query_end_time = parser.parse(end_time) if end_time else datetime.fromtimestamp(time.time())
        return query_start_time.replace(microsecond=0), query_end_time.replace(microsecond=0)


    def get_social_applications_command(args: dict,
                                        client: Client) -> Tuple[str, Dict[str, List[dict]], List[Dict[str, Any]]]:
        """ Queries Cortex Logging according to a pre-set query """
        logs_amount = args.get('limit')
        query_start_time, query_end_time = query_timestamp(args)
        query = f'SELECT * FROM `firewall.traffic` WHERE app_sub_category = "social-networking" '  # guardrails-disable-line
        query += f' AND (TIME(time_generated) BETWEEN TIME(TIMESTAMP("{query_start_time}")) AND ' \
                 f'TIME(TIMESTAMP("{query_end_time}"))) LIMIT {logs_amount}'

        records, raw_results = client.query_loggings(query)

        transformed_results = [traffic_context_transformer(record) for record in records]

        human_readable = tableToMarkdown('Logs traffic table', transformed_results, removeNull=True)
        ec = {
            'CDL.Logging.Traffic': transformed_results
        }
        return human_readable, ec, raw_results


    def search_by_file_hash_command(args: dict, client: Client) -> Tuple[str, Dict[str, List[dict]], List[Dict[str, Any]]]:
        """
        Queries Cortex Logging according to a pre-set query
        """
        logs_amount = args.get('limit')
        file_hash = args.get('SHA256')

        query_start_time, query_end_time = query_timestamp(args)
        query = f'SELECT * FROM `firewall.threat` WHERE file_sha_256 = "{file_hash}" '  # guardrails-disable-line
        query += f'AND (TIME(time_generated) BETWEEN TIME(TIMESTAMP("{query_start_time}")) AND ' \
                 f'TIME(TIMESTAMP("{query_end_time}"))) LIMIT {logs_amount}'

        records, raw_results = client.query_loggings(query)

        transformed_results = [threat_context_transformer(record) for record in records]

        human_readable = tableToMarkdown('Logs threat table', transformed_results, removeNull=True)
        ec = {
            'CDL.Logging.Threat': transformed_results
        }
        return human_readable, ec, raw_results


    def query_traffic_logs_command(args: dict, client: Client) -> Tuple[str, dict, List[Dict[str, Any]]]:
        """
        The function of the command that queries firewall.traffic table

            Returns: a Demisto's entry with all the parsed data
        """
        table_name: str = 'traffic'
        context_transformer_function = traffic_context_transformer
        table_context_path: str = 'CDL.Logging.Traffic'
        return query_table_logs(args, client, table_name, context_transformer_function, table_context_path)


    def query_threat_logs_command(args: dict, client: Client) -> Tuple[str, dict, List[Dict[str, Any]]]:
        """
        The function of the command that queries firewall.threat table

            Returns: a Demisto's entry with all the parsed data
        """
        query_table_name: str = 'threat'
        context_transformer_function = threat_context_transformer
        table_context_path: str = 'CDL.Logging.Threat'
        return query_table_logs(args, client, query_table_name, context_transformer_function, table_context_path)


    def query_table_logs(args: dict,
                         client: Client,
                         table_name: str,
                         context_transformer_function: Callable[[dict], dict],
                         table_context_path: str) -> Tuple[str, dict, List[Dict[str, Any]]]:
        """
        This function is a generic function that get's all the data needed for a specific table of Cortex and acts as a
        regular command function

        Args:
            args: demisto args
            client: The client
            table_name: the name of the table in Cortex
            context_transformer_function:  the context transformer function to parse the data
            table_context_path: the context path where the parsed data should be located
        """
        fields, query = build_query(args, table_name)
        results, raw_results = client.query_loggings(query)
        outputs = [context_transformer_function(record) for record in results]
        human_readable = records_to_human_readable_output(fields, table_name, results)

        context_outputs: dict = {table_context_path: outputs}
        return human_readable, context_outputs, raw_results


    def build_query(args, table_name):
        fields = args.get('fields', 'all')
        fields = '*' if 'all' in fields else fields
        where = build_where_clause(args)
        query_start_time, query_end_time = query_timestamp(args)
        timestamp_limitation = f'(TIME(time_generated) BETWEEN TIME(TIMESTAMP("{query_start_time}")) AND ' \
                               f'TIME(TIMESTAMP("{query_end_time}"))) '
        limit = args.get('limit', '5')
        where += f' AND {timestamp_limitation}' if where else timestamp_limitation
        query = f'SELECT {fields} FROM `firewall.{table_name}` WHERE {where} LIMIT {limit}'
        return fields, query


    def fetch_incidents(client: Client,
                        first_fetch_timestamp: str,
                        fetch_severity: list,
                        fetch_subtype: list,
                        fetch_limit: str,
                        last_run: dict) -> Tuple[Dict[str, str], list]:
        last_fetched_event_timestamp = last_run.get('lastRun')

        if last_fetched_event_timestamp:
            last_fetched_event_timestamp = parser.parse(last_fetched_event_timestamp)
        else:
            last_fetched_event_timestamp, _ = parse_date_range(first_fetch_timestamp)
            last_fetched_event_timestamp = last_fetched_event_timestamp.replace(microsecond=0)
        query = prepare_fetch_incidents_query(last_fetched_event_timestamp, fetch_severity, fetch_subtype, fetch_limit)
        demisto.debug('Query being fetched: {}'.format(query))
        records, _ = client.query_loggings(query)
        if not records:
            return {'lastRun': str(last_fetched_event_timestamp)}, []

        incidents = [convert_log_to_incident(record) for record in records]
        max_fetched_event_timestamp = max(records, key=lambda record: record.get('time_generated', 0)).get('time_generated',
                                                                                                           0)
        next_run = {'lastRun': human_readable_time_from_epoch_time(max_fetched_event_timestamp)}
        return next_run, incidents


    ''' EXECUTION CODE '''


    def main():
        params = demisto.params()
        registration_id_and_url = params.get(REGISTRATION_ID_CONST).split('@')
        if len(registration_id_and_url) != 2:
            token_retrieval_url = "https://oproxy.demisto.ninja"  # guardrails-disable-line
        else:
            token_retrieval_url = registration_id_and_url[1]
        registration_id = registration_id_and_url[0]
        # If there's a stored token in integration context, it's newer than current
        refresh_token = demisto.getIntegrationContext().get(REFRESH_TOKEN_CONST) or params.get(REFRESH_TOKEN_CONST)
        enc_key = params.get(ENCRYPTION_KEY_CONST)
        use_ssl = not params.get('insecure', False)
        proxy = params.get('proxy', False)
        client = Client(token_retrieval_url, registration_id, use_ssl, proxy, refresh_token, enc_key)
        args = demisto.args()
        command = demisto.command()
        LOG(f'command is {command}')
        try:
            if command == 'test-module':
                test_module(client)
            elif command == 'cdl-query-logs':
                return_outputs(*query_logs_command(args, client))
            elif command == 'cdl-get-critical-threat-logs':
                return_outputs(*get_critical_logs_command(args, client))
            elif command == 'cdl-get-social-applications':
                return_outputs(*get_social_applications_command(args, client))
            elif command == 'cdl-search-by-file-hash':
                return_outputs(*search_by_file_hash_command(args, client))
            elif command == 'cdl-query-traffic-logs':
                return_outputs(*query_traffic_logs_command(args, client))
            elif command == 'cdl-query-threat-logs':
                return_outputs(*query_threat_logs_command(args, client))
            elif command == 'fetch-incidents':
                first_fetch_timestamp = params.get('first_fetch_timestamp', '24 hours').strip()
                fetch_severity = params.get('firewall_severity')
                fetch_subtype = params.get('firewall_subtype')
                fetch_limit = params.get('limit')
                last_run = demisto.getLastRun()
                next_run, incidents = fetch_incidents(client,
                                                      first_fetch_timestamp,
                                                      fetch_severity,
                                                      fetch_subtype,
                                                      fetch_limit,
                                                      last_run)
                demisto.setLastRun(next_run)
                demisto.incidents(incidents)
        except Exception as e:
            error_message = str(e)
            return_error(error_message)


    if __name__ in ('__main__', 'builtins'):
        main()
  subtype: python3
  type: python
system: true
