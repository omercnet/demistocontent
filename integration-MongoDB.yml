category: Database
commonfields:
  id: MongoDB
  version: -1
configuration:
- defaultvalue: ""
  display: Username
  name: credentials
  required: true
  type: 9
- additionalinfo: A comma-separated list of URLs and ports.
  defaultvalue: ""
  display: Server URLs with port (host1.com:27017,host2.com:27017)
  name: urls
  required: true
  type: 0
- defaultvalue: ""
  display: Database Name
  name: database
  required: true
  type: 0
- defaultvalue: "false"
  display: Use SSL/TLS secured connection
  name: use_ssl
  required: false
  type: 8
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Use the MongoDB integration to search and query entries in your MongoDB.
display: MongoDB
image: data:image/png;base64,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
name: MongoDB
script:
  commands:
  - arguments:
    - description: Name of the collection from which to get entries.
      name: collection
      required: true
    - description: A comma-separated list of ObjectIds to get. Can be retrieved from
        the `mongodb-query` command.
      isArray: true
      name: object_id
      required: true
    description: Gets an entry from the database by the object ID.
    name: mongodb-get-entry-by-id
    outputs:
    - contextPath: MongoDB.Entry._id
      description: ID of the entry.
      type: String
    - contextPath: MongoDB.Entry.collection
      description: The collection of which the entry belongs to.
      type: String
  - arguments:
    - description: Name of the collection to query.
      name: collection
      required: true
    - description: 'A JSON query to search for in the collection, in the format: `{"key":
        "value"}`. e.g {"_id": "mongodbid"}'
      name: query
      required: true
    - defaultValue: "50"
      description: Limits the result returned from MongoDB
      name: limit
    description: Searches for items by the specified JSON query.
    name: mongodb-query
    outputs:
    - contextPath: MongoDB.Entry._id
      description: The ID of entry from the query.
      type: String
    - contextPath: MongoDB.Entry.collection
      description: The collection of which the entry belongs to.
      type: String
  - arguments:
    - description: Name of the collection in which to insert the entry.
      name: collection
      required: true
    - description: 'The entry to insert, in JSON format. Can include the `_id` argument
        or not, for example: `{"key": "value"}`'
      name: entry
      required: true
    description: Inserts an entry to the database.
    name: mongodb-insert
    outputs:
    - contextPath: MongoDB.Entry._id
      description: The ID of the entry from query.
      type: String
    - contextPath: MongoDB.Entry.collection
      description: The collection of which the entry belongs to.
      type: String
  - arguments:
    - description: The name of the collection in which to update an entry.
      name: collection
      required: true
    - description: 'A query that matches the document to update, in the format: `{"key":
        "value"}`.'
      name: filter
      required: true
    - description: 'The content with which to update the entry, in the format: {"$set":
        {"key": "value"}}. You can use Update Operators or Aggregation Pipeline. For
        more information, see the integration documentation.'
      name: update
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether to update a single entry. If false, will set all found
        entries. If false, will set all found entries.
      name: update_one
      predefined:
      - "true"
      - "false"
    description: Updates an entry in a collection.
    name: mongodb-update
  - arguments:
    - description: The name of the collection from which to delete an entry.
      name: collection
      required: true
    - description: 'A query that matches the document to delete, for example: `{"key":
        "value"}`.'
      name: filter
      required: true
    - auto: PREDEFINED
      defaultValue: "true"
      description: Whether to delete a single entry from the database. If false, will
        set all found entries.
      name: delete_one
      predefined:
      - "true"
      - "false"
    description: Deletes an entry from the database.
    name: mongodb-delete
  - arguments: []
    description: Lists all collections in the database.
    name: mongodb-list-collections
    outputs:
    - contextPath: MongoDB.Collection.Name
      description: The name of the collection.
      type: String
  - arguments:
    - default: true
      description: The name of the collection to create.
      name: collection
      required: true
    description: Creates a collection
    name: mongodb-create-collection
  - arguments:
    - default: true
      description: The name of the collection to drop from the database.
      name: collection
      required: true
    description: Drops a collection from the database.
    execution: true
    name: mongodb-drop-collection
  dockerimage: demisto/pymongo:1.0.0.5425
  runonce: false
  script: |2


    from json import JSONDecodeError
    from typing import List, Union, Tuple, Any

    from bson.objectid import ObjectId
    from pymongo import MongoClient
    from pymongo.collection import Collection
    from pymongo.database import Database
    from pymongo.errors import OperationFailure
    from pymongo.results import InsertManyResult, UpdateResult, DeleteResult
    from pymongo.cursor import Cursor

    CONTEXT_KEY = 'MongoDB.Entry(val._id === obj._id && obj.collection === val.collection)'


    class Client:
        def __init__(
                self,
                urls: List[str],
                username: str,
                password: str,
                database: str,
                ssl: bool = False,
                insecure: bool = False,
                timeout: int = 5000
        ):
            if insecure and not ssl:
                raise DemistoException(
                    f'"Trust any certificate (not secure)" must be ticked with "Use TLS/SSL secured connection"')
            if not insecure and not ssl:
                self._client = MongoClient(
                    urls, username=username, password=password, ssl=ssl, socketTimeoutMS=timeout
                )
            else:
                self._client = MongoClient(
                    urls, username=username, password=password, ssl=ssl, tlsAllowInvalidCertificates=insecure,
                    socketTimeoutMS=timeout
                )
            self.db: Database = self._client.get_database(database)

        def is_collection_in_db(self, collection: str) -> bool:
            return collection in self.db.list_collection_names()

        def get_collection(self, collection: str) -> Collection:
            if self.is_collection_in_db(collection):
                return self.db.get_collection(collection)
            raise DemistoException(
                f'Collection \'{collection}\' has not found in database \'{self.db.name}\''
            )

        def get_entry_by_id(self, collection: str, alert_ids: List[str]) -> List[dict]:
            collection_obj = self.get_collection(collection)
            entries: List[dict] = list()
            for alert_id in alert_ids:
                results = collection_obj.find({'_id': ObjectId(alert_id)})
                entries.extend([self.normalize_id(entry) for entry in results])
            entries = self.datetime_to_str(entries)
            return entries

        def query(self, collection: str, query: dict, limit: int = 50) -> List[dict]:
            collection_obj = self.get_collection(collection)
            entries = collection_obj.find(query).limit(limit)
            entries = self.datetime_to_str(entries)
            entries = [self.normalize_id(entry) for entry in entries]
            return entries

        @staticmethod
        def normalize_id(entry: dict):
            """ Convert ObjectID to str in given dict

            Args:
                entry:

            Returns:
                object with `_id` key as str.

            Examples:
                >>> Client.normalize_id({'_id': ObjectId('5e4412f230c5b8f63a7356ba')})
                {'_id': '5e4412f230c5b8f63a7356ba'}
            """
            entry['_id'] = str(entry.pop('_id'))
            return entry

        @classmethod
        def datetime_to_str(cls, obj: Any) -> Any:
            """ Converts any object with date value of type datetime to str

            Args:
                obj: The object contains possible date values.

            Returns:
                All Dates from type datetime converted to str in this format - %Y-%m-%dT%H:%M:%S.000Z

            Examples:
                >>> Client.datetime_to_str(datetime.strptime('2020-05-19T09:05:28.000Z', '%Y-%m-%dT%H:%M:%S.000Z'))
                '2020-05-19T09:05:28.000Z'
                >>> Client.datetime_to_str([datetime.strptime('2020-05-19T09:05:28.000Z', '%Y-%m-%dT%H:%M:%S.000Z')])
                ['2020-05-19T09:05:28.000Z']
                >>> Client.datetime_to_str({'date': datetime.strptime('2020-05-19T09:05:28.000Z', '%Y-%m-%dT%H:%M:%S.000Z')})
                {'date': '2020-05-19T09:05:28.000Z'}
            """
            if isinstance(obj, Cursor):
                return cls.datetime_to_str(list(obj))
            if isinstance(obj, list):
                return [cls.datetime_to_str(item) for item in obj]
            if isinstance(obj, dict):
                return {cls.datetime_to_str(k): cls.datetime_to_str(v) for k, v in obj.items()}
            if isinstance(obj, datetime):
                return obj.strftime('%Y-%m-%dT%H:%M:%S.000Z')
            else:
                return obj

        def insert_entry(self, collection: str, entries: List[dict]) -> InsertManyResult:
            collection_object = self.get_collection(collection)
            raw = collection_object.insert_many(entries)
            return self.datetime_to_str(raw)

        def update_entry(self, collection, filter, update, update_one) -> UpdateResult:
            collection_object = self.get_collection(collection)
            if update_one:
                raw = collection_object.update_one(filter, update)
            else:
                raw = collection_object.update_many(filter, update)
            return self.datetime_to_str(raw)

        def delete_entry(self, collection, filter, delete_one) -> DeleteResult:
            collection_object = self.get_collection(collection)
            if delete_one:
                raw = collection_object.delete_one(filter)
            else:
                raw = collection_object.delete_many(filter)
            return self.datetime_to_str(raw)

        def create_collection(self, collection) -> Collection:
            raw = self.db.create_collection(collection)
            return self.datetime_to_str(raw)

        def drop_collection(self, collection):
            return self.db.drop_collection(collection)


    def convert_id_to_object_id(
            entries: Union[List[dict], dict]
    ) -> Union[List[dict], dict]:
        """ Converts list or dict with `_id` key of type str to ObjectID

        Args:
            entries: The object contains list or dict with possible `_id` key.

        Returns:
            All '_id` key converted to ObjectID

        Examples:
            >>> convert_id_to_object_id([{'_id': '5e4412f230c5b8f63a7356ba'}])
            [{'_id': ObjectId('5e4412f230c5b8f63a7356ba')}]

            >>> convert_id_to_object_id({'_id': '5e4412f230c5b8f63a7356ba'})
            {'_id': ObjectId('5e4412f230c5b8f63a7356ba')}
        """

        def _convert(entry: dict):
            if '_id' in entry:
                entry['_id'] = ObjectId(entry['_id'])
            return entry

        if isinstance(entries, list):
            return [_convert(entry) for entry in entries]
        return _convert(entries)


    def convert_str_to_datetime(entries: dict) -> dict:
        """ Converts list or dict with date values of type str to Datetime.

        Args:
            entries: The object contains list or dict with possible dates value.

        Returns:
            All Dates converted to Datetime.
        """
        # regex for finding timestamp in string
        regex_for_timestamp = re.compile(r'\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?Z?')
        for key, value in entries.items():
            for match in regex_for_timestamp.findall(str(value)):
                try:
                    entries[key] = datetime.strptime(match, '%Y-%m-%dT%H:%M:%S.000Z')
                except ValueError as e:
                    raise DemistoException(str(e))

        return entries


    def convert_object_id_to_str(entries: List[ObjectId]) -> List[str]:
        ''' Converts list of ObjectID to list of str.

        Args:
            entries: list of ObjectIDs

        Returns:
            List of strs representing the ObjectID

        Examples:
            >>> convert_object_id_to_str([ObjectId('5e4412f230c5b8f63a7356ba')])
            ['5e4412f230c5b8f63a7356ba']  # guardrails-disable-line
        '''
        return list(map(str, entries))


    def test_module(client: Client, **kwargs) -> Tuple[str, dict]:
        # Using kwargs so vulture will let it go
        kwargs.get("")
        try:
            _ = client.db.list_collection_names()
        except OperationFailure as e:
            raise DemistoException(str(e))
        # To the unpack in the return.
        return 'ok', {}


    def get_entry_by_id_command(
            client: Client, collection: str, object_id: str, **kwargs
    ) -> Tuple[str, dict, list]:
        raw_response = client.get_entry_by_id(collection, argToList(object_id))
        if raw_response:
            readable_outputs = tableToMarkdown(
                f'Total of {len(raw_response)} found in MongoDB collection `{collection}`:',
                raw_response,
            )
            entries = list()
            for item in raw_response:
                item['collection'] = collection
                entries.append(item)
            outputs = {
                CONTEXT_KEY: entries
            }
            return readable_outputs, outputs, raw_response
        else:
            return 'MongoDB: No results found', {}, raw_response


    def search_query(
            client: Client, collection: str, query: str, limit: str, **kwargs
    ) -> Tuple[str, dict, list]:
        # test if query is a valid json
        try:
            query_json = validate_json_objects(json.loads(query))
            raw_response = client.query(collection, query_json, int(limit))  # type: ignore
        except JSONDecodeError:
            raise DemistoException('The `query` argument is not a valid json.')
        if raw_response:
            readable_outputs = tableToMarkdown(
                f'Total of {len(raw_response)} entries were found in MongoDB collection `{collection}` with query: {query}:',
                [entry.get('_id') for entry in raw_response],
                headers=['_id'],
            )
            outputs_objects = list()
            for item in raw_response:
                item.update({'collection': collection})
                outputs_objects.append(item)
            outputs = {CONTEXT_KEY: outputs_objects}
            return readable_outputs, outputs, raw_response
        else:
            return 'MongoDB: No results found', {}, raw_response


    def insert_entry_command(
            client: Client, collection: str, entry: str, **kwargs
    ) -> Tuple[str, dict, list]:
        # test if query is a valid json
        try:
            entry_json = validate_json_objects(json.loads(entry))

            if not isinstance(entry_json, list):
                entry_json = [entry_json]
            entries = convert_id_to_object_id(entry_json)
            results = client.insert_entry(collection, entries)  # type: ignore[arg-type]
            if not results.acknowledged:
                raise Exception('Error occurred when trying to enter insert entries.')
            else:
                object_ids = convert_object_id_to_str(results.inserted_ids)
                human_readable = tableToMarkdown(
                    f'MongoDB: Successfully entered {len(object_ids)} entry to the \'{collection}\' collection.',
                    object_ids,
                    headers=['_id'],
                )
                outputs = {
                    CONTEXT_KEY: [
                        {'_id': _id, 'collection': collection} for _id in object_ids
                    ]
                }
                return human_readable, outputs, object_ids
        except JSONDecodeError:
            raise DemistoException('The `entry` argument is not a valid json.')


    def validate_json_objects(json_obj: Union[dict, list]) -> Union[dict, list]:
        """ Validate that all objects in the json are according to MongoDB convention.

        Args:
            json_obj: The json to send to MongoDB

        Returns:
            valid json according to MongoDB convention.
        """
        valid_mongodb_json = convert_str_to_datetime(convert_id_to_object_id(json_obj))  # type: ignore
        return valid_mongodb_json


    def update_entry_command(
            client: Client,
            collection: str,
            filter: str,
            update: str,
            update_one=False,
            **kwargs,
    ) -> Tuple[str, None]:
        try:
            json_filter = validate_json_objects(json.loads(filter))

        except JSONDecodeError:
            raise DemistoException('The `filter` argument is not a valid json.')
        try:
            json_update = validate_json_objects(json.loads(update))
        except JSONDecodeError:
            raise DemistoException('The `update` argument is not a valid json.')
        response = client.update_entry(
            collection, json_filter, json_update, argToBoolean(update_one)
        )
        if not response.acknowledged:
            raise DemistoException('Error occurred when trying to enter update entries.')
        return (
            f'MongoDB: Total of {response.modified_count} entries has been modified.',
            None,
        )


    def delete_entry_command(
            client: Client, collection, filter, delete_one, **kwargs
    ) -> Tuple[str, None]:
        try:
            json_filter = json.loads(filter)
            json_filter = convert_id_to_object_id(json_filter)
        except JSONDecodeError:
            raise DemistoException('The `filter` argument is not a valid json.')
        results = client.delete_entry(collection, json_filter, argToBoolean(delete_one))
        if not results.acknowledged:
            raise DemistoException('Error occurred when trying to enter delete entries.')
        return f'MongoDB: Successfully deleted {results.deleted_count} entries.', None


    def create_collection_command(
            client: Client, collection: str, **kwargs
    ) -> Tuple[str, None]:
        if client.is_collection_in_db(collection):
            raise DemistoException(f'Collection \'{collection}\' is already exists')
        _ = client.create_collection(collection)
        return (
            f'MongoDB: Collection \'{collection}\' has been successfully created.',
            None,
        )


    def list_collections_command(client: Client, **kwargs) -> Tuple[str, dict, list]:
        raw_response = client.db.list_collection_names()
        if raw_response:
            readable_outputs = tableToMarkdown(
                'MongoDB: All collections in database', raw_response, headers=['Collection']
            )
            outputs = {
                'MongoDB.Collection(val.Name === obj.Name)': [
                    {'Name': collection} for collection in raw_response
                ]
            }
            return readable_outputs, outputs, raw_response
        else:
            return 'MongoDB: No results found', {}, raw_response


    def drop_collection_command(
            client: Client, collection: str, **kwargs
    ) -> Tuple[str, None]:
        response = client.drop_collection(collection)
        if (
                hasattr(response, 'acknowledged')
                and not response.acknowledged
                or isinstance(response, dict)
                and not response.get('ok') == 1.0
        ):
            raise DemistoException('Error occurred when trying to drop collection entries.')
        return f'MongoDB: Collection \'{collection}` has been successfully dropped.', None


    def main():
        params = demisto.params()
        args = demisto.args()
        command = demisto.command()
        client = Client(
            argToList(params.get('urls')),
            params.get('credentials', {}).get('identifier'),
            params.get('credentials', {}).get('password'),
            params['database'],
            bool(params.get('use_ssl', False)),
            bool(params.get('insecure', False))
        )
        commands = {
            'test-module': test_module,
            'mongodb-get-entry-by-id': get_entry_by_id_command,
            'mongodb-query': search_query,
            'mongodb-insert': insert_entry_command,
            'mongodb-update': update_entry_command,
            'mongodb-delete': delete_entry_command,
            'mongodb-list-collections': list_collections_command,
            'mongodb-create-collection': create_collection_command,
            'mongodb-drop-collection': drop_collection_command,
        }
        try:
            return_outputs(*commands[command](client, **args))  # type: ignore[operator]
        except Exception as e:
            return_error(f'MongoDB: {str(e)}', error=e)


    if __name__ in ('builtins', '__builtin__'):
        main()
  subtype: python3
  type: python
system: true
