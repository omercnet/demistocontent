category: Endpoint
commonfields:
  id: Malwarebytes
  version: -1
configuration:
- defaultvalue: ""
  display: Account ID
  name: accountid
  required: true
  type: 0
- defaultvalue: ""
  display: Client ID
  name: clientid
  required: true
  type: 0
- defaultvalue: ""
  display: Client Secret
  name: clientsecret
  required: true
  type: 4
- defaultvalue: ""
  display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- defaultvalue: ""
  display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: RTP Detections (EP)
  display: Fetch Event List
  name: Fetch_Event_List
  options:
  - Suspicious Activity (EPR)
  - RTP Detections (EP)
  required: false
  type: 15
- defaultvalue: Malware
  display: RTP Detections Threat Category
  name: rtp_threat_category
  options:
  - Malware
  - PUP
  - PUM
  - Exploit
  - Ransomware
  - Website
  required: false
  type: 16
- defaultvalue: High
  display: Suspicious Activity Severity
  name: suspicious_activity_severity
  options:
  - High
  - Medium
  - Low
  required: false
  type: 16
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Scan and Remediate threats on endpoints in the Malwarebytes cloud.
detaileddescription: "# Malwarebytes Cloud | NEBULA\nMalwarebytes Cloud integrates
  with Demisto for interactions with Incident Response, Endpoint Protection, and Endpoint
  Protection and Response products.\n\nMalwarebytes makes endpoints resilient through
  adaptive cyber protection, active threat response and orchestrated endpoint control
  that quickly restores workforce productivity when a compromise occurs. \n\nOur adaptive
  cyber protection predicts and detects attacks with multi-layer detection across
  the kill chain. \n\nWe enable active threat response where machine learning is actionable
  and automated allowing for full recovery when a compromise occurs.\n \nWe orchestrate
  command and control across siloed IT and Security organizations simplifying security
  management and making response effective. Malwarebytes makes endpoints resilient,
  so that you can protect, remediate, and regain control of your digital business.\n\n\n##
  Requirements\nTo run the Malwarebytes Integration, you need:\n\n1. An active Malwarebytes
  Cloud | Nebula platform subscription.\n2. Malwarebytes Nebula platform login credentials.\n\n##
  Generating Credentials\n\n1. To get your Cloud Console Account Id:\n    1. Log into
  the Cloud Console [link](https://cloud.malwarebytes.com).\n    2. Copy the following
  string of characters found in the url and paste into account_id in integration config.\n
  \       ![DOC-3239-3](https://user-images.githubusercontent.com/48316606/77554197-6d9bf380-6ebe-11ea-8986-cd9aa5867375.png)\n2.
  To get your Cloud Console Client Id and Cloud Console Client Secret:\n    1. Click
  this [link](https://cloud.malwarebytes.com/auth/credentials).\n    2. Enter your
  Malwarebytes Nebula administrator credentials and click LOG IN.\n    3. On the Client
  Credentials screen, click Generate Credentials > YES, GENERATE.\n        ![DOC-3239-4](https://user-images.githubusercontent.com/48316606/77554273-886e6800-6ebe-11ea-9c54-726f2bf07319.png)\n
  \       ![DOC-3239-5](https://user-images.githubusercontent.com/48316606/77554282-8c9a8580-6ebe-11ea-83fb-372d68bccecb.jpg)\n
  \   4. Copy Client ID and Client Secret and paste into Integration config.\n    \n##
  Testing Connectivity\n\n- Click 'Test' in integration config to test connectivity
  to Malwarebytes Cloud.\n"
display: Malwarebytes
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA3hpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTQwIDc5LjE2MDQ1MSwgMjAxNy8wNS8wNi0wMTowODoyMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDpmYzRlNGJjNy1lYzZlLTQ3MWItOTM4NC0xNWMzODRkZmNkMjMiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6Qzc4MDk5NTQ3OEM4MTFFQUE5OTNGOTI5RTYxRDAyNUMiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6Qzc4MDk5NTM3OEM4MTFFQUE5OTNGOTI5RTYxRDAyNUMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTggKE1hY2ludG9zaCkiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpmYzRlNGJjNy1lYzZlLTQ3MWItOTM4NC0xNWMzODRkZmNkMjMiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6ZmM0ZTRiYzctZWM2ZS00NzFiLTkzODQtMTVjMzg0ZGZjZDIzIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+zXvV+gAAB7JJREFUeNrsXAdsVVUYvnRQkS27ILLDMIiAi6UoIQpIlRWJhmkERE1QQEAJBpWtMRZcjCCIjIrKEjUSIigBoSwpsioWK1IgrEIrtPD8fvOd5Pf63ut78CBC/j/5cnrPvuf717mPUCwQCHgmN67E2REYwSZGsIkRbGIEmxjBJkawiRFsBJsYwSZGsIkRbGIEmxjBJkawCaR02y0Vo+hb+QrWKQW0AHoBN1+H57QOOHBdWTA23A1FNsohEbzgJBQHUD54meu+C2wBFgOVr0NbqAkkxFhpagDtrgrBmPg+FIuAJOA9PD9bBLkvy5/ACjw3sdAQE1kJLI85wSCoOMq5QKKqn4H6UWHIdSLudQ7qixk//08RN9MTaBCkbSKI83LXt5wUglwndwMPA6vpsocBEstLALnAPmAJ5vmmCBfVFYWEiUvAUPTPZ70oWkN2m4b6Xax/HEUKIP+o7BmgC8tb6IlOAb8ACzFmnVqnKYq2wGlgKcckoc8UtndE0R9oTAU+LJ5Kwgr6XPAZh/TtxP0lcb0p6Pcb2kbg7wrAGDxf8r1rMxT9gDSgBtAIuBUoibZ32C0X48ayfxe+ayUgn+FtNtpPsT0exdPAA+wj6x0FvhWCe4c594kcXAYYGaafzLEaKM+D1tIGGIB55mFDfcPMUQ5w7e8DmzFGlGQccBPrj6p9PAl0B3Iwb4HEMCqalvuBwWibij5u3HgeVg4gSltdDkKIQb/BXFtLPaAdlSJF1QshorQXgUygLA+4K+apj7IuMIhud4NvziFUrDlAZxnDMy5G5RKlPQiMxVyieCNoLBlc5wkxArS1xHud4DuNAU7QoMQrS+isKATfU4SVvxGBJ3BzrAcGAmeBQiAZeJ4eog82JNb0dYg5tqu/RcM3Ax0UuR6VZ6TqI7JVxbBcru0IkIOpJiXX3qbmqqL+vkhFHs/ns3zvbL5PexLXBHNksI9Ys+Qqaag7w/FLqQQdaJ2DqIQblPVKP/E+ezFup5wL63egqIW6sqqvnN+LwG6gFdpOs74/lWMo8DrPpQCo4/poF10xBq7+n8PC5Ee5sHZH4lLX8lGsIBTBu3loxRV5j6rDlPpGmK8uLbku27Zx7YPUer22WOkCPrZ2fZUcAkYxm29A9ybyMeabzDlkv8eVIjuC89FntpsIf4uSfE+CxTV/BRxj2HlJrenc6Ie+vQQILS0AUYjPfcSl8Zxb8lnyp/PAmWAx2B2eExlYm1obTNZy4720BfgOthoVRzZXSjWVDKUheIFCKkNzIZiJmyP4NWA442tXWncwy/foqivQ3ZX0vet/8gesm8Nx2lMkME56nMdJmSIUPeAjfJnERrnz4zmdTT1ZLonAcCqo96ql6t2enLUfYRyX5HiWKDLWC7iXPsQ44zE4j6aLWhmE5LV0B9V8BO/lJiRWzQyRtEUi20hwUyZvVVm/jEnPUyS4wDdG1hbLmc6kJVI5H6J+EHGlspTJj7jkdOwxjhadAQJ+jmKeV4lQMpoKM4TIwVqrxH0LwWsUwXvoZl3mpkkWV9Ud7XmSVKD9MGOsyCo8i7V8yUQri3HnApOnlCgI9mj17oV+xZq7Mf8KEtyG83qMuZmMVYuZyYqypVMJqjMeRisyx54g9fujnEfO9iTQg+/Tmu45Ncp5FjIR9Es2vcUmnEFtGoVk9Y9JYgvclcA7sNPWc8rF5CmSxaJ7+K4J+SohkXhyJ8kVd92c2Z0oSqsgBBeGcJ3bfQmVxyuKx4y1kP07uv7iirBGW5IrazZD3V9cu0cUBOurzHKVdUcjib6wI9n9F7xFNFJeLy3C+fJYpmOuueE68iq2UYC15OYhCVzjODRspAv0mMQkapJ59eimyUUfsUoXE4ah7bgiPN5ZNvuNC7KfI+rvnuhXidnlziCJxgruRZKMH0Jk3u4gklyihPmqMoGKVDKVZ+h8md/a3W3iD19C5JFcyah34V32hBif5HvOYnl7NJtg/BXDCzjrGUD3WJP3y7mq84UgcwxkoB+O9lnKvW5lDN2BA/qTMTQ+yPjPGDckJk0g+mKuefyIX5/9JCtcpy2LWajnuyKt4WHcJi6d2XOyL0Eq6lDOYdwMfqiReH+Y8xQwWZuMPtP0Vzy0p9IFyzr30ltk+vbs3PQrtPBQ7lnO6w7MOZ0KsoDJpChxP/mBRs6VHrIKz3km9jQfbbOpnL/T0BrSXe+L48uJa3uIsWcaBtQL88WpDopH5MqDcW/5XERnbiyf8S+fSddBEnCMfbcznmYHWeI79hUsEjfns+YshZ+Up2lPBbjIteVQP1J9Tynv4eoKfWuPYLburkLJVJrivgz6R87znHyMYHyVK82nsg/s57x20yg+UJ5pSZjvDft5t5ZbQzLPtBPPtCPvvBP4QegSv8Z5/F1AvMObwNv8iJJBQ/wXeaKV8vUqC+ij3fVl/DqSEGE/cc/l6aJj9ctMYozmKRdJn6J+8kR7EnAS2BTBfPFh2kqFeze56vE8S3hB7ni6Y2lmYuIqP4Em7bPP9lekKCm8YbyAs0y9lmsnhIhHcv2Yb9TETHozHCy61gvbz3xX33rdL1trYDhdrjnB9l843Nhi/7LCCDYxgk2MYBMj2MQINjGCTYxgI9jECDYxgk2MYBMj2MQINgktfwswAP4twzyKjpApAAAAAElFTkSuQmCC
name: Malwarebytes
script:
  commands:
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Initiate Scan and Remediate action on an endpoint based on IP or
      Hostname.
    name: malwarebytes-scan-and-remediate
    outputs:
    - contextPath: Malwarebytes.Scan.Machine_ID
      description: Endpoint ID of the host
      type: string
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job ID of the scanned host
      type: string
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Initiate Scan and report action on an endpoint based on IP or Hostname.
    name: malwarebytes-scan-and-report
    outputs:
    - contextPath: Malwarebytes.Scan.Machine_ID
      description: Endpoint ID of the host
      type: string
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job ID of the scanned host
      type: string
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Initiate Isolation action on an endpoint based on IP or Hostname.
      This action isolate an endpoint by Process, Network and Desktop.
    name: malwarebytes-isolate-endpoint
    outputs:
    - contextPath: Malwarebytes.Scan.Machine_ID
      description: Endpoint ID of the host
      type: string
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job ID of the scanned host
      type: string
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Initiate Process Isolation action on an endpoint based on IP or Hostname.
    name: malwarebytes-isolate-process
    outputs:
    - contextPath: Malwarebytes.Scan.Machine_ID
      description: Endpoint ID of the host
      type: string
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job ID of the scanned host
      type: string
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Initiate Desktop Isolation action on an endpoint based on IP or Hostname.
    name: malwarebytes-isolate-desktop
    outputs:
    - contextPath: Malwarebytes.Scan.Machine_ID
      description: Endpoint ID of the host
      type: string
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job ID of the scanned host
      type: string
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Initiate Network Isolation action on an endpoint based on IP or Hostname.
    name: malwarebytes-isolate-network
    outputs:
    - contextPath: Malwarebytes.Scan.Machine_ID
      description: Endpoint ID of the host
      type: string
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job ID of the scanned host
      type: string
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Initiate Deisolation action on an endpoint based on IP or Hostname.
      This action deisolate an endpoint by Process, Network and Desktop.
    name: malwarebytes-deisolate-endpoint
    outputs:
    - contextPath: Malwarebytes.Scan.Machine_ID
      description: Endpoint ID of the host
      type: string
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job ID of the scanned host
      type: string
  - arguments:
    - auto: PREDEFINED
      defaultValue: all
      description: Enter value 'all' to get all endpoints and value 'online' or 'offline'
        to get online/offline endpoints.
      name: endpoints
      predefined:
      - all
      - online
      - offline
    description: List all/online/offline endpoints available in the Malwarebytes Cloud.
    name: malwarebytes-list-endpoints
    outputs:
    - contextPath: Malwarebytes.Endpoint.total_count
      description: total count of all/online/offline endpoints.
      type: int
  - arguments:
    - description: Hostname of an endpoint in Malwarebytes Cloud.
      name: hostname
    - description: IP of an endpoint in Malwarebytes Cloud.
      name: ip
    description: Lists more granular information about an endpoint.
    name: malwarebytes-list-endpoint-info
    outputs:
    - contextPath: Malwarebytes.Endpoint.Assets
      description: Asset information of the endpoint.
      type: string
    - contextPath: Malwarebytes.Endpoint.Hostname
      description: The hostname that is mapped to this endpoint.
      type: string
    - contextPath: Malwarebytes.Endpoint.IPAddress
      description: The IP address of the endpoint.
      type: string
    - contextPath: Malwarebytes.Endpoint.Domain
      description: The domain of the endpoint.
      type: string
    - contextPath: Malwarebytes.Endpoint.MACAddress
      description: The MAC address of the endpoint.
      type: string
    - contextPath: Malwarebytes.Endpoint.OS
      description: Endpoint OS.
      type: string
    - contextPath: Malwarebytes.Endpoint.OSVersion
      description: OS version.
      type: string
    - contextPath: Malwarebytes.Endpoint.Model
      description: The model of the machine or device.
      type: string
    - contextPath: Malwarebytes.Endpoint.Memory
      description: Memory on this endpoint.
      type: int
    - contextPath: Endpoint.Hostname
      description: The hostname that is mapped to this endpoint.
      type: string
    - contextPath: Endpoint.IPAddress
      description: The IP address of the endpoint.
      type: string
    - contextPath: Endpoint.Domain
      description: The domain of the endpoint.
      type: string
    - contextPath: Endpoint.MACAddress
      description: The MAC address of the endpoint.
      type: string
    - contextPath: Endpoint.OS
      description: Endpoint OS.
      type: string
    - contextPath: Endpoint.OSVersion
      description: OS version.
      type: string
    - contextPath: Endpoint.Model
      description: The model of the machine or device.
      type: string
    - contextPath: Endpoint.Memory
      description: Memory on this endpoint.
      type: int
  - arguments:
    - description: Job ID of the initiated Scan actions only.
      name: job_id
      required: true
    description: Lists detections from an endpoint for the scans initiated from Demisto.
    name: malwarebytes-get-scan-detections
    outputs:
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job_Id of the initiated Scan/Isolation/Deisolation actions.
      type: string
    - contextPath: Malwarebytes.Scan.Status
      description: Scan Status for the host
      type: string
    - contextPath: Malwarebytes.Scan.Detections
      description: Scan detections for the host
      type: string
  - arguments:
    - description: Job_Id of the initiated Scan/Isolation/Deisolation actions.
      name: job_id
      required: true
    description: Lists scan/isolation/deisolation status of the endpoint for the scan/isolation/deisolation
      initated from Demisto.
    name: malwarebytes-get-job-status
    outputs:
    - contextPath: Malwarebytes.Scan.Job_ID
      description: Job_Id of the initiated Scan/Isolation/Deisolation actions.
      type: string
    - contextPath: Malwarebytes.Scan.Status
      description: Scan Status for the host
      type: string
  - arguments:
    - description: Machine ID of an endpoint where Suspicious Activity is found.
      name: machine_id
      required: true
    - description: Detection ID of the Suspicious Activity.
      name: detection_id
      required: true
    description: Open Suspicious Activity for investigation in Malwarebytes Cloud.
      Use malwarebytes-get-sa-activities command to get machine and detection ID.
    name: malwarebytes-open-sa-incident
    outputs:
    - contextPath: Malwarebytes.SA.Machine_ID
      description: Machine ID of the Suspicious host
      type: string
  - arguments:
    - description: Machine ID of an endpoint in Malwarebytes Cloud where Suspicious
        Activity is found.
      name: machine_id
      required: true
    - description: Detection ID of the Suspicious Activity
      name: detection_id
      required: true
    description: Remediate Suspicious Activity from Malwarebytes Cloud. Use malwarebytes-get-sa-activities
      command to get machine and detection ID.
    name: malwarebytes-remediate-sa-incident
    outputs:
    - contextPath: Malwarebytes.SA.Machine_ID
      description: Machine ID of the Suspicious host
      type: string
  - arguments:
    - description: Machine ID of an endpoint in Malwarebytes Cloud where Suspicious
        Activity is found.
      name: machine_id
      required: true
    - description: Detection ID of the Suspicious Activity.
      name: detection_id
      required: true
    description: Close Suspicious Activity Incident in Malwarebytes Cloud. Use malwarebytes-get-sa-activities
      command to get machine and detection ID.
    name: malwarebytes-close-sa-incident
    outputs:
    - contextPath: Malwarebytes.SA.Machine_ID
      description: Machine ID of the Suspicious host
      type: string
  - arguments:
    - description: Hostname of the endpoint.
      name: hostname
    - description: Path of the file to be searched in suspicious activities.
      name: path
    description: Lists all suspicious activities from hostname value and list all
      the hostnames from path of file.
    name: malwarebytes-get-sa-activities
    outputs:
    - contextPath: Malwarebytes.Endpoint.Suspicious_Activities
      description: Suspicious Activities for the host
      type: string
  dockerimage: demisto/oauthlib:1.0.0.7727
  isfetch: true
  runonce: false
  script: |2



    """ IMPORTS """

    import requests
    from requests_oauthlib import OAuth2Session
    from oauthlib.oauth2 import BackendApplicationClient
    import json
    import traceback
    import time
    from typing import Dict

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    '''GLOBAL/PARAMS'''
    URL = 'https://cloud.malwarebytes.com'


    # Get OAuth2 token
    def nebula_url(path):
        return "{NEBULA_URL}{PATH}".format(NEBULA_URL="https://cloud.malwarebytes.com", PATH=path)


    def get_nebula_client(client_id, client_secret, account_id, use_ssl):
        client_scope = ["read", "write", "execute"]
        headers = {"x-mwb-clientid": client_id,
                   "x-mwb-accountid": account_id}

        client = BackendApplicationClient(client_id, scope=client_scope)
        nebula = OAuth2Session(client=client, scope=client_scope)
        nebula.headers.update(headers)
        token = nebula.fetch_token(
            token_url=nebula_url('/oauth2/token'),
            client_secret=client_secret, scope=client_scope,
            verify=use_ssl
        )

        return "Bearer " + token.get('access_token')


    # Test connectivity to the Nebula cloud
    def test_connectivity(account_id, client_id, auth_token, USE_SSL):

        url = 'https://cloud.malwarebytes.com/api/v2/endpoints'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)

        if response.status_code == 200:
            return True
        else:
            raise Exception(response.text)


    # Get all the endpoints from the Malwarebytes Cloud
    def get_all_endpoints(account_id, client_id, auth_token, USE_SSL):

        url = 'https://cloud.malwarebytes.com/api/v2/endpoints'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)

        if response.status_code == 200:
            try:
                machine_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            machines = machine_json['machines']
            cursor = machine_json['next_cursor']
            while cursor != "":
                cursor_temp, machines_temp = get_all_endpoints_paginated(account_id, client_id, auth_token, cursor, USE_SSL)
                machines.extend(machines_temp)
                cursor = cursor_temp
            return machines
        else:
            raise Exception(response.text)


    def get_all_endpoints_paginated(account_id, client_id, auth_token, cursor, USE_SSL):

        url = 'https://cloud.malwarebytes.com/api/v2/endpoints?next_cursor=' + cursor

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)

        if response.status_code == 200:
            try:
                machine_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            machines = machine_json['machines']
            cursor = machine_json['next_cursor']
            return cursor, machines
        else:
            return False


    # Get the scan status to acquire the scan info
    def get_scan_status(account_id, client_id, auth_token, job_id, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/jobs/' + str(job_id)
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                scan_status_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            scan_status = scan_status_json['state']
            return scan_status
        else:
            raise Exception(response.text)


    # Get the scanid for the scan jobs initiated
    def get_scan_id(account_id, client_id, auth_token, job_id, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/jobs/' + str(job_id)
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                scan_id_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            scan_id = scan_id_json['scan_id']
            return scan_id
        else:
            raise Exception(response.text)


    # Get the machine_id associated with scan_id
    def get_scan_id_machine(account_id, client_id, auth_token, job_id, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/jobs/' + str(job_id)
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                scan_id_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            machine_id = scan_id_json['machine_id']
            return machine_id
        else:
            raise Exception(response.text)


    # Get detections for the scan jobs initiated
    def get_scan_detections(account_id, client_id, auth_token, ids, scan_id, USE_SSL):

        url = 'https://cloud.malwarebytes.com'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = url + '/api/v2/endpoints/' + str(ids) + '/scans/' + str(scan_id) + '/detections'
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                detection_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            detections = detection_json['detections']
            cursor = detection_json['next_cursor']
            while cursor != "":
                cursor_temp, detections_temp = get_scan_detections_paginated(account_id, client_id, auth_token, ids, scan_id, cursor,
                                                                             USE_SSL)
                detections.extend(detections_temp)
                cursor = cursor_temp
            return detections
        else:
            raise Exception(response.text)


    def get_scan_detections_paginated(account_id, client_id, auth_token, ids, scan_id, cursor, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/endpoints/' + str(ids) + '/scans/' + str(
            scan_id) + '/detections?next_cursor=' + cursor
        response = requests.request("GET", url, headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                detection_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            detections = detection_json['detections']
            cursor = detection_json['next_cursor']

            return cursor, detections
        else:
            raise Exception(response.text)


    # Get Suspicious Activities found on all the endpoints
    def get_suspicious_activities(account_id, client_id, auth_token, USE_SSL):

        url = 'https://cloud.malwarebytes.com/api/v2/sa'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        response = requests.request("GET", url, headers=headers, verify=USE_SSL)

        if response.status_code == 200:
            try:
                sa_detections_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            sa_detection = sa_detections_json['sa']
            cursor = sa_detections_json['next_cursor']
            while cursor != "":
                cursor_temp, sa_detections_temp = get_suspicious_activities_paginated(account_id, client_id, auth_token, cursor,
                                                                                      USE_SSL)
                sa_detection.extend(sa_detections_temp)
                cursor = cursor_temp

            return sa_detection
        else:
            raise Exception(response.text)


    def get_suspicious_activities_paginated(account_id, client_id, auth_token, cursor, USE_SSL):

        url = 'https://cloud.malwarebytes.com/api/v2/sa?next_cursor' + cursor

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        response = requests.request("GET", url, headers=headers, verify=USE_SSL)

        if response.status_code == 200:
            try:
                sa_detections_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            sa_detection = sa_detections_json['sa']
            cursor = sa_detections_json['next_cursor']

            return cursor, sa_detection
        else:
            return False, False


    # Get RTP Detections found on all the endpoints
    def get_rtp_detections(account_id, client_id, auth_token, USE_SSL):
        url = 'https://cloud.malwarebytes.com/api/v2/detections/search'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        body: Dict[str, bool] = {"is_rtp_stream_event": True}
        response = requests.post(url, data=json.dumps(body), headers=headers, verify=USE_SSL)

        if response.status_code == 200:
            try:
                rtp_detections_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            detections = rtp_detections_json['detections']
            cursor = rtp_detections_json['next_cursor']
            while cursor != "":
                cursor_temp, detections_temp = get_rtp_detections_paginated(account_id, client_id, auth_token, cursor, USE_SSL)
                detections.extend(detections_temp)
                cursor = cursor_temp
            return detections
        else:
            raise Exception(response.text)


    def get_rtp_detections_paginated(account_id, client_id, auth_token, cursor, USE_SSL):

        url = 'https://cloud.malwarebytes.com/api/v2/detections/search' + cursor

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        body: Dict[str, bool] = {"is_rtp_stream_event": True}
        response = requests.post(url, data=json.dumps(body), headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                rtp_detections_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            detections = rtp_detections_json['detections']
            cursor = rtp_detections_json['next_cursor']
            return cursor, detections
        else:
            raise Exception(response.text)


    # Resolve machine_id from IP Address
    def get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/endpoints'

        data = {
            "nics.ips": ip
        }

        response = requests.post(url, data=json.dumps(data), headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                machine_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            if len(machine_json['machines']) != 0:
                machine_id = machine_json['machines'][0]
                machine_id = machine_id['machine']['id']
                return machine_id
            else:
                return False
        else:
            raise Exception(response.text)


    # Resolve machine_id from Hostname
    def get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/endpoints'

        data = {
            "fully_qualified_host_name_partial": hostname
        }

        response = requests.post(url, data=json.dumps(data), headers=headers, verify=USE_SSL)
        if response.status_code == 200:
            try:
                machine_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            if len(machine_json['machines']) != 0:
                machine_id = machine_json['machines'][0]
                machine_id = machine_id['machine']['id']
                return machine_id
            else:
                return False
        else:
            raise Exception(response.text)


    # Initiate POST Request for scan and report
    def post_scan_report(account_id, client_id, auth_token, ids, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/jobs'
        scan = {
            "command": "command.threat.scan",
            "data": {"scan_settings": {"type": "ThreatScan", "remove": False}},
            "machine_ids": [ids]}
        response = requests.post(url, data=json.dumps(scan), headers=headers, verify=USE_SSL)

        if response.status_code == 201:
            try:
                scan_result_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            job_id = scan_result_json['jobs'][0]
            job_id = job_id['job_id']
            return job_id
        else:
            raise Exception(response.text)


    # Initiate POST Request for scan and quarantine
    def post_scan_remediate(account_id, client_id, auth_token, ids, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/jobs'
        scan = {
            "command": "command.threat.scan",
            "data": {"scan_settings": {"type": "ThreatScan", "remove": True}},
            "machine_ids": [ids]}
        response = requests.post(url, data=json.dumps(scan), headers=headers, verify=USE_SSL)
        if response.status_code == 201:
            try:
                scan_result_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            job_id = scan_result_json['jobs'][0]
            job_id = job_id['job_id']
            return job_id
        else:
            raise Exception(response.text)


    # Initiate POST Request for Isolate actions
    def post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/jobs/endpoints/isolate'

        if isolated == 'isolate':
            isolate = {"data": {"desktop": True, "network": True, "process": True}, "machine_ids": [ids]}

        elif isolated == 'desktop_isolate':
            isolate = {"data": {"desktop": True, "network": False, "process": False}, "machine_ids": [ids]}

        elif isolated == 'network_isolate':
            isolate = {"data": {"desktop": False, "network": True, "process": False}, "machine_ids": [ids]}

        elif isolated == 'process_isolate':
            isolate = {"data": {"desktop": False, "network": False, "process": True}, "machine_ids": [ids]}

        response = requests.post(url, data=json.dumps(isolate), headers=headers, verify=USE_SSL)

        if response.status_code == 201:
            try:
                isolate_result_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            job_id = isolate_result_json['jobs'][0]
            job_id = job_id['job_id']
            return job_id
        else:
            raise Exception(response.text)


    # Initiate POST Request for deisolation
    def post_deisolate(account_id, client_id, auth_token, ids, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/jobs/endpoints/unlock'
        deisolate = {"machine_ids": [ids]}
        response = requests.post(url, data=json.dumps(deisolate), headers=headers, verify=USE_SSL)

        if response.status_code == 201:
            try:
                deisolate_result_json = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            job_id = deisolate_result_json['jobs'][0]
            job_id = job_id['job_id']
            return job_id
        else:
            raise Exception(response.text)


    # Get endpoint info
    def get_endpoint_info(account_id, client_id, auth_token, ids, USE_SSL):

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = URL + '/api/v2/endpoints/' + ids + '/assets'

        response = requests.request("GET", url, headers=headers, verify=USE_SSL)

        if response.status_code == 200:
            try:
                assets = response.json()
            except Exception:
                raise Exception(f'Failed to parse response to json. response: {response.text}')
            return assets


    # Get Latest High Severity Suspicious Activities to create incidents
    def fetch_suspicious_activities(suspicious_activities, suspicious_activity_severity, last_fetch_time, last_custom):

        if last_custom is not None and last_custom != suspicious_activity_severity:
            demisto.setLastRun({'time': None, 'custom': None})
            return False, False

        asc_suspicious_activities = []

        if len(suspicious_activities) != 0:
            for i in reversed(suspicious_activities):
                asc_suspicious_activities.append(i)
        else:
            return False, False

        SA_severity = []
        for i in suspicious_activity_severity:
            SA_severity.append(severity_text_to_number(i))

        Filtered_SA = []

        if len(asc_suspicious_activities) != 0:

            if last_fetch_time is None and last_custom is None:
                demisto.setLastRun({'time': asc_suspicious_activities[-1]['timestamp'], 'custom': suspicious_activity_severity})
                return False, False

            else:
                last_count = 0
                for i in asc_suspicious_activities:
                    if i['level'] in SA_severity and i['status'] == 'detected' and i['timestamp'] > last_fetch_time:
                        Filtered_SA.append(i)

                if len(Filtered_SA) != 0:
                    incident = {'name': "Malwarebytes Suspicious Activity Incident Detected on Host: "
                                        + str(Filtered_SA[last_count]["pc_hostname"]),
                                'occurred': str(Filtered_SA[last_count]["timestamp"]),
                                'severity': 3,
                                'rawJSON': json.dumps(Filtered_SA[last_count])}
                    lastPointer = {'time': Filtered_SA[last_count]["timestamp"], 'custom': suspicious_activity_severity}
                    return lastPointer, incident
                else:
                    return False, False
        else:
            return False, False


    # Get Real Time Protection Detections to Create Incidents
    def fetch_rtp_detections(category, rtp_detections, last_fetch_time, last_custom):

        if last_custom is not None and last_custom != category:
            demisto.setLastRun({'time': None, 'custom': None})
            return False, False

        asc_rtp_events_by_category = []
        if len(rtp_detections) != 0:
            if last_fetch_time is None and last_custom is None:
                demisto.setLastRun({'time': rtp_detections[-1]['reported_at'], 'custom': category})
                return False, False
            else:
                last_count = 0
                for i in rtp_detections:
                    if i['category'] in category and i['reported_at'] > last_fetch_time:
                        asc_rtp_events_by_category.append(i)
                if len(asc_rtp_events_by_category) != 0:
                    incident = {'name': "Malwarebytes RTP has protected against threat "
                                        + str(asc_rtp_events_by_category[last_count]["threat_name"]) + " on Host: "
                                        + str(asc_rtp_events_by_category[last_count]["machine_name"]),
                                'occurred': str(asc_rtp_events_by_category[last_count]["reported_at"]),
                                'severity': 3,
                                'rawJSON': json.dumps(asc_rtp_events_by_category[last_count])}
                    lastPointer = {'time': asc_rtp_events_by_category[last_count]["reported_at"], 'custom': category}
                    return lastPointer, incident
                else:
                    return False, False
        else:
            return False, False


    # Convert Text Category to Malwarebytes Category
    def category_to_code(rtp_malware_category):

        if rtp_malware_category == 'Malware':
            return 'MALWARE'
        elif rtp_malware_category == 'PUP':
            return 'PUP'
        elif rtp_malware_category == 'PUM':
            return 'PUM'
        elif rtp_malware_category == 'Exploit':
            return 'AE'
        elif rtp_malware_category == 'Ransomware':
            return 'ARW'
        elif rtp_malware_category == 'Website':
            return 'MWAC'


    # Remove empty fields from Scan Detections
    def remove_empty_detection_fields(detections):
        for i in detections:
            del i['affected_application'], i['detection_id_from_endpoint'], i['group_id'], i['id'], i['ip_address'], i[
                'md5'], i['port'], i['process_name'], i['scan_id'], i['scanned_at'], i[
                'scanned_at_local'], i['url']


    # Convert Severity Text to Severity Number
    def severity_text_to_number(suspicious_activity_severity):

        if suspicious_activity_severity == 'High':
            return 3
        elif suspicious_activity_severity == 'Medium':
            return 2
        elif suspicious_activity_severity == 'Low':
            return 1


    # Function to execute Scan and Remediate action
    def scan_and_remediate(account_id, client_id, auth_token, ip, hostname, USE_SSL):

        # This is the call made initiating scan_and_remediate action
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                job_id = post_scan_remediate(account_id, client_id, auth_token, ids, USE_SSL)
                return_outputs(
                    'Scan and Remediate action has been successfully started on the Endpoint: ' + str(ip)
                    + ' with the job_id: ' + str(job_id)
                    + '. Use job_id in malwarebytes-get-job-status command to check status and '
                      'malwarebytes-get-scan-detections command to view results',
                    outputs={
                        'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                            'Machine_ID': ids,
                            'Job_ID': job_id
                        }
                    }
                )
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                job_id = post_scan_remediate(account_id, client_id, auth_token, ids, USE_SSL)
                return_outputs(
                    'Scan and Remediate action has been successfully started on the Endpoint: ' + str(hostname)
                    + ' with the job_id: ' + str(job_id)
                    + '. Use job_id in malwarebytes-get-job-status command to check status and '
                      'malwarebytes-get-scan-detections command to view results',
                    outputs={
                        'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                            'Machine_ID': ids,
                            'Job_ID': job_id
                        }
                    }
                )
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        else:
            return_error(message="Please Enter IP or Hostname", error='')


    # Function to execute Scan and Report action
    def scan_and_report(account_id, client_id, auth_token, ip, hostname, USE_SSL):
        # This is the call made initiating scan_and_report action
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                job_id = post_scan_report(account_id, client_id, auth_token, ids, USE_SSL)
                return_outputs(
                    'Scan and Report action has been successfully started on the Endpoint: ' + str(ip)
                    + ' with the job_id: ' + str(job_id)
                    + '. Use job_id in malwarebytes-get-job-status command to check status and '
                      'malwarebytes-get-scan-detections command to view results',
                    outputs={
                        'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                            'Machine_ID': ids,
                            'Job_ID': job_id
                        }
                    }
                )
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                job_id = post_scan_report(account_id, client_id, auth_token, ids, USE_SSL)
                return_outputs(
                    'Scan and Report action has been successfully started on the Endpoint: ' + str(hostname)
                    + ' with the job_id: ' + str(job_id)
                    + '. Use job_id in malwarebytes-get-job-status command to check status and '
                      'malwarebytes-get-scan-detections command to view results',
                    outputs={
                        'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                            'Machine_ID': ids,
                            'Job_ID': job_id
                        }
                    }
                )
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        else:
            return_error(message="Please Enter IP or Hostname", error='')


    # Functions to execute Isolate Command
    def isolate_endpoint(account_id, client_id, auth_token, ip, hostname, USE_SSL):
        # This is the call made initiating Isolate Endpoint action
        isolated = 'isolate'
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Isolation action has been successfully started on the Endpoint: ' + str(ip)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Isolation action Failed for the Endpoint: ' + str(ip), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Isolation action has been successfully started on the Endpoint: ' + str(hostname)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Isolation action Failed for the Endpoint: ' + str(hostname), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        else:
            return_error(message="Please Enter IP or Hostname", error='')


    def isolate_process(account_id, client_id, auth_token, ip, hostname, USE_SSL):
        # This is the call made initiating Isolate Process action
        isolated = 'process_isolate'
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Process Isolation action has been successfully started on the Endpoint: ' + str(ip)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Process Isolation action Failed for the Endpoint: ' + str(ip), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Process Isolation action has been successfully started on the Endpoint: ' + str(hostname)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Process Isolation action Failed for the Endpoint: ' + str(hostname), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")
        else:
            return_error(message="Please Enter IP or Hostname", error='')


    def isolate_network(account_id, client_id, auth_token, ip, hostname, USE_SSL):
        # This is the call made initiating Isolate Network action
        isolated = 'network_isolate'
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Network Isolation action has been successfully started on the Endpoint: ' + str(ip)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Network Isolation action Failed for the Endpoint: ' + str(ip), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Network Isolation action has been successfully started on the Endpoint: ' + str(hostname)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Network Isolation action Failed for the Endpoint: ' + str(hostname), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")
        else:
            return_error(message="Please Enter IP or Hostname", error='')


    def isolate_desktop(account_id, client_id, auth_token, ip, hostname, USE_SSL):
        # This is the call made initiating Isolate Desktop action
        isolated = 'desktop_isolate'
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Desktop Isolation action has been successfully started on the Endpoint: ' + str(ip)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Desktop Isolation action Failed for the Endpoint: ' + str(ip), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                job_id = post_isolate(account_id, client_id, auth_token, ids, isolated, USE_SSL)
                if job_id:
                    return_outputs(
                        'Desktop Isolation action has been successfully started on the Endpoint: ' + str(hostname)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Desktop Isolation action Failed for the Endpoint: ' + str(hostname), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")
        else:
            return_error(message="Please Enter IP or Hostname", error='')


    # Function to execute Deisolate Command
    def deisolate_endpoint(account_id, client_id, auth_token, ip, hostname, USE_SSL):
        # This is the call made initiating scan_and_report action
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                job_id = post_deisolate(account_id, client_id, auth_token, ids, USE_SSL)
                if job_id:
                    return_outputs(
                        'Deisolation action has been successfully started on the Endpoint: ' + str(ip)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Deisolation action Failed for the Endpoint: ' + str(ip), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                job_id = post_deisolate(account_id, client_id, auth_token, ids, USE_SSL)
                if job_id:
                    return_outputs(
                        'Deisolation action has been successfully started on the Endpoint: ' + str(hostname)
                        + ' with the job_id: ' + str(job_id)
                        + '. Use job_id in malwarebytes-get-job-status command to view results',
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Machine_ID': ids,
                                'Job_ID': job_id
                            }
                        }
                    )
                else:
                    return_error(message='Deisolation action Failed for the Endpoint: ' + str(hostname), error='')
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")
        else:
            return_error(message="Please Enter IP or Hostname", error='')


    # Function to execute List all endpoints Command
    def list_all_endpoints(account_id, client_id, auth_token, endpoint, USE_SSL):

        machines = get_all_endpoints(account_id, client_id, auth_token, USE_SSL)
        found_machines = []
        if len(machines) != 0:
            if endpoint == 'all':
                found_machines = machines

            elif endpoint == 'online':
                for i in machines:
                    if i['online'] is True:
                        found_machines.append(i)

            elif endpoint == 'offline':
                for i in machines:
                    if i['online'] is False:
                        found_machines.append(i)

            return_outputs(
                readable_output=tableToMarkdown('Found ' + endpoint + ' ' + str(len(found_machines))
                                                + ' Endpoints from Malwarebytes Cloud: ',
                                                found_machines),
                outputs={
                    'Malwarebytes.Endpoint(val.total_count == obj.total_count)': {
                        'total_count': len(found_machines)
                    }
                },
                raw_response=found_machines
            )
        else:
            demisto.results("No Endpoint Found!")


    # Function to execute List endpoint info Command
    def list_endpoint_info(account_id, client_id, auth_token, ip, hostname, USE_SSL):
        # This is the call made initiating get endpoint info action
        if ip:
            ids = get_machine_id_ip(account_id, client_id, auth_token, ip, USE_SSL)
            if ids:
                assets = get_endpoint_info(account_id, client_id, auth_token, ids, USE_SSL)
                return_outputs(
                    readable_output=tableToMarkdown(f'Endpoint Information for the IP: {ip}', assets),
                    outputs={
                        'Malwarebytes.Endpoint(val.Hostname == obj.Hostname)': {
                            'Hostname': assets['host_name'],
                            'IPAddress': assets['nics'],
                            'Domain': assets['domain_name'],
                            'MACAddress': assets['nics'][0]['mac_address'],
                            'OS': assets['os_info']['os_platform'],
                            'OSVersion': assets['os_info']['os_version'],
                            'Model': assets['computer_info']['model'],
                            'Memory': assets['memory'],
                            'Assets': assets
                        },
                        'Endpoint(val.Hostname == obj.Hostname)': {
                            'Hostname': assets['host_name'],
                            'IPAddress': assets['nics'][0]['ips'][0],
                            'Domain': assets['domain_name'],
                            'MACAddress': assets['nics'][0]['mac_address'],
                            'OS': assets['os_info']['os_platform'],
                            'OSVersion': assets['os_info']['os_version'],
                            'Model': assets['computer_info']['model'],
                            'Memory': assets['memory']['total_virtual']
                        }
                    },
                    raw_response=assets
                )
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")

        elif hostname:
            ids = get_machine_id_hostname(account_id, client_id, auth_token, hostname, USE_SSL)
            if ids:
                assets = get_endpoint_info(account_id, client_id, auth_token, ids, USE_SSL)
                return_outputs(
                    readable_output=tableToMarkdown(f'Endpoint Information for the Hostname: {hostname}', assets),
                    outputs={
                        'Malwarebytes.Endpoint(val.Hostname == obj.Hostname)': {
                            'Hostname': assets['host_name'],
                            'IPAddress': assets['nics'],
                            'Domain': assets['domain_name'],
                            'MACAddress': assets['nics'][0]['mac_address'],
                            'OS': assets['os_info']['os_platform'],
                            'OSVersion': assets['os_info']['os_version'],
                            'Model': assets['computer_info']['model'],
                            'Memory': assets['memory'],
                            'Assets': assets
                        },
                        'Endpoint(val.Hostname == obj.Hostname)': {
                            'Hostname': assets['host_name'],
                            'IPAddress': assets['nics'][0]['ips'][0],
                            'Domain': assets['domain_name'],
                            'MACAddress': assets['nics'][0]['mac_address'],
                            'OS': assets['os_info']['os_platform'],
                            'OSVersion': assets['os_info']['os_version'],
                            'Model': assets['computer_info']['model'],
                            'Memory': assets['memory']['total_virtual']
                        }
                    },
                    raw_response=assets
                )
            else:
                demisto.results("Endpoint is not found in the Malwarebytes Cloud")
        else:
            return_error(message="Please Input an IP or Hostname", error='')


    # Function to execute Get Scan Detections Command
    def scan_detections(account_id, client_id, auth_token, job_id, USE_SSL):

        if job_id:
            status = get_scan_status(account_id, client_id, auth_token, job_id, USE_SSL)
            if status == 'COMPLETED':
                scan_id = get_scan_id(account_id, client_id, auth_token, job_id, USE_SSL)
                machine_id = get_scan_id_machine(account_id, client_id, auth_token, job_id, USE_SSL)
                detections = get_scan_detections(account_id, client_id, auth_token, machine_id, scan_id, USE_SSL)
                if len(detections) != 0:
                    remove_empty_detection_fields(detections)
                    return_outputs(
                        readable_output=tableToMarkdown(f'Scan Detections Report for the Job_Id: {job_id}', detections),
                        outputs={
                            'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                                'Job_ID': job_id,
                                'Status': status,
                                'Detections': detections
                            }
                        },
                        raw_response=detections
                    )
                else:
                    demisto.results("Scan has been Completed and No Threats have been found !")
            else:
                demisto.results('Scan Status for the job_id ' + str(job_id) + ' is ' + str(status))

        else:
            return_error(message="Please Enter Job_Id", error='')


    # Function to execute Get Scan Status Command
    def scan_status(account_id, client_id, auth_token, job_id, USE_SSL):

        if job_id:
            status = get_scan_status(account_id, client_id, auth_token, job_id, USE_SSL)
            return_outputs(
                'Scan Status for the job_id ' + str(job_id) + ' is ' + str(status),
                outputs={
                    'Malwarebytes.Scan(val.Job_ID == obj.Job_ID)': {
                        'Job_ID': job_id,
                        'Status': status
                    }
                },
                raw_response=[]
            )

        else:
            return_error(message="Please Enter Job_Id", error='')


    # Function to execute Fetch Incidents Command
    def fetch_incidents(account_id, client_id, auth_token, event_list, USE_SSL):

        incident = None
        lastPointer = None

        if event_list == 'Suspicious Activity (EPR)':

            suspicious_activities = get_suspicious_activities(account_id, client_id, auth_token, USE_SSL)

            # And retrieve it for use later
            lastRun = demisto.getLastRun()
            last_fetch_time = lastRun.get("time")
            last_custom = lastRun.get("custom")
            suspicious_activity_severity = demisto.params().get('suspicious_activity_severity')
            if suspicious_activity_severity:
                lastPointer, incident = fetch_suspicious_activities(suspicious_activities, suspicious_activity_severity,
                                                                    last_fetch_time, last_custom)
            else:
                demisto.incidents([])

        elif event_list == 'RTP Detections (EP)':

            rtp_detections = get_rtp_detections(account_id, client_id, auth_token, USE_SSL)

            # And retrieve it for use later
            lastRun = demisto.getLastRun()
            last_fetch_time = lastRun.get("time")
            last_custom = lastRun.get("custom")
            rtp_malware_category = demisto.params().get('rtp_threat_category')
            category = []
            if rtp_malware_category:
                for i in rtp_malware_category:
                    category.append(category_to_code(i))
                lastPointer, incident = fetch_rtp_detections(category, rtp_detections,
                                                             last_fetch_time, last_custom)
            else:
                demisto.incidents([])

        if incident and lastPointer:
            demisto.incidents([incident])
            # You can store the last run time...
            demisto.setLastRun(lastPointer)
        else:
            demisto.incidents([])


    def get_token(client_id, client_secret, account_id, use_ssl):
        integration_context = demisto.getIntegrationContext()
        token = integration_context.get('access_token')
        valid_until = integration_context.get('valid_until')
        time_now = int(time.time())
        if token and valid_until:
            if time_now < valid_until:
                # Token is still valid - did not expire yet
                return token
        token = get_nebula_client(client_id, client_secret, account_id, use_ssl)
        integration_context = {
            'access_token': token,
            'valid_until': time_now + 3595  # Assuming the expiration time is 1 hour
        }
        demisto.setIntegrationContext(integration_context)
        return token


    # Function to execute Open SA action
    def open_sa_incident(account_id, client_id, auth_token, machine_id, detection_id, USE_SSL):

        url = 'https://cloud.malwarebytes.com'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Authorization': auth_token
        }

        url = url + '/api/v2/endpoints/' + str(machine_id) + '/sa/' + str(detection_id) + '/open'
        response = requests.put(url, data=None, headers=headers, verify=USE_SSL)
        if response.status_code == 201:
            return_outputs(
                "Open SA Incident action is initiated Successfully for the detection id: " + str(detection_id),
                outputs={
                    'Malwarebytes.SA(val.Machine_ID == obj.Machine_ID)': {
                        'Machine_ID': machine_id
                    }
                },
                raw_response=[]
            )
        else:
            raise Exception(response.text)


    # Function to execute Remediate SA action
    def remediate_sa_incident(account_id, client_id, auth_token, machine_id, detection_id, USE_SSL):

        url = 'https://cloud.malwarebytes.com'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Content-Type': "application/json",
            'Authorization': auth_token
        }

        url = url + '/api/v2/endpoints/' + str(machine_id) + '/sa/' + str(detection_id) + '/remediate'
        response = requests.post(url, data=json.dumps({}), headers=headers, verify=USE_SSL)
        if response.status_code == 201:
            return_outputs(
                "Remediate SA Incident action is initiated Successfully for the detection id: " + str(detection_id),
                outputs={
                    'Malwarebytes.SA(val.Machine_ID == obj.Machine_ID)': {
                        'Machine_ID': machine_id
                    }
                },
                raw_response=[]
            )
        elif response.status_code == 404:
            return_error(message="HTTP Error: " + str(response.status_code) + " as threat with detection id: "
                                 + str(detection_id) + " is already remediated", error='')
        else:
            raise Exception(response.text)


    # Function to execute Close Remediate SA action
    def close_sa_incident(account_id, client_id, auth_token, machine_id, detection_id, USE_SSL):

        url = 'https://cloud.malwarebytes.com'

        headers = {
            'X-MWB-AccountID': account_id,
            'X-MWB-ClientID': client_id,
            'Authorization': auth_token
        }

        url = url + '/api/v2/endpoints/' + str(machine_id) + '/sa/' + str(detection_id) + '/close'
        response = requests.put(url, data=None, headers=headers, verify=USE_SSL)
        if response.status_code == 201:
            return_outputs(
                "Close SA Incident action is initiated Successfully for the detection id: " + str(detection_id),
                outputs={
                    'Malwarebytes.SA(val.Machine_ID == obj.Machine_ID)': {
                        'Machine_ID': machine_id
                    }
                },
                raw_response=[]
            )
        else:
            raise Exception(response.text)


    def get_sa_activities_command(account_id, client_id, auth_token, hostname, path, USE_SSL):
        suspicious_activities = get_suspicious_activities(account_id, client_id, auth_token, USE_SSL)
        if hostname:
            Filtered_SA = []
            for i in suspicious_activities:
                if i['pc_hostname'] == hostname:
                    Filtered_SA.append(i)
            if len(Filtered_SA) != 0:
                return_outputs(
                    readable_output=tableToMarkdown(f'Suspicious Activites found for the host: {hostname}', Filtered_SA),
                    outputs={
                        'Malwarebytes.Endpoint(val.Suspicious_Activities == obj.Suspicious_Activities)': {
                            'Suspicious_Activities': Filtered_SA
                        }
                    },
                    raw_response=Filtered_SA
                )
            else:
                demisto.results("No Suspicious Activites found for the host: " + str(hostname))

        elif path:
            Filtered_SA = []
            for i in suspicious_activities:
                if i['path'] == path:
                    Filtered_SA.append(i)
            if len(Filtered_SA) != 0:
                return_outputs(
                    readable_output=tableToMarkdown(f'File Path: {path} is found on the hosts', Filtered_SA),
                    outputs={
                        'Malwarebytes.Endpoint(val.Suspicious_Activities == obj.Suspicious_Activities)': {
                            'Suspicious_Activities': Filtered_SA
                        }
                    },
                    raw_response=Filtered_SA
                )
            else:
                demisto.results("File Path: " + str(path) + " is not found on any hosts.")
        else:
            return_error(message='Please enter hostname or path', error='')


    def main():
        '''CONSTANTS'''
        account_id = demisto.params().get('accountid')
        client_id = demisto.params().get('clientid')
        client_secret = demisto.params().get('clientsecret')
        use_ssl = not demisto.params().get('insecure', False)

        auth_token = get_token(client_id, client_secret, account_id, use_ssl)

        try:
            # Remove proxy if not set to true in params
            handle_proxy()

            # The command demisto.command() holds the command sent from the user.
            LOG(f'command is {demisto.command()}')
            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration test button.
                status = test_connectivity(account_id, client_id, auth_token, use_ssl)
                if status is True:
                    demisto.results('ok')

            elif demisto.command() == 'malwarebytes-scan-and-remediate':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                scan_and_remediate(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-scan-and-report':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                scan_and_report(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-isolate-endpoint':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                isolate_endpoint(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-isolate-process':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                isolate_process(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-isolate-network':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                isolate_network(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-isolate-desktop':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                isolate_desktop(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-deisolate-endpoint':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                deisolate_endpoint(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-list-endpoints':
                endpoint = demisto.args().get('endpoints')
                list_all_endpoints(account_id, client_id, auth_token, endpoint, use_ssl)

            elif demisto.command() == 'malwarebytes-list-endpoint-info':
                ip = demisto.args().get('ip')
                hostname = demisto.args().get('hostname')
                list_endpoint_info(account_id, client_id, auth_token, ip, hostname, use_ssl)

            elif demisto.command() == 'malwarebytes-get-scan-detections':
                job_id = demisto.args().get('job_id')
                scan_detections(account_id, client_id, auth_token, job_id, use_ssl)

            elif demisto.command() == 'malwarebytes-get-job-status':
                job_id = demisto.args().get('job_id')
                scan_status(account_id, client_id, auth_token, job_id, use_ssl)

            elif demisto.command() == 'malwarebytes-open-sa-incident':
                machine_id = demisto.args().get('machine_id')
                detection_id = demisto.args().get('detection_id')
                open_sa_incident(account_id, client_id, auth_token, machine_id, detection_id, use_ssl)

            elif demisto.command() == 'malwarebytes-remediate-sa-incident':
                machine_id = demisto.args().get('machine_id')
                detection_id = demisto.args().get('detection_id')
                remediate_sa_incident(account_id, client_id, auth_token, machine_id, detection_id, use_ssl)

            elif demisto.command() == 'malwarebytes-close-sa-incident':
                machine_id = demisto.args().get('machine_id')
                detection_id = demisto.args().get('detection_id')
                close_sa_incident(account_id, client_id, auth_token, machine_id, detection_id, use_ssl)

            elif demisto.command() == 'malwarebytes-get-sa-activities':
                hostname = demisto.args().get('hostname')
                path = demisto.args().get('path')
                get_sa_activities_command(account_id, client_id, auth_token, hostname, path, use_ssl)

            elif demisto.command() == 'fetch-incidents':
                event_list = demisto.params().get('Fetch_Event_List')
                fetch_incidents(account_id, client_id, auth_token, event_list, use_ssl)

        except Exception as e:
            # Log exceptions
            return_error(f'Failed to execute {demisto.command()} command. Error: {str(e)}{str(traceback.format_exc())}')


    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
