category: IT Services
commonfields:
  id: Azure Compute v2
  version: -1
configuration:
- defaultvalue: https://management.azure.com
  display: Host URL (e.g. https://management.azure.com)
  name: host
  required: true
  type: 0
- defaultvalue: ""
  display: ID (received from the admin consent - see Detailed Instructions (?)
  name: auth_id
  required: true
  type: 4
- defaultvalue: ""
  display: Token (received from the admin consent - see Detailed Instructions (?)
    section)
  name: tenant_id
  required: true
  type: 4
- defaultvalue: ""
  display: Key (received from the admin consent - see Detailed Instructions (?)
  name: enc_key
  required: true
  type: 4
- defaultvalue: ""
  display: Default Subscription ID
  name: subscription_id
  required: false
  type: 4
- defaultvalue: ""
  display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- defaultvalue: ""
  display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- defaultvalue: ""
  display: Use a self-deployed Azure Application
  name: self_deployed
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    propagationLabels:
    - all
description: Create and Manage Azure Virtual Machines
detaileddescription: "To allow us access to Azure Compute, an administrator has to
  approve the Demisto app using an admin consent flow, by clicking [here](https://oproxy.demisto.ninja/ms-azure-compute).\nAfter
  authorizing the Demisto app, you will receive an ID, Token, and Key, which needs
  to be added to the integration instance configuration's corresponding fields. After
  giving consent, the application must have a role assigned, so it can access the
  relevant resources per subscription. \nFor more information, see the integration
  documentation.\n"
display: Azure Compute v2
image: data:image/png;base64,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
name: Azure Compute v2
script:
  commands:
  - arguments:
    - description: The resource group of the virtual machines. To see all the resource
        groups associated with your subscription, run the `azure-list-resource-groups`
        command. If none are present, navigate to the Azure Web Portal to create resource
        groups.
      name: resource_group
      required: true
    description: Lists the virtual machine instances in the given resource group.
    name: azure-vm-list-instances
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Location
      description: The location of the virtual machine.
      type: string
    - contextPath: Azure.Compute.ProvisioningState
      description: The provisioning state of the virtual machine.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group in which the virtual machine resides.
      type: string
    - contextPath: Azure.Compute.ID
      description: The ID of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Size
      description: The size of the deployed virtual machine (in gigabytes).
      type: number
    - contextPath: Azure.Compute.OS
      description: The OS running on the virtual machine.
      type: string
  - arguments:
    - description: Resource Group to which the virtual machine belongs. To see all
        the resource groups associated with your subscription, run the `azure-list-resource-groups`
        command. If none are present, navigate to the Azure Web Portal to create resource
        groups.
      name: resource_group
      required: true
    - description: Name of the virtual machine to power on. To see all virtual machines
        and their associated names for a specific resource group, run the `azure-vm-list-instances`
        command.
      name: virtual_machine_name
      required: true
    description: Powers on a given virtual machine.
    execution: true
    name: azure-vm-start-instance
    outputs:
    - contextPath: Azure.Compute.Name
      description: Name of the VM that was started
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: Resource group the VM resides in
      type: string
    - contextPath: Azure.Compute.PowerState
      description: Whether the VM instance is powered on or off
      type: string
  - arguments:
    - description: The resource group to which the virtual machine belongs. To see
        all the resource groups associated with your subscription, run the `azure-list-resource-groups`
        command. If none are present, navigate to the Azure Web Portal to create resource
        groups.
      name: resource_group
      required: true
    - description: The name of the virtual machine to power off. To see all virtual
        machines with their associated names for a specific resource group, run the
        `azure-vm-list-instances` command.
      name: virtual_machine_name
      required: true
    description: Powers off a given virtual machine.
    execution: true
    name: azure-vm-poweroff-instance
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the virtual machine that was powered off.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group in which the virtual machine resides.
      type: string
    - contextPath: Azure.Compute.PowerState
      description: Whether the virtual machine instance is powered on or off.
      type: string
  - arguments:
    - description: The resource group to which the virtual machine belongs. To see
        all the resource groups associated with your subscription, run the `azure-list-resource-groups`
        command. If none are present, navigate to the Azure Web Portal to create resource
        groups.
      name: resource_group
      required: true
    - description: The name of the virtual machine you want to view the details of.
        To see all the virtual machines with their associated names for a specific
        resource group, run the `azure-vm-list-instances` command.
      name: virtual_machine_name
      required: true
    description: Gets the properties of a given virtual machine.
    name: azure-vm-get-instance-details
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the virtual machine you want to get details of.
      type: string
    - contextPath: Azure.Compute.ID
      description: The ID of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Size
      description: The size of the deployed virtual machine (in gigabytes).
      type: number
    - contextPath: Azure.Compute.OS
      description: The OS running on the given virtual machine.
      type: string
    - contextPath: Azure.Compute.ProvisioningState
      description: The provisioning state of the deployed virtual machine.
      type: string
    - contextPath: Azure.Compute.Location
      description: The region in which the virtual machine is hosted.
      type: string
    - contextPath: Azure.Compute.PowerState
      description: Whether the virtual machine instance is powered on or off.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group to which the virtual machine belongs.
      type: string
  - arguments:
    - description: The resource group to which the new virtual machine will belong.
        To see all the resource groups associated with your subscription, run the
        `azure-list-resource-groups` command. If none are present, navigate to the
        Azure Web Portal to create resource groups.
      name: resource_group
      required: true
    - description: The name of the virtual machine to create.
      name: virtual_machine_name
      required: true
    - auto: PREDEFINED
      description: The location in which to create the virtual machine.
      name: virtual_machine_location
      predefined:
      - westus2
      - westus
      - westindia
      - westeurope
      - westcentralus
      - uksouth
      - ukwest
      - southeastasia
      - northcentralus
      - northeurope
      - southcentralus
      - southindia
      - francesouth
      - francecentral
      - japaneast
      - japanwest
      - koreacentral
      - koreasouth
      - brazilsouth
      - canadacentral
      - canadaeast
      - centralindia
      - eastus2
      - eastasia
      - westus
      - centralus
      - eastus
      - australiacentral
      - australiacentral2
      - australiaeast
      - australiasoutheast
      required: true
    - description: The name of the Network Interface to link the virtual machine with.
        A Network Interface has to be created in the Azure Portal. Note that the virtual
        machine's location property must match that of the Network Interface you choose
        to link it to. To see a list of available Network Interfaces visit the Azure
        Web Portal, navigate to the search bar at the top of the page, type "network
        interfaces", and in the dynamic drop-down menu that appears, click the 'Network
        interfaces' option that appears under the 'Services' category. If none are
        present, you will need to create a new Network Interface which you can do
        by clicking the '+Add' button towards the top left of the page and following
        the instructions. For more information regarding Network Interfaces, see the
        [Azure documentation](https://docs.microsoft.com/en-us/azure/virtual-network/virtual-network-network-interface).
      name: nic_name
      required: true
    - auto: PREDEFINED
      description: The name of a VirtualMachineSize, which determines the size of
        the deployed virtual machine. For more information, see the [Azure documentation](https://docs.microsoft.com/en-us/rest/api/compute/virtualmachines/listavailablesizes#virtualmachinesize).
      name: vm_size
      predefined:
      - Standard_D1_v2
      - Standard_D2_v2
      - Standard_D2s_v3
      - Standard_B1ms
      - Standard_B1s
      - Standard_B2s
      - Standard_B4ms
      - Standard_D4s_v3
      - Standard_DS1_v2
      - Standard_DS2_v2
      - Standard_DS3_v2
      - Promo_DS2_v2
      - Promo_DS3_v2
      required: true
    - auto: PREDEFINED
      description: The base operating system image of the virtual machine.
      name: os_image
      predefined:
      - Ubuntu Server 14.04 LTS
      - Ubuntu Server 16.04 LTS
      - Ubuntu Server 18.04 LTS
      - Red Hat Enterprise Linux 7.6
      - CentOS-based 7.5
      - Windows Server 2012 R2 Datacenter
      - Windows Server 2016 Datacenter
      - Windows 10 Pro Version 1803
      - Windows 10 Pro Version 1809
    - defaultValue: 2016-Datacenter
      description: SKU of the OS image to be used. To see a list of available SKUs,
        visit your Azure Web Portal, click the symbol that looks similar to a '>'
        on the top bar of the page. This should open a cloud shell, make sure it is
        a bash shell. At the command prompt enter `az vm image list-skus` along with
        the appropriate arguments that it will prompt you with to display the list
        of VM image SKUs available in the Azure Marketplace.
      name: sku
    - defaultValue: MicrosoftWindowsServer
      description: Name of the publisher of the OS image. To see a list of available
        publishers, visit your Azure Web Portal, click the symbol that looks similar
        to a '>' on the top bar of the page which should open a cloud shell, make
        sure it is a bash shell. At the command prompt enter `az vm image list-publishers`
        along with the appropriate arguments that it will prompt you with to display
        the list of VM image publishers available in the Azure Marketplace.
      name: publisher
    - defaultValue: latest
      description: Version of the image to use. The supported formats are Major.Minor.Build
        or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest'
        to use the latest version of an image available at deploy time.
      name: version
    - defaultValue: WindowsServer
      description: Specifies the offer of the platform image or marketplace image
        used to create the virtual machine. To see a list of available offers, visit
        your Azure Web Portal, click the symbol that looks similar to a '>' on the
        top bar of the page which should open a cloud shell, make sure it is a bash
        shell. At the command prompt enter `az vm image list-offers` along with the
        appropriate arguments that it will prompt you with to display the list of
        VM image offers available in the Azure Marketplace.
      name: offer
    - defaultValue: DemistoUser
      description: The admin username to use when creating the virtual machine.
      name: admin_username
    - defaultValue: Passw0rd@123
      description: The admin password to use when creating the virtual machine.
      name: admin_password
    description: Creates a virtual machine instance with the specified OS image.
    execution: true
    name: azure-vm-create-instance
    outputs:
    - contextPath: Azure.Compute.Name
      description: The name of the created virtual machine instance.
      type: string
    - contextPath: Azure.Compute.ResourceGroup
      description: The resource group in which the virtual machine resides.
      type: string
    - contextPath: Azure.Compute.ID
      description: The ID of the virtual machine.
      type: string
    - contextPath: Azure.Compute.Size
      description: The size of the deployed virtual machine (in gigabytes).
      type: number
    - contextPath: Azure.Compute.OS
      description: The OS running on the specified virtual machine.
      type: string
    - contextPath: Azure.Compute.ProvisioningState
      description: The provisioning state of the deployed virtual machine.
      type: string
    - contextPath: Azure.Compute.Location
      description: The region in which the virtual machine is hosted.
      type: string
  - arguments:
    - description: Subscription ID to use. Can be retrieved from the azure-sc-list-subscriptions
        command. If not specified, the default subscripton ID will be used.
      name: subscription_id
    description: Lists all resource groups that belong to your Azure subscription.
    name: azure-list-resource-groups
    outputs:
    - contextPath: Azure.ResourceGroup.Name
      description: The name of the resource group.
      type: string
    - contextPath: Azure.ResourceGroup.ID
      description: The ID of the resource group.
      type: string
    - contextPath: Azure.ResourceGroup.Location
      description: The location of the resource group.
      type: string
    - contextPath: Azure.ResourceGroup.ProvisioningState
      description: The provisioning state of the resource group.
      type: string
  - arguments:
    - description: The resource group to which the virtual machine belongs. To see
        all the resource groups associated with your subscription, run the `azure-list-resource-groups`
        command. If none are present, navigate to the Azure Web Portal to create resource
        groups.
      name: resource_group
      required: true
    - description: The name of the virtual machine to delete. To see all the virtual
        machines with their associated names for a specific resource group, run the
        `azure-vm-list-instances` command.
      name: virtual_machine_name
    description: Deletes a specified virtual machine.
    name: azure-vm-delete-instance
  - arguments: []
    description: Lists the subscriptions for this application.
    name: azure-list-subscriptions
    outputs:
    - contextPath: Azure.Subscription.ID
      description: The ID of the subscription.
      type: String
    - contextPath: Azure.Subscription.Name
      description: The name of the subscription.
      type: String
    - contextPath: Azure.Subscription.State
      description: The state of the subscription.
      type: String
  dockerimage: demisto/crypto:1.0.0.7634
  runonce: false
  script: |2




    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    '''GLOBAL VARS'''
    API_VERSION = '2018-06-01'
    APP_NAME = 'ms-azure-compute'

    # Image options to be used in the create_vm_command
    IMAGES = {
        'ubuntu server 14.04 lts': {
            'publisher': 'Canonical',
            'offer': 'UbuntuServer',
            'sku': '14.04-LTS',
            'version': 'latest'
        },
        'ubuntu server 16.04 lts': {
            'publisher': 'Canonical',
            'offer': 'UbuntuServer',
            'sku': '16.04-LTS',
            'version': 'latest'
        },
        'ubuntu server 18.04 lts': {
            'publisher': 'Canonical',
            'offer': 'UbuntuServer',
            'sku': '18.04-LTS',
            'version': 'latest'
        },
        'red hat enterprise linux 7.6': {
            'publisher': 'RedHat',
            'offer': 'RHEL',
            'sku': '7-RAW',
            'version': 'latest'
        },
        'centos-based 7.5': {
            'publisher': 'OpenLogic',
            'offer': 'CentOS',
            'sku': '7.5',
            'version': 'latest'
        },
        'windows server 2012 r2 datacenter': {
            'publisher': 'MicrosoftWindowsServer',
            'offer': 'WindowsServer',
            'sku': '2012-R2-Datacenter',
            'version': 'latest'
        },
        'windows server 2016 datacenter': {
            'publisher': 'MicrosoftWindowsServer',
            'offer': 'WindowsServer',
            'sku': '2016-Datacenter',
            'version': 'latest'
        },
        'windows 10 pro version 1803': {
            'publisher': 'MicrosoftWindowsDesktop',
            'offer': 'Windows-10',
            'sku': 'rs4-pro',
            'version': 'latest'
        },
        'windows 10 pro version 1809': {
            'publisher': 'MicrosoftWindowsDesktop',
            'offer': 'Windows-10',
            'sku': 'rs5-pro',
            'version': 'latest'
        }
    }

    # Error messages for different provisioning states
    CREATING_OR_UPDATING_ERR = 'Please wait for the VM to finish being' \
                               ' {} before executing this command. To retrieve the ' \
                               'last known state of the VM, execute the ' \
                               '`azure-vm-get-instance-details` command. '
    DELETING_ERR = 'You cannot execute this command because the VM is being deleted.'
    FAILED_ERR = 'Unable to power-off or power-on \'{}\' virtual machine ' \
                 'because the following provisioning failure occurred during ' \
                 'the vm\'s creation.\ncode: "{}"\nmessage: "{}"\nVisit the ' \
                 'Azure Web Portal to take care of this issue.'

    # Error messages determined by the provisioning state of the VM
    PROVISIONING_STATE_TO_ERRORS = {
        'creating': CREATING_OR_UPDATING_ERR.format('created'),
        'updating': CREATING_OR_UPDATING_ERR.format('updated'),
        'deleting': DELETING_ERR,
        'failed': FAILED_ERR
    }

    '''HELPER FUNCTIONS'''


    def screen_errors(error_message, *args, **kwargs):
        """
        Make sure that the values passed as args and the keys in kwargs do not appear in error messages

        parameter: (string) error_message
            The error message that needs to be screened for the values in args and the keys
            in kwargs

        parameter: (list) *args
            Arguments that need to be screened from error outputs and that will be replaced
            by x's enclosed by a '<' symbol on the left, and a '>' symbol on the right

        parameter: (dict) **kwargs
            Key-value pairs for each of which the user wishes to screen the key identifier string
            from the error_message and replace it with its assigned value string. Useful for
            when the user wishes to replace sensitive data with a value of their choosing
            instead of the default x's enclosed by '<', and '>' symbols on the left and right respectively

        returns:
            The error message free of sensitive information as determined by the values of
            args and the keys of kwargs
        """
        if isinstance(error_message, Exception):
            # Format Exception object as String
            error_as_dict = vars(error_message)
            updated_error_message = ''
            for key, val in error_as_dict.items():
                if updated_error_message != '':
                    updated_error_message += '\n' + str(key) + ': ' + str(val)
                else:
                    updated_error_message += str(key) + ': ' + str(val)
        elif not isinstance(error_message, str):
            # If not an Exception or a String, try to cast to a string
            updated_error_message = str(error_message)
        else:
            updated_error_message = error_message

        for argument in args:
            if argument != '' and argument in updated_error_message:
                length = len(argument)
                placeholder = '<' + 'x' * length + '>'
                updated_error_message = updated_error_message.replace(argument, placeholder)

        for key, value in kwargs.items():
            if key != '' and key in updated_error_message:
                updated_error_message = updated_error_message.replace(key, value)

        return updated_error_message


    def assign_image_attributes(image):
        """
        Retrieve image properties determined by the chosen image

        returns:
            Image Properties Tuple (sku, publisher, offer, version)
        """
        image = image.lower()
        image_properties = IMAGES.get(image)
        if not image_properties:
            err_msg = 'Invalid value entered for the \'os_image\' argument. '
            err_msg += 'Only values from the provided options are accepted.'
            raise Exception(err_msg)
        sku = image_properties.get('sku')
        publisher = image_properties.get('publisher')
        offer = image_properties.get('offer')
        version = image_properties.get('version')
        return sku, publisher, offer, version


    def create_vm_parameters(args, subscription_id):
        """
        Construct the VM object

        Use the actual parameters passed to the 'azure-vm-create-instance' command
        to build a vm object that will be sent in the body of the command's associated
        API call.

        parameter: (dict) args
            Dictionary that contains the actual parameters that were passed to the
            'azure-vm-create-instance' command

        returns:
            Virtual Machine Object
        """
        # Retrieve relevant command arguments
        location = args.get('virtual_machine_location')
        vm_size = args.get('vm_size')
        image = args.get('os_image')
        sku = args.get('sku')
        publisher = args.get('publisher')
        version = args.get('version')
        offer = args.get('offer')
        vm_name = args.get('virtual_machine_name')
        resource_group = args.get('resource_group')
        admin_username = args.get('admin_username')
        admin_password = args.get('admin_password')
        nic_name = args.get('nic_name')
        full_nic_id = f"/subscriptions/{subscription_id}/resourceGroups/"  # type: ignore
        full_nic_id += f"{resource_group}/providers/Microsoft.Network/networkInterfaces/{nic_name}"

        if not image and not (sku and publisher and version and offer):
            err_msg = 'You must enter a value for the \'os_image\' argument '
            err_msg += 'or the group of arguments, \'sku\', \'publisher\', \'version\', and \'offer\'.'
            raise Exception(err_msg)

        if image:
            sku, publisher, offer, version = assign_image_attributes(image)

        # Construct VM object
        vm = {
            'location': location,
            'properties': {
                'hardwareProfile': {
                    'vmSize': vm_size
                },
                'storageProfile': {
                    'imageReference': {
                        'sku': sku,
                        'publisher': publisher,
                        'version': version,
                        'offer': offer
                    },
                    'osDisk': {
                        'caching': 'ReadWrite',
                        'managedDisk': {
                            'storageAccountType': 'Standard_LRS'
                        },
                        'name': vm_name,
                        'createOption': 'FromImage'
                    }
                },
                'osProfile': {
                    'adminUsername': admin_username,
                    'computerName': vm_name,
                    'adminPassword': admin_password
                },
                'networkProfile': {
                    'networkInterfaces': [
                        {
                            'id': full_nic_id,
                            'properties': {
                                'primary': 'true'
                            }
                        }
                    ]
                }
            },
            'name': vm_name
        }

        return vm


    class MsGraphClient:
        """
          Microsoft Graph Client enables authorized access to Create and Manage Azure Virtual Machines.
          """

        def __init__(self, tenant_id, auth_id, enc_key, app_name, base_url, verify, proxy, self_deployed, ok_codes, server,
                     subscription_id):

            self.ms_client = MicrosoftClient(
                tenant_id=tenant_id, auth_id=auth_id, enc_key=enc_key, app_name=app_name, base_url=base_url, verify=verify,
                proxy=proxy, self_deployed=self_deployed, ok_codes=ok_codes)
            self.server = server
            self.subscription_id = subscription_id

        def list_resource_groups(self):
            parameters = {'api-version': '2018-05-01'}
            return self.ms_client.http_request(method='GET', params=parameters, url_suffix='')

        def list_subscriptions(self):
            parameters = {'api-version': '2017-05-10'}
            url = self.server + '/subscriptions'
            return self.ms_client.http_request(method='GET', full_url=url, params=parameters, url_suffix='')

        def list_vms(self, resource_group):
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines"

            parameters = {'api-version': API_VERSION}
            return self.ms_client.http_request(method='GET', url_suffix=url_suffix, params=parameters)

        def get_vm(self, resource_group, vm_name):
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}"
            parameters = {'$expand': 'instanceView', 'api-version': API_VERSION}
            return self.ms_client.http_request(method='GET', url_suffix=url_suffix, params=parameters)

        def create_vm(self, args):
            # Retrieve relevant command argument
            resource_group = args.get('resource_group')
            vm_name = args.get('virtual_machine_name')

            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}"
            parameters = {'api-version': API_VERSION}

            # Construct VM object utilizing parameters passed as command arguments
            payload = create_vm_parameters(args, self.subscription_id)
            return self.ms_client.http_request(method='PUT', url_suffix=url_suffix, params=parameters, json_data=payload)

        def delete_vm(self, resource_group, vm_name):
            # Construct endpoint URI suffix (for de-allocation of compute resources)
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}/deallocate"
            parameters = {'api-version': API_VERSION}

            # Call API to deallocate compute resources
            self.ms_client.http_request(method='POST', url_suffix=url_suffix, params=parameters, resp_type="response")

            # Construct endpoint URI suffix (for deletion)
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}"
            parameters = {'api-version': API_VERSION}

            # Call API to delete
            return self.ms_client.http_request(
                method='DELETE', url_suffix=url_suffix, params=parameters, resp_type="response")

        def start_vm(self, resource_group, vm_name):
            # Retrieve relevant command arguments
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}/start"
            parameters = {'api-version': API_VERSION}

            # Call API
            return self.ms_client.http_request(
                method='POST', url_suffix=url_suffix, params=parameters, resp_type="response")

        def poweroff_vm(self, resource_group, vm_name):
            url_suffix = f"{resource_group}/providers/Microsoft.Compute/virtualMachines/{vm_name}/powerOff"
            parameters = {'api-version': API_VERSION}

            return self.ms_client.http_request(
                method='POST', url_suffix=url_suffix, params=parameters, resp_type="response")

        def validate_provisioning_state(self, resource_group, vm_name):
            """
            Ensure that the provisioning state of a VM is 'Succeeded'

            For all provisioning states other than 'Succeeded', this method will raise an
            exception with an informative error message.

            parameter: (dict) args
                The command arguments passed to either the `azure-vm-start-instance` or
                `azure-vm-poweroff-instance` commands

            returns:
                None
            """
            response = self.get_vm(resource_group, vm_name)
            # Retrieve relevant properties for checking provisioning state and returning
            # informative error messages if necessary

            properties = response.get('properties')
            provisioning_state = properties.get('provisioningState')
            statuses = properties.get('instanceView', {}).get('statuses')

            # Check if the current ProvisioningState of the VM allows for executing this command
            if provisioning_state.lower() == 'failed':
                for status in statuses:
                    status_code = status.get('code')
                    if 'provisioningstate/failed' in status_code.lower():
                        message = status.get('message')
                        err_msg = PROVISIONING_STATE_TO_ERRORS.get('failed')
                        raise Exception(err_msg.format(vm_name, status_code, message))  # type: ignore
                # In the case that the microsoft API changes and the status code is no longer
                # relevant, preventing the above exception with its detailed error message from
                # being raised, then raise the below exception with a more general error message
                err_msg = 'Cannot execute this command because the ProvisioningState of the VM is \'Failed\'.'
                raise Exception(err_msg)
            elif provisioning_state.lower() in PROVISIONING_STATE_TO_ERRORS.keys():
                err_msg = PROVISIONING_STATE_TO_ERRORS.get(provisioning_state.lower())
                raise Exception(err_msg)


    def test_module(client: MsGraphClient, args: dict):
        # Implicitly will test tenant, enc_token and subscription_id
        client.list_resource_groups()
        return 'ok', None, None


    # <-------- Resource Groups --------> #

    def list_resource_groups_command(client: MsGraphClient, args: dict):
        """
        List all Resource Groups belonging to your Azure subscription

        returns:
            Resource-Group Objects
        """
        response = client.list_resource_groups()
        # Retrieve relevant properties to return to context
        value = response.get('value')
        resource_groups = []
        for resource_group in value:
            resource_group_context = {
                'Name': resource_group.get('name'),
                'ID': resource_group.get('id'),
                'Location': resource_group.get('location'),
                'ProvisioningState': resource_group.get('properties', {}).get('provisioningState')
            }
            resource_groups.append(resource_group_context)

        title = 'List of Resource Groups'
        human_readable = tableToMarkdown(title, resource_groups, removeNull=True)
        entry_context = {'Azure.ResourceGroup(val.Name && val.Name === obj.Name)': resource_groups}
        return human_readable, entry_context, response


    # <-------- Subscriptions --------> #

    def list_subscriptions_command(client: MsGraphClient, args: dict):
        """
        List all subscriptions for this application

        returns:
            Subscription Objects
        """
        response = client.list_subscriptions()
        # Retrieve relevant properties to return to context
        value = response.get('value')
        subscriptions = []
        for subscription in value:
            subscription_context = {
                'Name': subscription.get('displayName'),
                'ID': subscription.get('id'),
                'State': subscription.get('state')
            }
            subscriptions.append(subscription_context)

        title = 'List of Subscriptions'
        human_readable = tableToMarkdown(title, subscriptions, removeNull=True)
        entry_context = {'Azure.Subscription(val.ID && val.ID === obj.ID)': subscriptions}
        return human_readable, entry_context, response


    # <-------- Virtual Machines --------> #

    def list_vms_command(client: MsGraphClient, args: dict):
        """
        List the VM instances in the specified Resource Group

        demisto parameter: (string) resource_group
            Resource Group of the VMs

        returns:
            Virtual Machine Objects
        """
        resource_group = args.get('resource_group')
        response = client.list_vms(resource_group)

        vm_objects_list = response.get('value')

        vms = []
        for vm_object in vm_objects_list:
            vm_name = vm_object.get('name').lower()
            location = vm_object.get('location')
            properties = vm_object.get('properties')
            provisioning_state = properties.get('provisioningState')
            os_disk = properties.get('storageProfile', {}).get('osDisk')
            datadisk = os_disk.get('diskSizeGB', 'NA')
            vm_id = properties.get('vmId')
            os_type = os_disk.get('osType')
            vm = {
                'Name': vm_name,
                'ID': vm_id,
                'Size': datadisk,
                'OS': os_type,
                'Location': location,
                'ProvisioningState': provisioning_state,
                'ResourceGroup': resource_group
            }
            vms.append(vm)

        title = 'Microsoft Azure - List of Virtual Machines in Resource Group "{}"'.format(resource_group)
        table_headers = ['Name', 'ID', 'Size', 'OS', 'Location', 'ProvisioningState', 'ResourceGroup']
        human_readable = tableToMarkdown(title, vms, headers=table_headers, removeNull=True)
        entry_context = {'Azure.Compute(val.Name && val.Name === obj.Name)': vms}
        return human_readable, entry_context, response


    def get_vm_command(client: MsGraphClient, args: dict):
        """
        Get the properties of a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine you wish to view the details of

        returns:
            Virtual Machine Object
        """
        resource_group = args.get('resource_group')
        vm_name = args.get('virtual_machine_name')

        response = client.get_vm(resource_group, vm_name)

        # Retrieve relevant properties to return to context
        vm_name = vm_name.lower()  # type: ignore
        properties = response.get('properties')
        os_disk = properties.get('storageProfile', {}).get('osDisk')
        datadisk = os_disk.get('diskSizeGB', 'NA')
        vm_id = properties.get('vmId')
        os_type = os_disk.get('osType')
        provisioning_state = properties.get('provisioningState')
        location = response.get('location')
        statuses = properties.get('instanceView', {}).get('statuses')
        power_state = None
        for status in statuses:
            status_code = status.get('code')
            status_code_prefix = status_code[:status_code.find('/')]
            if status_code_prefix == 'PowerState':
                power_state = status.get('displayStatus')

        vm = {
            'Name': vm_name,
            'ID': vm_id,
            'Size': datadisk,
            'OS': os_type,
            'ProvisioningState': provisioning_state,
            'Location': location,
            'PowerState': power_state,
            'ResourceGroup': args.get('resource_group')
        }

        title = 'Properties of VM "{}"'.format(vm_name)
        table_headers = ['Name', 'ID', 'Size', 'OS', 'ProvisioningState', 'Location', 'PowerState']
        human_readable = tableToMarkdown(title, vm, headers=table_headers, removeNull=True)
        entry_context = {'Azure.Compute(val.Name && val.Name === obj.Name)': vm}
        return human_readable, entry_context, response


    def create_vm_command(client: MsGraphClient, args: dict):
        """
        Create a virtual machine instance with the specified OS image

        demisto parameter: (string) resource_group
            Resource group to which the new VM will belong

        demisto parameter: (string) virtual_machine_name
            Name to assign to the new virtual machine

        demisto parameter: (string) virtual_machine_location
            Region in which the vm will be hosted

        demisto parameter: (string) nic_name
            The name of the Network Interface to link the VM with. This must be created from the Azure Portal

        demisto parameter: (string) vm_size
            The name of a VirtualMachineSize which determines the size of the deployed vm

        demisto parameter: (string) os_image
            Choose the base operating system image of the vm

        demisto parameter: (string) sku
            SKU of the image to be used

        demisto parameter: (string) publisher
            Name of the publisher of the image

        demisto parameter: (string) version
            Version of the image to use

        demisto parameter: (string) offer
            Specifies the offer of the platform image or marketplace image used
            to create the virtual machine

        demisto parameter: (string) admin_username
            Admin Username to be used when creating the VM

        demisto parameter: (string) admin_password
            Admin Password to be used when creating the VM

        returns:
            Virtual Machine Object
        """
        response = client.create_vm(args)

        # Retrieve relevant properties to return to context
        vm_name = response.get('name').lower()
        properties = response.get('properties')
        os_disk = properties.get('storageProfile', {}).get('osDisk')
        datadisk = os_disk.get('diskSizeGB', 'NA')
        vm_id = properties.get('vmId')
        os_type = os_disk.get('osType')
        provisioning_state = properties.get('provisioningState')
        location = response.get('location')

        vm = {
            'Name': vm_name,
            'ID': vm_id,
            'Size': datadisk,
            'OS': os_type,
            'ProvisioningState': provisioning_state,
            'Location': location,
            'ResourceGroup': args.get('resource_group')
        }

        title = 'Created Virtual Machine "{}"'.format(vm_name)
        human_readable = tableToMarkdown(title, vm, removeNull=True)
        entry_context = {'Azure.Compute(val.Name && val.Name === obj.Name)': vm}
        return human_readable, entry_context, response


    def delete_vm_command(client: MsGraphClient, args: dict):
        """
        Delete a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine to delete

        returns:
            Success message to the war room
        """
        resource_group = args.get('resource_group')
        vm_name = args.get('virtual_machine_name')

        client.delete_vm(resource_group, vm_name)
        success_msg = '"{}" VM Deletion Successfully Initiated'.format(vm_name)
        return success_msg, None, None


    def start_vm_command(client: MsGraphClient, args: dict):
        """
        Power-on a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine to power-on

        returns:
            Virtual Machine Object
        """
        resource_group = args.get('resource_group')
        vm_name = args.get('virtual_machine_name')

        # Raise an exception if the VM isn't in the proper provisioning state
        client.validate_provisioning_state(resource_group, vm_name)

        client.start_vm(resource_group, vm_name)
        vm_name = vm_name.lower()   # type: ignore
        vm = {
            'Name': vm_name,
            'ResourceGroup': args.get('resource_group'),
            'PowerState': 'VM starting'
        }

        title = 'Power-on of Virtual Machine "{}" Successfully Initiated'.format(vm_name)
        human_readable = tableToMarkdown(title, vm, removeNull=True)
        entry_context = {'Azure.Compute(val.Name && val.Name === obj.Name)': vm}

        return human_readable, entry_context, vm


    def poweroff_vm_command(client: MsGraphClient, args: dict):
        """
        Power-off a specified Virtual Machine

        demisto parameter: (string) resource_group
            Resource Group to which the virtual machine belongs

        demisto parameter: (string) virtual_machine_name
            Name of the virtual machine to power-off

        returns:
            Virtual Machine Object
        """
        resource_group = args.get('resource_group')
        vm_name = args.get('virtual_machine_name')

        # Raise an exception if the VM isn't in the proper provisioning state
        client.validate_provisioning_state(resource_group, vm_name)

        client.poweroff_vm(resource_group, vm_name)

        vm_name = vm_name.lower()   # type: ignore
        vm = {
            'Name': vm_name,
            'ResourceGroup': args.get('resource_group'),
            'PowerState': 'VM stopping'
        }

        title = 'Power-off of Virtual Machine "{}" Successfully Initiated'.format(vm_name)
        human_readable = tableToMarkdown(title, vm, removeNull=True)
        entry_context = {'Azure.Compute(val.Name && val.Name === obj.Name)': vm}

        return human_readable, entry_context, vm


    def main():
        params: dict = demisto.params()
        server = params.get('host', 'https://management.azure.com').rstrip('/')
        tenant = params.get('tenant_id')
        auth_and_token_url = params.get('auth_id')
        enc_key = params.get('enc_key')
        verify = not params.get('unsecure', False)
        subscription_id = demisto.args().get('subscription_id') or demisto.params().get('subscription_id')
        proxy: bool = params.get('proxy', False)
        self_deployed: bool = params.get('self_deployed', False)
        ok_codes = (200, 201, 202, 204)

        commands = {
            'test-module': test_module,
            'azure-vm-list-instances': list_vms_command,
            'azure-vm-get-instance-details': get_vm_command,
            'azure-vm-start-instance': start_vm_command,
            'azure-vm-poweroff-instance': poweroff_vm_command,
            'azure-vm-create-instance': create_vm_command,
            'azure-vm-delete-instance': delete_vm_command,
            'azure-list-resource-groups': list_resource_groups_command,
            'azure-list-subscriptions': list_subscriptions_command
        }

        '''EXECUTION'''
        command = demisto.command()
        LOG(f'Command being called is {command}')

        try:
            # Initial setup
            if not subscription_id:
                return_error('A subscription ID must be provided.')
            base_url = f"{server}/subscriptions/{subscription_id}/resourceGroups/"

            client = MsGraphClient(
                base_url=base_url, tenant_id=tenant, auth_id=auth_and_token_url, enc_key=enc_key, app_name=APP_NAME,
                verify=verify, proxy=proxy, self_deployed=self_deployed, ok_codes=ok_codes, server=server,
                subscription_id=subscription_id)

            human_readable, entry_context, raw_response = commands[command](client, demisto.args())  # type: ignore
            return_outputs(readable_output=human_readable, outputs=entry_context, raw_response=raw_response)

        except Exception as e:
            screened_error_message = screen_errors(str(e), tenant)
            return_error(screened_error_message)



    ### GENERATED CODE ###
    # This code was inserted in place of an API module.import traceback




    import requests
    import base64
    from cryptography.hazmat.primitives.ciphers.aead import AESGCM
    from typing import Dict, Tuple

    # authorization types
    OPROXY_AUTH_TYPE = 'oproxy'
    SELF_DEPLOYED_AUTH_TYPE = 'self_deployed'

    # grant types in self-deployed authorization
    CLIENT_CREDENTIALS = 'client_credentials'
    AUTHORIZATION_CODE = 'authorization_code'
    REFRESH_TOKEN = 'refresh_token'  # guardrails-disable-line


    class MicrosoftClient(BaseClient):

        def __init__(self, tenant_id: str = '',
                     auth_id: str = '',
                     enc_key: str = '',
                     token_retrieval_url: str = 'https://login.microsoftonline.com/{tenant_id}/oauth2/v2.0/token',
                     app_name: str = '',
                     refresh_token: str = '',
                     auth_code: str = '',
                     scope: str = 'https://graph.microsoft.com/.default',
                     grant_type: str = CLIENT_CREDENTIALS,
                     redirect_uri: str = 'https://localhost/myapp',
                     resource: str = '',
                     verify: bool = True,
                     self_deployed: bool = False,
                     *args, **kwargs):
            """
            Microsoft Client class that implements logic to authenticate with oproxy or self deployed applications.
            It also provides common logic to handle responses from Microsoft.
            Args:
                tenant_id: If self deployed it's the tenant for the app url, otherwise (oproxy) it's the token
                auth_id: If self deployed it's the client id, otherwise (oproxy) it's the auth id and may also
                contain the token url
                enc_key: If self deployed it's the client secret, otherwise (oproxy) it's the encryption key
                scope: The scope of the application (only if self deployed)
                resource: The resource of the application (only if self deployed)
                verify: Demisto insecure parameter
                self_deployed: Indicates whether the integration mode is self deployed or oproxy
            """
            super().__init__(verify=verify, *args, **kwargs)  # type: ignore[misc]

            if not self_deployed:
                auth_id_and_token_retrieval_url = auth_id.split('@')
                auth_id = auth_id_and_token_retrieval_url[0]
                if len(auth_id_and_token_retrieval_url) != 2:
                    self.token_retrieval_url = 'https://oproxy.demisto.ninja/obtain-token'  # guardrails-disable-line
                else:
                    self.token_retrieval_url = auth_id_and_token_retrieval_url[1]

                self.app_name = app_name
                self.auth_id = auth_id
                self.enc_key = enc_key
                self.tenant_id = tenant_id
                self.refresh_token = refresh_token

            else:
                self.token_retrieval_url = token_retrieval_url.format(tenant_id=tenant_id)
                self.client_id = auth_id
                self.client_secret = enc_key
                self.tenant_id = tenant_id
                self.auth_code = auth_code
                self.grant_type = grant_type
                self.resource = resource
                self.scope = scope
                self.redirect_uri = redirect_uri

            self.auth_type = SELF_DEPLOYED_AUTH_TYPE if self_deployed else OPROXY_AUTH_TYPE
            self.verify = verify

        def http_request(self, *args, resp_type='json', headers=None, return_empty_response=False, **kwargs):
            """
            Overrides Base client request function, retrieves and adds to headers access token before sending the request.

            Returns:
                requests.Response: The http response
            """
            token = self.get_access_token()
            default_headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
            if headers:
                default_headers.update(headers)

            response = super()._http_request(   # type: ignore[misc]
                *args, resp_type="response", headers=default_headers, **kwargs)

            # 206 indicates Partial Content, reason will be in the warning header.
            # In that case, logs with the warning header will be written.
            if response.status_code == 206:
                demisto.debug(str(response.headers))

            is_response_empty_and_successful = (response.status_code == 204)
            if is_response_empty_and_successful and return_empty_response:
                return response

            try:
                if resp_type == 'json':
                    return response.json()
                if resp_type == 'text':
                    return response.text
                if resp_type == 'content':
                    return response.content
                if resp_type == 'xml':
                    ET.parse(response.text)
                return response
            except ValueError as exception:
                raise DemistoException('Failed to parse json object from response: {}'.format(response.content), exception)

        def get_access_token(self):
            """
            Obtains access and refresh token from oproxy server or just a token from a self deployed app.
            Access token is used and stored in the integration context
            until expiration time. After expiration, new refresh token and access token are obtained and stored in the
            integration context.

            Returns:
                str: Access token that will be added to authorization header.
            """
            integration_context = demisto.getIntegrationContext()
            access_token = integration_context.get('access_token')
            refresh_token = integration_context.get('current_refresh_token', '')
            valid_until = integration_context.get('valid_until')
            if access_token and valid_until:
                if self.epoch_seconds() < valid_until:
                    return access_token

            auth_type = self.auth_type
            if auth_type == OPROXY_AUTH_TYPE:
                access_token, expires_in, refresh_token = self._oproxy_authorize()
            else:
                access_token, expires_in, refresh_token = self._get_self_deployed_token(refresh_token)
            time_now = self.epoch_seconds()
            time_buffer = 5  # seconds by which to shorten the validity period
            if expires_in - time_buffer > 0:
                # err on the side of caution with a slightly shorter access token validity period
                expires_in = expires_in - time_buffer

            integration_context = {
                'access_token': access_token,
                'current_refresh_token': refresh_token,
                'valid_until': time_now + expires_in,
            }

            demisto.setIntegrationContext(integration_context)
            return access_token

        def _oproxy_authorize(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing with oproxy.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            content = self.refresh_token or self.tenant_id
            headers = self._add_info_headers()
            oproxy_response = requests.post(
                self.token_retrieval_url,
                headers=headers,
                json={
                    'app_name': self.app_name,
                    'registration_id': self.auth_id,
                    'encrypted_token': self.get_encrypted(content, self.enc_key)
                },
                verify=self.verify
            )

            if not oproxy_response.ok:
                msg = 'Error in authentication. Try checking the credentials you entered.'
                try:
                    demisto.info('Authentication failure from server: {} {} {}'.format(
                        oproxy_response.status_code, oproxy_response.reason, oproxy_response.text))
                    err_response = oproxy_response.json()
                    server_msg = err_response.get('message')
                    if not server_msg:
                        title = err_response.get('title')
                        detail = err_response.get('detail')
                        if title:
                            server_msg = f'{title}. {detail}'
                        elif detail:
                            server_msg = detail
                    if server_msg:
                        msg += ' Server message: {}'.format(server_msg)
                except Exception as ex:
                    demisto.error('Failed parsing error response - Exception: {}'.format(ex))
                raise Exception(msg)
            try:
                gcloud_function_exec_id = oproxy_response.headers.get('Function-Execution-Id')
                demisto.info(f'Google Cloud Function Execution ID: {gcloud_function_exec_id}')
                parsed_response = oproxy_response.json()
            except ValueError:
                raise Exception(
                    'There was a problem in retrieving an updated access token.\n'
                    'The response from the Oproxy server did not contain the expected content.'
                )

            return (parsed_response.get('access_token', ''), parsed_response.get('expires_in', 3595),
                    parsed_response.get('refresh_token', ''))

        def _get_self_deployed_token(self, refresh_token: str = ''):
            if self.grant_type == AUTHORIZATION_CODE:
                return self._get_self_deployed_token_auth_code(refresh_token)
            else:
                # by default, grant_type is CLIENT_CREDENTIALS
                return self._get_self_deployed_token_client_credentials()

        def _get_self_deployed_token_client_credentials(self) -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application in client credentials grant type.

            Returns:
                tuple: An access token and its expiry.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'grant_type': CLIENT_CREDENTIALS
            }

            if self.scope:
                data['scope'] = self.scope
            if self.resource:
                data['resource'] = self.resource

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, ''

        def _get_self_deployed_token_auth_code(self, refresh_token: str = '') -> Tuple[str, int, str]:
            """
            Gets a token by authorizing a self deployed Azure application.

            Returns:
                tuple: An access token, its expiry and refresh token.
            """
            data = {
                'client_id': self.client_id,
                'client_secret': self.client_secret,
                'resource': self.resource,
                'redirect_uri': self.redirect_uri
            }
            refresh_token = refresh_token or self._get_refresh_token_from_auth_code_param()
            if refresh_token:
                data['grant_type'] = REFRESH_TOKEN
                data['refresh_token'] = refresh_token
            else:
                data['grant_type'] = AUTHORIZATION_CODE
                data['code'] = self.auth_code

            response_json: dict = {}
            try:
                response = requests.post(self.token_retrieval_url, data, verify=self.verify)
                if response.status_code not in {200, 201}:
                    return_error(f'Error in Microsoft authorization. Status: {response.status_code},'
                                 f' body: {self.error_parser(response)}')
                response_json = response.json()
            except Exception as e:
                return_error(f'Error in Microsoft authorization: {str(e)}')

            access_token = response_json.get('access_token', '')
            # refresh_token = response_json.get('refresh_token', '')
            expires_in = int(response_json.get('expires_in', 3595))

            return access_token, expires_in, refresh_token

        def _get_refresh_token_from_auth_code_param(self) -> str:
            refresh_prefix = "refresh_token:"
            if self.auth_code.startswith(refresh_prefix):  # for testing we allow setting the refresh token directly
                demisto.debug("Using refresh token set as auth_code")
                return self.auth_code[len(refresh_prefix):]
            return ''

        @staticmethod
        def error_parser(error: requests.Response) -> str:
            """

            Args:
                error (requests.Response): response with error

            Returns:
                str: string of error

            """
            try:
                response = error.json()
                inner_error = response.get('error', {})
                if isinstance(inner_error, dict):
                    err_str = f"{inner_error.get('code')}: {inner_error.get('message')}"
                else:
                    err_str = inner_error
                if err_str:
                    return err_str
                # If no error message
                raise ValueError
            except ValueError:
                return error.text

        @staticmethod
        def epoch_seconds(d: datetime = None) -> int:
            """
            Return the number of seconds for given date. If no date, return current.

            Args:
                d (datetime): timestamp
            Returns:
                 int: timestamp in epoch
            """
            if not d:
                d = MicrosoftClient._get_utcnow()
            return int((d - MicrosoftClient._get_utcfromtimestamp(0)).total_seconds())

        @staticmethod
        def _get_utcnow() -> datetime:
            return datetime.utcnow()

        @staticmethod
        def _get_utcfromtimestamp(_time) -> datetime:
            return datetime.utcfromtimestamp(_time)

        @staticmethod
        def get_encrypted(content: str, key: str) -> str:
            """
            Encrypts content with encryption key.
            Args:
                content: Content to encrypt
                key: encryption key from oproxy

            Returns:
                timestamp: Encrypted content
            """

            def create_nonce():
                return os.urandom(12)

            def encrypt(string, enc_key):
                """
                Encrypts string input with encryption key.
                Args:
                    string: String to encrypt
                    enc_key: Encryption key

                Returns:
                    bytes: Encrypted value
                """
                # String to bytes
                try:
                    enc_key = base64.b64decode(enc_key)
                except Exception as err:
                    return_error(f"Error in Microsoft authorization: {str(err)}"
                                 f" Please check authentication related parameters.", error=traceback.format_exc())

                # Create key
                aes_gcm = AESGCM(enc_key)
                # Create nonce
                nonce = create_nonce()
                # Create ciphered data
                data = string.encode()
                ct = aes_gcm.encrypt(nonce, data, None)
                return base64.b64encode(nonce + ct)

            now = MicrosoftClient.epoch_seconds()
            encrypted = encrypt(f'{now}:{content}', key).decode('utf-8')
            return encrypted

        @staticmethod
        def _add_info_headers() -> Dict[str, str]:
            # pylint: disable=no-member
            headers = {}
            try:
                calling_context = demisto.callingContext.get('context', {})  # type: ignore[attr-defined]
                brand_name = calling_context.get('IntegrationBrand', '')
                instance_name = calling_context.get('IntegrationInstance', '')
                headers['X-Content-Version'] = CONTENT_RELEASE_VERSION
                headers['X-Content-Name'] = brand_name or instance_name or 'Name not found'
                if hasattr(demisto, 'demistoVersion'):
                    demisto_version = demisto.demistoVersion()
                    headers['X-Content-Server-Version'] = '{}-{}'.format(demisto_version.get('version'),
                                                                         demisto_version.get("buildNumber"))
            except Exception as e:
                demisto.error('Failed getting integration info: {}'.format(str(e)))

            return headers




    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()
  subtype: python3
  type: python
system: true
